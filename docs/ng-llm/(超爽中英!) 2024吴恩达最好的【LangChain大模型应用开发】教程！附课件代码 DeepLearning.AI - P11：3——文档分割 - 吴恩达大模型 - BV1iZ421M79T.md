# (超爽中英!) 2024吴恩达最好的【LangChain大模型应用开发】教程！附课件代码 DeepLearning.AI - P11：3——文档分割 - 吴恩达大模型 - BV1iZ421M79T

![](img/ebe398bb25bacc9df35d89337a0c9403_0.png)

我们刚刚讨论了如何将文档加载到标准格式，现在我们要讨论如何把它们分成更小的块，这听起来可能很容易，但这里有很多微妙之处，对未来产生了巨大的影响，让我们跳进去吧，将数据加载到文档格式后会发生文档拆分。

但在它进入矢量存储之前，这可能看起来很简单，你可以根据每个字符的长度或类似的东西来分割块。

![](img/ebe398bb25bacc9df35d89337a0c9403_2.png)

![](img/ebe398bb25bacc9df35d89337a0c9403_3.png)

但作为一个例子，为什么这既棘手又非常重要，让我们看一下这里的这个例子，我们有一个关于丰田凯美瑞的句子和一些规格。



![](img/ebe398bb25bacc9df35d89337a0c9403_5.png)

如果我们做一个简单的分裂，我们可以把句子的一部分分成一大块，句子的另一部分在另一大块中，然后当我们试图回答一个问题时。



![](img/ebe398bb25bacc9df35d89337a0c9403_7.png)

关于凯美瑞的规格是什么。

![](img/ebe398bb25bacc9df35d89337a0c9403_9.png)

我们实际上在这两个块中都没有正确的信息，所以它分裂了，所以我们不能正确地回答这个问题，因此，在如何分割大块时，有很多细微差别和重要性，这样你就可以把语义上相关的块放在一起。



![](img/ebe398bb25bacc9df35d89337a0c9403_11.png)

车道链中所有文本拆分器的基础都涉及到在块上拆分，在一些块大小和一些块重叠的情况下。

![](img/ebe398bb25bacc9df35d89337a0c9403_13.png)

所以我们在下面有一个小图来显示它是什么样子的，所以块大小对应于块的大小，块的大小可以用几种不同的方法来测量，我们将在这节课中讨论其中的一些，所以我们允许传入一个length函数来测量块的大小。

这通常是字符或令牌，块重叠通常保持为两个块之间的一点重叠，就像一扇滑动的窗户，当我们从一个移动到另一个，这允许相同的上下文在一个块的末尾，在另一个的开始，并有助于创造一些一致性的概念。

文本拆分器和链接链都有一个创建文档和拆分文档的方法，这涉及到引擎盖下相同的逻辑，它只是暴露了一个稍微不同的界面。



![](img/ebe398bb25bacc9df35d89337a0c9403_15.png)

一个接收文本列表，另一个接收文件列表，在长链中有很多不同类型的分配器，我们将在这节课中介绍其中的一些，但我会鼓励你在业余时间看看其余的，这些文本拆分器在一系列维度上有所不同。

它们可以根据如何分割大块而有所不同，里面有什么角色，它们可以根据，他们如何测量块的长度，是按人物写的吗，是用代币吗，甚至有些人使用其他较小的模型来确定句子的结尾可能是，用它来分割大块。



![](img/ebe398bb25bacc9df35d89337a0c9403_17.png)

分割成块的另一个重要部分也是元数据。

![](img/ebe398bb25bacc9df35d89337a0c9403_19.png)

在所有块中维护相同的元数据，但也会在相关时添加新的元数据，所以有一些文本拆分器真正关注于此。

![](img/ebe398bb25bacc9df35d89337a0c9403_21.png)

块的拆分通常可以特定于，我们正在处理的文档类型。

![](img/ebe398bb25bacc9df35d89337a0c9403_23.png)

当您在代码上分裂时，这一点非常明显，所以我们有一个语言文本拆分器，它有一堆不同的分隔符。

![](img/ebe398bb25bacc9df35d89337a0c9403_25.png)

对于各种不同的语言。

![](img/ebe398bb25bacc9df35d89337a0c9403_27.png)

就像蟒蛇，Ruby c，当拆分这些文件时，它考虑到了这些不同的语言和这些语言的相关分隔符。

![](img/ebe398bb25bacc9df35d89337a0c9403_29.png)

当它先劈开的时候，我们将像以前一样通过加载打开的ai api密钥来设置环境。

![](img/ebe398bb25bacc9df35d89337a0c9403_31.png)

接下来，我们将导入两种最常见的文本拆分器和长链。

![](img/ebe398bb25bacc9df35d89337a0c9403_33.png)

递归字符文本拆分器和字符文本拆分器，我们将首先讨论一些玩具用例，只是为了了解这些到底是做什么的，所以我们要设置一个相对较小的26块大小。



![](img/ebe398bb25bacc9df35d89337a0c9403_35.png)

更小的四块重叠，好让我们看看这些能做什么。

![](img/ebe398bb25bacc9df35d89337a0c9403_37.png)

让我们将这两个不同的文本拆分器初始化为r拆分器和c拆分器，然后让我们来看看几个不同的用例。

![](img/ebe398bb25bacc9df35d89337a0c9403_39.png)

让我们加载第一个学期，一直到z，让我们看看当我们使用各种拆分器时会发生什么。

![](img/ebe398bb25bacc9df35d89337a0c9403_41.png)

当我们用递归字符文本拆分器拆分它时。

![](img/ebe398bb25bacc9df35d89337a0c9403_43.png)

它最终仍然是一根弦，这是因为它有26个字符长，我们指定了26的块大小，所以现在甚至不需要在这里做任何分裂，让我们用稍微长一点的绳子来做，它比我们指定的块大小的26个字符长。

这里我们可以看到创建了两个不同的块，第一个以z结尾，那就是两个六个字，下一个我们可以看到的是以W开头的，X，Y，Z，这就是四块重叠，然后它继续与字符串的其余部分，让我们看一个稍微复杂一点的字符串。



![](img/ebe398bb25bacc9df35d89337a0c9403_45.png)

我们在角色之间有一堆空格，我们现在可以看到它分成三块，因为有空间，所以它占用了更多的空间，所以如果我们看看重叠，我们可以在第一个中看到，有llm，l和m也出现在第二个中，好像只有两个角色。

但是由于l和n之间的空间，然后在L之前和M之后，这实际上算作组成块重叠的四个，现在让我们尝试使用字符文本拆分器。



![](img/ebe398bb25bacc9df35d89337a0c9403_47.png)

当我们运行它时，我们可以看到，它实际上根本没有试图分裂它，那么这里发生了什么，问题是字符文本在单个字符上拆分。



![](img/ebe398bb25bacc9df35d89337a0c9403_49.png)

默认情况下，该字符是一个新的行字符，但这里没有新的，如果我们将分隔符设置为空白。

![](img/ebe398bb25bacc9df35d89337a0c9403_51.png)

我们可以看到会发生什么，然后呢。

![](img/ebe398bb25bacc9df35d89337a0c9403_53.png)

这里和以前一样分裂，这是暂停视频并尝试一些新示例的好点，都是你编的不同的琴弦，然后交换分离器，看看会发生什么，实验块大小和块重叠也很有趣，并大致了解几个玩具例子中发生了什么。

所以当我们转向更多现实世界的例子时，你会对幕后发生的事情有很好的直觉。

![](img/ebe398bb25bacc9df35d89337a0c9403_55.png)

现在呢，让我们用一些更真实的例子来尝试一下。

![](img/ebe398bb25bacc9df35d89337a0c9403_57.png)

我们这里有很长一段，我们可以看到，就在这里，我们有这个双新线符号。

![](img/ebe398bb25bacc9df35d89337a0c9403_59.png)

它是段落之间的典型分隔符，让我们看看这篇课文的长度。

![](img/ebe398bb25bacc9df35d89337a0c9403_61.png)

我们可以看到它大约是500，现在让我们定义两个文本拆分器，我们将像以前一样使用字符文本拆分器，以空间为分隔符，然后我们将初始化递归字符文本拆分器，在这里我们传递一个分隔符列表。



![](img/ebe398bb25bacc9df35d89337a0c9403_63.png)

这些是默认的分隔符，但我们只是把它们放在这个笔记本里，以便更好地显示发生了什么。

![](img/ebe398bb25bacc9df35d89337a0c9403_65.png)

所以我们可以看到我们有一个双新行的列表，单新线空间，然后什么都没有，一个空字符串，这些意味着当你拆分一段文本时，它将首先尝试用两条新线来分割它，然后如果它还需要更多地分割单个块，它将继续单行新线。

如果它还需要做更多，它继续到空间。

![](img/ebe398bb25bacc9df35d89337a0c9403_67.png)

最后它就会一个字符一个字符地，如果它真的需要这么做，看看它们在上面的文本中的表现。

![](img/ebe398bb25bacc9df35d89337a0c9403_69.png)

我们可以看到字符文本拆分器在空格上拆分。

![](img/ebe398bb25bacc9df35d89337a0c9403_71.png)

所以我们以句子中间奇怪的分离而告终。

![](img/ebe398bb25bacc9df35d89337a0c9403_73.png)

递归文本拆分器首先尝试在双新行上拆分，所以这里它把它分成两段，即使第一个比指定的450个字符短，这可能是一个更好的分裂，因为现在两个段落各自是自己的段落在块中，而不是在句子中间分开。

现在我们把它分成更小的块，只是为了更好地了解发生了什么，我们还将添加句点分隔符。

![](img/ebe398bb25bacc9df35d89337a0c9403_75.png)

这是为了在句子之间分开，如果我们运行这个文本拆分器，我们可以看到句子上的分裂，但经期实际上在错误的地方。



![](img/ebe398bb25bacc9df35d89337a0c9403_77.png)

这是因为场景下发生的Reg X，为了解决这个问题，我们实际上可以通过查看后面的内容来指定一个稍微复杂一点的reg x，现在如果我们运行这个，我们可以看到它被分成句子，它是正确地分裂的，句号在正确的地方。

现在让我们在一个更真实的例子上这样做。

![](img/ebe398bb25bacc9df35d89337a0c9403_79.png)

使用我们在第一个文档加载部分中使用的PDF文件之一，让我们把它装进去，然后让我们在这里定义我们的文本拆分器，我们在这里传递length函数，这是用孤，内置的蟒蛇，这是默认值。

但我们只是为了更清楚而具体说明。

![](img/ebe398bb25bacc9df35d89337a0c9403_81.png)

幕后发生了什么，这是计算字符的长度，因为我们现在想使用文档，我们使用拆分文档的方法，我们正在传递一份文件清单。



![](img/ebe398bb25bacc9df35d89337a0c9403_83.png)

如果我们将这些文件的长度与原始页面的长度进行比较。

![](img/ebe398bb25bacc9df35d89337a0c9403_85.png)

我们可以看到已经创建了更多的文档。

![](img/ebe398bb25bacc9df35d89337a0c9403_87.png)

因为这种分裂，我们也可以用我们在第一节课中使用的db概念来做类似的事情。

![](img/ebe398bb25bacc9df35d89337a0c9403_89.png)

并再次比较原始文档和新拆分文档的链接。

![](img/ebe398bb25bacc9df35d89337a0c9403_91.png)

我们可以看到我们有更多的文件，现在我们已经做了所有的分裂，这是一个很好的点暂停视频和尝试一些新的例子到目前为止。



![](img/ebe398bb25bacc9df35d89337a0c9403_93.png)

我们已经根据角色做了所有的拆分，但还有另一种方法，这是基于代币，为此，让我们导入令牌文本拆分器。

![](img/ebe398bb25bacc9df35d89337a0c9403_95.png)

这之所以有用，是因为lms通常有上下文窗口，由令牌计数指定的，因此，了解代币是什么以及它们出现在哪里是很重要的，然后我们可以在他们身上分头行动，对LLM如何看待他们有一个更有代表性的想法。

为了真正了解代币和字符之间的区别，让我们初始化令牌文本拆分器，块大小为1，块重叠为零，因此，这将把任何文本拆分为相关令牌的列表，让我们创建一个有趣的编造文本。



![](img/ebe398bb25bacc9df35d89337a0c9403_97.png)

当我们分开的时候，我们可以看到它分裂成一堆不同的代币，它们的长度都有点不同，其中的字符数，所以第一个就是foo，然后你有一个空间，然后是酒吧，然后你在B中有一个空格，然后是一个Z，然后是z。

然后是foo，这显示了在字符上拆分和在令牌上拆分之间的一点区别，让我们将此应用于上面加载的文档，以类似的方式，以类似的方式，我们可以调用页面上的拆分文档。



![](img/ebe398bb25bacc9df35d89337a0c9403_99.png)

如果我们看一下第一份文件，我们有了新的拆分文档，页面内容大致是标题，然后我们得到了源的元数据和它来自的页面，您可以在这里看到源的元数据，块中的页面与原始文档中的页面相同，所以如果我们看看。

只是为了确保第0页，元数据，我们可以看到它是一字排开的，这很好，它将元数据适当地传递到每个块，但也有一些情况，您实际上希望向块添加更多的元数据，当你把它们分开的时候，这可以包含文档中的位置等信息。

这一大块来自，它在哪里，相对于文档中的其他事物或概念，一般来说，这些信息可以在回答问题时使用，提供更多关于这个块到底要看什么的上下文，这方面的一个具体例子，让我们看看另一种类型的文本拆分器。

它实际上将信息添加到每个块的元数据中，您现在可以暂停并尝试您想出的几个示例。

![](img/ebe398bb25bacc9df35d89337a0c9403_101.png)

此文本拆分器是标记头文本拆分器，它会做的是，它将根据标头或任何子标头拆分标记文件，然后我将把这些标题作为内容添加到元数据字段中，这将被传递给任何源于这些分裂的块。



![](img/ebe398bb25bacc9df35d89337a0c9403_103.png)

让我们先做一个玩具示例，然后玩一下文档，我们有一个标题，然后是第一章的副标题，然后我们得到了一些句子，然后是一个更小的子标题的另一部分。



![](img/ebe398bb25bacc9df35d89337a0c9403_105.png)

然后我们跳回到第二章，在那里的一些句子中，让我们定义一个要拆分的标题列表，那些标题的名字，首先我们有一个标签我们称它为标题一，然后我们有两个标签标题二，三个标签标题三。



![](img/ebe398bb25bacc9df35d89337a0c9403_107.png)

然后，我们可以用这些标头初始化markdown标头文本拆分器，然后拆分我们上面的玩具示例，如果我们看几个例子，我们可以看到第一个有内容嗨，我是吉姆嗨，我是乔，现在在元数据中，我们有标题一。

然后我们把它作为标题和标题二作为第一章。

![](img/ebe398bb25bacc9df35d89337a0c9403_109.png)

这是从这里传来的。

![](img/ebe398bb25bacc9df35d89337a0c9403_111.png)

在上面的示例文档中，让我们来看看下一个，我们可以看到这里我们跳到了一个更小的部分，所以我们得到了嗨的内容，我是兰斯，现在我们不仅有头球，也是头球二，也是头球三，这又一次来自内容和名称。

在上面的降价文档中。

![](img/ebe398bb25bacc9df35d89337a0c9403_113.png)

让我们在一个现实世界的例子中尝试一下，在我们使用concept目录加载器加载concept目录之前，它加载了文件来标记。



![](img/ebe398bb25bacc9df35d89337a0c9403_115.png)

与标记标头拆分器相关，所以让我们加载这些文档，然后将标头为1的markdown拆分器定义为单个标签，标题二作为双重标签。



![](img/ebe398bb25bacc9df35d89337a0c9403_117.png)

我们对文本进行拆分，如果我们看一下它们，我们就会得到拆分。

![](img/ebe398bb25bacc9df35d89337a0c9403_119.png)

我们可以看到第一个有一些页面的内容，现在如果我们向下滚动到元数据，我们可以看到，我们已经加载了标题一作为blendel的员工手册，我们现在已经讨论了如何使用适当的元数据获得语义上相关的块。

下一步是将这些数据块移动到向量存储中。