# (超爽中英!) 2024公认最全的【吴恩达大模型LLM】系列教程！附代码_LangChain_微调ChatGPT提示词_RAG模型应用_agent_生成式AI - P35：3——文档分割 - 吴恩达大模型 - BV1gLeueWE5N

![](img/998abcc69f89944611c944f1c443e931_0.png)

我们刚刚讨论了如何将文档加载到标准格式中，现在，我们将讨论如何将它们分成较小的片段，这可能听起来非常容易，但是，这里有许多微妙之处，它们对后来的影响很大，让我们开始吧。

文档分割发生在您将数据加载到文档格式后，但在它进入向量存储之前，这可能看起来非常简单，您可以根据每个字符的长度或其他类似的方式分割片段。



![](img/998abcc69f89944611c944f1c443e931_2.png)

![](img/998abcc69f89944611c944f1c443e931_3.png)

但是，作为为什么这既更复杂又非常重要在下游的原因的示例，让我们看看这个例子在这里，我们中有一个关于丰田卡罗拉的句子和一些规格。



![](img/998abcc69f89944611c944f1c443e931_5.png)

如果我们进行简单的分割，我们可能会得到一个句子的一部分在一个片段中，句子的另一部分在另一个片段中，然后，当我们在下游尝试回答问题时。



![](img/998abcc69f89944611c944f1c443e931_7.png)

关于卡罗拉的规格是什么。

![](img/998abcc69f89944611c944f1c443e931_9.png)

我们实际上在任一个片段中都没有正确的信息，所以它被分割开来，因此，我们无法正确地回答这个问题，因此，如何在分割片段时如何处理有许多微妙和重要性，以便将语义相关的片段组合在一起。



![](img/998abcc69f89944611c944f1c443e931_11.png)

所有在lane chain中的文本分割器都基于分割片段，在某个片段大小和一些片段重叠下。

![](img/998abcc69f89944611c944f1c443e931_13.png)

所以我们这里有一个下面的图表来显示这看起来像什么，片段大小对应于片段的大小，片段的大小可以以几种不同的方式测量，我们在课程中会讨论一些，因此，我们允许传递一个长度函数来测量片段的大小。

这通常是字符或标记，片段重叠通常被保持为一些重叠在两个片段之间，就像我们在从一个到另一个移动时滑动的窗口，这允许同一部分上下文在片段的末尾，并在另一个片段的开始，并帮助创建一些一致性的概念。

文本分割器和lane chain都有创建文档和分割文档的方法，这涉及到相同的逻辑在内部，它只是暴露了一个稍微不同的用户界面。



![](img/998abcc69f89944611c944f1c443e931_15.png)

一个接受文本列表，另一个接受文档列表，lane chain中有许多不同类型的分割器，我们在这门课程中会覆盖一些，但我鼓励你在空闲时间检查其余的，这些文本分割器在许多维度上差异很大。

它们可以差异于如何分割片段，哪些字符进入那个，它们可以差异于，如何测量片段的长度，是按字符，是按标记，甚至有一些使用其他较小的模型来确定句子的结束可能何时，并且将其用作分块方式。



![](img/998abcc69f89944611c944f1c443e931_17.png)

分块成片段的另一个重要部分也是元数据。

![](img/998abcc69f89944611c944f1c443e931_19.png)

在所有片段中保持相同的元数据，但在相关时也添加新的元数据，因此，有些文本分割器真的很专注于这一点。

![](img/998abcc69f89944611c944f1c443e931_21.png)

片段的分割往往特定于，我们正在处理的文档类型。

![](img/998abcc69f89944611c944f1c443e931_23.png)

这在您在代码上分割时尤为明显，所以我们有一个语言文本分割器，有许多不同的分隔符。

![](img/998abcc69f89944611c944f1c443e931_25.png)

用于各种不同的语言。

![](img/998abcc69f89944611c944f1c443e931_27.png)

如Python，Ruby c，当分割这些文档时，它将考虑这些不同的语言和这些语言的相关分隔符。

![](img/998abcc69f89944611c944f1c443e931_29.png)

在执行分割时，我们将首先按照之前设置环境，加载Open AI API密钥。

![](img/998abcc69f89944611c944f1c443e931_31.png)

接下来，我们将导入两种最常见的文本分割器和长链。

![](img/998abcc69f89944611c944f1c443e931_33.png)

递归字符文本分割器和字符文本分割器，我们将首先尝试一些玩具用例，只是为了了解这些做什么，因此，我们将设置一个相对较小的片段大小为二十六。



![](img/998abcc69f89944611c944f1c443e931_35.png)

和一个甚至更小的片段重叠为四，只是为了看到它们可以做什么。

![](img/998abcc69f89944611c944f1c443e931_37.png)

让我们初始化这两个不同的文本分割器为r_splitter和c_splitter，然后，让我们看一些不同的使用案例。



![](img/998abcc69f89944611c944f1c443e931_39.png)

让我们加载第一个术语，从a到z的所有字母，让我们看看当我们使用各种分割器时发生了什么。

![](img/998abcc69f89944611c944f1c443e931_41.png)

当我们使用递归字符文本分割器时。

![](img/998abcc69f89944611c944f1c443e931_43.png)

它仍然只是一个字符串，这是因为这有二十六个字符长，我们已指定片段大小为二十六，因此，实际上在这里甚至不需要进行任何分割，让我们在稍长的字符串上进行分割，它比我们指定的二十六个字符的片段大小更长，在这里。

我们可以看到创建了两个不同的片段，第一个片段以z结束，所以这是二六字符，我们可以看到下一个片段从w开始，X，Y，Z，这些是四个片段重叠，然后，它继续与字符串的其余部分，让我们看一个稍微更复杂的字符串。



![](img/998abcc69f89944611c944f1c443e931_45.png)

其中字符之间有许多空格，我们现在可以看到它被分割成三个片段，因为有空格，所以它占用更多的空间，因此，如果我们看重叠，我们可以看到在第一个中，有llm，然后在第二个中也有l和m，这似乎只有两个字符。

但是因为在l和n之间有空格，然后在l前面和m后面，实际上这相当于构成块重叠的四个字符，让我们现在尝试使用字符文本分割器。



![](img/998abcc69f89944611c944f1c443e931_47.png)

我们可以看到当我们运行它时，它实际上并没有尝试在任何地方分割它，所以这里发生了什么，问题在于字符文本在一个字符上分裂。



![](img/998abcc69f89944611c944f1c443e931_49.png)

并且默认那个字符是新行字符，但在这里没有新的，如果我们将分隔符设置为空白。

![](img/998abcc69f89944611c944f1c443e931_51.png)

我们可以看到会发生什么，然后。

![](img/998abcc69f89944611c944f1c443e931_53.png)

在这里它与以前相同分裂，这是一个暂停视频并尝试一些新例子的好时机，无论是用你创造的不同字符串，还是交换分隔符并看会发生什么，此外，尝试不同的块大小和块重叠也很有趣，所以，通过几个玩具示例。

你可以大致了解正在发生的事情，这样，当我们转向更真实的世界示例时，你对场景下发生的事情会有良好的直觉。



![](img/998abcc69f89944611c944f1c443e931_55.png)

现在，让我们在更多的真实世界示例上尝试一下。

![](img/998abcc69f89944611c944f1c443e931_57.png)

这里有一段很长的段落，我们可以看到，大约在这里我们有一个双行新符号。

![](img/998abcc69f89944611c944f1c443e931_59.png)

这是段落之间的典型分隔符，让我们检查这段文本的长度。

![](img/998abcc69f89944611c944f1c443e931_61.png)

"我们可以看到，它就大约是五百"，"现在让我们定义我们的两个文本分割器"，"我们将像以前那样与字符文本分割器合作"，"以空间作为分隔符"，"然后，我们将初始化递归字符文本分割器"，"并且。

这里是一个分隔符列表"。

![](img/998abcc69f89944611c944f1c443e931_63.png)

"这些是默认的分隔符"，"但我们只是把它们放在这个笔记本里，以更好地展示正在发生的事情"。

![](img/998abcc69f89944611c944f1c443e931_65.png)

因此，我们可以看到，我们拥有一份包含双行空格的列表。"单行空格"，然后什么，一个空的字符串，这些意味着当你在分割一段文本时，它会首先尝试按双行新符分割它，然后，如果它还需要进一步分割单个块。

它会继续按单行新符分割，然后，如果它还需要更多，它会继续到空格。

![](img/998abcc69f89944611c944f1c443e931_67.png)

最后，它会只是按字符分割，如果它真的需要这样做，看这些在上述文本中的表现。

![](img/998abcc69f89944611c944f1c443e931_69.png)

我们可以看到，字符文本分割器在空格上分裂。

![](img/998abcc69f89944611c944f1c443e931_71.png)

因此，我们最终得到了句子中间奇怪的分隔。

![](img/998abcc69f89944611c944f1c443e931_73.png)

递归文本分割器首先尝试在双行新线上分裂，因此，它将其分割成两个段落，尽管第一个段落比指定的四百五十个字符要短，这可能是一个更好的分割，因为现在，每个自己的段落都在块中，与在中间分割句子不同。

让我们现在将其分割成更小的块，只是为了更好地理解正在发生的事情，我们还将添加句号分隔符。

![](img/998abcc69f89944611c944f1c443e931_75.png)

这是为了在句子之间分割，如果我们运行此文本分割器，我们可以看到按句子分割，但句号实际上在错误的位置，这是因为下面的正则表达式x在起作用，为了修复这个问题，我们可以实际上指定一个稍微更复杂的正则表达式x。

带有一个后视镜，现在如果我们运行这个，我们可以看到它被分割成句子，并且它以正确的方式分割，句号在正确的位置，让我们现在将这个应用到一个更真实的世界例子中。



![](img/998abcc69f89944611c944f1c443e931_77.png)

与在第一个文档加载部分我们工作的一个pdf中，让我们加载它，然后让我们在这里定义我们的文本分割器这里我们传递长度函数，这是用lone的，Python内置的，这是默认的，但我们只是明确指定它以增加清晰度。



![](img/998abcc69f89944611c944f1c443e931_79.png)

在幕后发生了什么，并且这正在计算字符的长度，因为我们现在要使用文档，我们使用split documents方法，并传递一个文档列表。



![](img/998abcc69f89944611c944f1c443e931_81.png)

如果我们比较那些文档的长度与原始页面的长度。

![](img/998abcc69f89944611c944f1c443e931_83.png)

我们可以看到创建了许多更多的文档。

![](img/998abcc69f89944611c944f1c443e931_85.png)

作为这个分割的结果，我们可以对在第一次讲座中使用的概念db做类似的事情。

![](img/998abcc69f89944611c944f1c443e931_87.png)

再次比较原始文档的链接与新的拆分文档。

![](img/998abcc69f89944611c944f1c443e931_89.png)

我们可以看到有许多文档，现在，我们完成了所有分割，这是一个好暂停视频的点，尝试一些新的示例。

![](img/998abcc69f89944611c944f1c443e931_91.png)

我们已经基于字符进行了所有分割，但还有其他一种分割方式，这是基于标记的，为了此，我们将导入标记文本分割器，这是因为经常LMS有上下文窗口，由标记数指定，因此，了解标记是什么以及它们出现在哪里很重要。



![](img/998abcc69f89944611c944f1c443e931_93.png)

然后，我们可以基于它们进行分割，为了获得一个稍微更代表性的想法，看看llm如何看待他们，真正理解标记和字符之间的差异，让我们初始化标记文本分割器，以块大小为一，块重叠为零。

所以这将将任何文本分割为一个标记列表，让我们创建一个有趣的虚构文本。

![](img/998abcc69f89944611c944f1c443e931_95.png)

当我们分割它，我们可以看到它被分割成一堆不同的马克标记，并且它们在长度上都有所不同，以及它们内部的字符数量，所以第一个就是foo，然后你有一个空格然后bar，然后只有b有一个空格，然后一个z。

然后z然后foo又出现了，这显示了一下在字符分裂与标记分裂之间的一些差异，让我们将这个应用到我们上面加载的文档中，以类似的方式，以类似的方式，我们可以在页面上调用分割的文档。



![](img/998abcc69f89944611c944f1c443e931_97.png)

如果我们看一下第一个文档，我们有我们的新分割文档，页面内容大致是标题，然后，我们有源文档和它来自的页面的元数据，在这里，你可以看到源文档的元数据，以及页面在块中与原始文档相同，因此，如果我们看那个。

只是为了确保页面零，元数据，我们可以看到它对齐，这很好，它将元数据适当地传递到每个块中，但也可能存在您实际上想要向块添加更多元数据的情况，在你分割它们时，这可以包含文档中的位置信息，块来自哪里。

它位于何处，相对于文档中的其他事物或概念，一般来说，这种信息可以在回答问题时使用，以提供关于这个块确切内容的更多上下文，以便看到，一个具体的例子，我们来看看另一种文本分割器，实际上。

它将信息添加到每个片段的元数据中，你现在可以暂停并尝试一些你自己想出来的例子。

![](img/998abcc69f89944611c944f1c443e931_99.png)

这个文本分割器是Markdown标题文本分割器，它会做什么，它将根据标题或任何子标题分割Markdown文件，然后，我将将这些标题作为内容添加到元数据字段中。

这将被传递给来自那些分割的片段的任何其他片段。

![](img/998abcc69f89944611c944f1c443e931_101.png)

让我们先做一个玩具示例，玩一玩文档，我们有一个标题，然后，第一章的子标题，然后我们在那里有一些句子，然后，另一个甚至更小的子标题的部分。



![](img/998abcc69f89944611c944f1c443e931_103.png)

然后，我们跳回到第二章，在一些句子中，让我们定义一个我们要在文本上分割的标题列表，以及那些标题的名称，所以首先我们有一个单独的哈希标签，我们将其称为标题一，然后我们有两个哈希标签标题二。

三个哈希标签标题三。

![](img/998abcc69f89944611c944f1c443e931_105.png)

我们可以然后使用这些标题初始化Markdown标题文本分割器，然后分割我们上面的玩具示例，如果我们看一些这些例子，我们可以看到第一个有一个内容hi，这是吉姆hi，这是乔，现在，在元数据中我们有标题一。

然后，我们将其作为标题，标题二作为第一章。

![](img/998abcc69f89944611c944f1c443e931_107.png)

这是从这里来的。

![](img/998abcc69f89944611c944f1c443e931_109.png)

在上述示例文档中，让我们看看下一个，在这里，我们可以看到我们已经跳入了一个甚至更小的子部分，所以我们有内容的hi，这是兰斯，现在我们不仅有标题一，还有标题二和标题三，这又从内容和名称中来。

在上述Markdown文档中。

![](img/998abcc69f89944611c944f1c443e931_111.png)

让我们试试在真实世界的例子中，在加载Notion目录使用Notion目录加载器之前，并加载了Markdown文件。



![](img/998abcc69f89944611c944f1c443e931_113.png)

这对于Markdown标题分割器是有关的，所以让我们加载那些文档，然后定义Markdown分割器，标题一为一个单独的哈希标签，标题二为两个哈希标签。



![](img/998abcc69f89944611c944f1c443e931_115.png)

我们分割文本，得到我们的分割，如果看它们。

![](img/998abcc69f89944611c944f1c443e931_117.png)

我们可以看到第一个有内容的一些页面，如果向下滚动到元数据，我们可以看到我们已经加载标题一作为Blendel的员工手册，我们已经覆盖了如何以适当的元数据获取语义相关的片段。

下一步是将这些数据片段移动到一个向量存储中。