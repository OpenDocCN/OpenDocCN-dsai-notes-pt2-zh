# P29：【斯坦福大学】博弈论（28）逆向归纳法 - 自洽音梦 - BV1644y1D7dD

现在让我们来谈谈逆向归纳法，向后归纳法可以看作是计算子博弈的一种方法，博弈的完全均衡，这是一个使用，呃，广泛地，或它的变体在游戏程序中被广泛使用，就这样吧，呃，国际象棋或其他的，这是如何工作的。



![](img/b054fd0449a440180067441fadbf3c7a_1.png)

所以这是一个忙，忙滑梯，呃，不要气馁。

![](img/b054fd0449a440180067441fadbf3c7a_3.png)

我们会慢慢解释的，你们中的一些人可能以前没有见过算法，但在此之前，我们将用非常简单的术语解释算法，让我们先给出直觉，直觉很直截了当，我们要做的是把游戏的价值，不仅用叶节点，带叶节点，我们知道价值是多少。

它只是由回报向量定义的，与叶子节点相关联是游戏定义的一部分，但是假设我们要去节点的根，或任何其他内部节点，这么说，这里相关的收益到底是什么，假设代理人会玩一个子博弈完美均衡。

这就是这个叫做逆向归纳法的过程的目标，直觉很直截了当。

![](img/b054fd0449a440180067441fadbf3c7a_5.png)

我们会去树叶，慢慢后退，如果在路上的每一步。

![](img/b054fd0449a440180067441fadbf3c7a_7.png)

假设代理将最大化，在该节点采取最大化回报的行动，这就是现在的直觉。

![](img/b054fd0449a440180067441fadbf3c7a_9.png)

让我们看看是怎么做的，呃，正式，这个过程被称为逆向归纳法。

![](img/b054fd0449a440180067441fadbf3c7a_11.png)

它需要一个论点，节点，树中的节点，任何节点都可以是根，可能是一片叶子或介于两者之间的任何东西，当然，每个节点都有一些参与者。



![](img/b054fd0449a440180067441fadbf3c7a_13.png)

预测我们很快会遇到什么。

![](img/b054fd0449a440180067441fadbf3c7a_15.png)

h行将是与该节点关联的播放器，h，当程序返回时，会给我们这些收益。

![](img/b054fd0449a440180067441fadbf3c7a_17.png)

我们向与该节点相关的所有代理支付的款项。

![](img/b054fd0449a440180067441fadbf3c7a_19.png)

那么这是怎么工作的呢，再一次记住我们的直觉。

![](img/b054fd0449a440180067441fadbf3c7a_21.png)

我们说下面，如果h是叶节点，Z是一组叶节点。

![](img/b054fd0449a440180067441fadbf3c7a_23.png)

如果h是叶节点，然后我们简单地返回由博弈定义的回报向量。

![](img/b054fd0449a440180067441fadbf3c7a_25.png)

这就是递归的底部，大部分的工作，当然啦，发生在递归步骤中，当我们不在叶节点的时候，为此，我们执行以下操作，我们会保留一个。



![](img/b054fd0449a440180067441fadbf3c7a_27.png)

最佳UTIL将是一个向量。

![](img/b054fd0449a440180067441fadbf3c7a_29.png)

与代理相关联的收益向量。

![](img/b054fd0449a440180067441fadbf3c7a_31.png)

每一个，每一个，每一个探员，我们会更新的，呃，那个矢量，当我们，呃。

![](img/b054fd0449a440180067441fadbf3c7a_33.png)

当我们前进的时候，所以首先，我们会假设收益都很糟糕，我们把它叫做负无穷大，回报，小于游戏中所有可能的收益，然后我们执行以下操作，我们会看看所有的。



![](img/b054fd0449a440180067441fadbf3c7a_35.png)

可在该说明查阅。

![](img/b054fd0449a440180067441fadbf3c7a_37.png)

所以h的chi是所有动作的集合，A将是这种行动的一个例子。

![](img/b054fd0449a440180067441fadbf3c7a_39.png)

因此，我们将轮流进行每个动作，一次一个，并执行以下操作。

![](img/b054fd0449a440180067441fadbf3c7a_41.png)

我们将通过在该节点h采取行动来查看您到达的孩子。

![](img/b054fd0449a440180067441fadbf3c7a_43.png)

这叫做A的西格玛H，所以sigma a只是另一个节点，通过采取特定操作到达的节点h的子节点之一。

![](img/b054fd0449a440180067441fadbf3c7a_45.png)

我们将递归地查看与该子向量相关联的向量，我们会把它保持在这个叫做Utia子的变量。

![](img/b054fd0449a440180067441fadbf3c7a_47.png)

![](img/b054fd0449a440180067441fadbf3c7a_48.png)

所以我们有两个两个向量，最好注意Util。

![](img/b054fd0449a440180067441fadbf3c7a_50.png)

你告诉一个孩子最好的效用是我们迄今为止发现的最好的，最适合特定的代理。

![](img/b054fd0449a440180067441fadbf3c7a_52.png)

效用子是我们在一个特定的孩子身上发现的。

![](img/b054fd0449a440180067441fadbf3c7a_54.png)

我们会一次一个地检查所有的孩子吗，Utia子级对代理更好，那么到目前为止最好的你会更新。

![](img/b054fd0449a440180067441fadbf3c7a_56.png)

你说得最清楚的就是这里发生的事情，所以这就是上面写的，上面写着，效用试验是一个向量，所以看看与代理相对应的向量的元素。



![](img/b054fd0449a440180067441fadbf3c7a_58.png)

我们关心代理和节点h。

![](img/b054fd0449a440180067441fadbf3c7a_60.png)

如果实用子代更适合该代理。

![](img/b054fd0449a440180067441fadbf3c7a_62.png)

给最好的Util，我们到目前为止发现的，然后简单的更新一下，将best util更新为此实用程序子程序。



![](img/b054fd0449a440180067441fadbf3c7a_64.png)

否则保持不变，所以用这种方式，我们骑车穿过所有的孩子，并从该代理那里发现，从他的观点来看，节点属于谁。



![](img/b054fd0449a440180067441fadbf3c7a_66.png)

所有向量中哪一个最好，直觉是他会采取导致那个孩子的行动，并更新该工作。

![](img/b054fd0449a440180067441fadbf3c7a_68.png)

这个矢量相应地，这就是为什么当我们做完，我们正在归还我们迄今为止发现的最好的UTI。

![](img/b054fd0449a440180067441fadbf3c7a_70.png)

这就是逆向归纳法。

![](img/b054fd0449a440180067441fadbf3c7a_72.png)

注意到我们不返回策略，只需返回收益列表，从某种意义上说，呃，你可以把它看作是简单地扩大回报。

![](img/b054fd0449a440180067441fadbf3c7a_74.png)

从节点到所有内部节点，但即使我们没有明确地返回均衡策略，一个会是子游戏完美的，从这些数字中读出来很容易，因为在每个节点上，代理将采取将其引导到节点的操作，从他的角度来看效用最好的子节点。

所以这就是子游戏完美，呃，这是计算子博弈的过程，完美均衡，反向归纳法。

![](img/b054fd0449a440180067441fadbf3c7a_76.png)

如果我们看看零和博弈的特例。

![](img/b054fd0449a440180067441fadbf3c7a_78.png)

它简化了一点，因为只有两个球员，1的对减去2的对减去另一个，所以我们只需要跟踪与每个节点相关的一个数字，所以要做的簿记就少了，并进一步，嗯，在这种零和游戏中，所有赢输的游戏都是零和游戏。



![](img/b054fd0449a440180067441fadbf3c7a_80.png)

比如说，国际象棋有一种方法可以加快逆向归纳程序，顺便说一句，在零和K中，我们简单地称之为极大极小过程，因为我们在最小化和最大化值之间交替，一个玩家想把它最小化，另一个最大化，事实上。

有一种方法可以加快程序，我们不会在这里讨论，但直觉是，当您访问给定节点的某个子节点时，你可能会发现在这一点上没有，不需要探索该节点的剩余子节点，就像我们在逆向归纳过程中所做的那样，因为这无关紧要。

您已经找到了一个值，该值意味着此节点，你正在检查的，永远不会访问父节点，它被称为字母表阿尔法，贝塔修剪程序及逆向诱导的优化，或者零和游戏的迷你Mac程序，你被邀请去其他地方探索它。



![](img/b054fd0449a440180067441fadbf3c7a_82.png)

关于逆向归纳法，我还想说一件事，呃，事实上，与子游戏完美，这里有两种不同的东西，它们都被关闭了，同样的例子，蜈蚣游戏的著名例子，所以这个众所周知的例子，你有两个球员，他们交替转弯，一号玩家移动。

二号玩家移动，然后再玩一个，挑两个，以此类推，以此类推，但收益是以人为的方式构建的，这样它们就逐渐增加了，你可以想象它叫蜈蚣，因为你可以想象这里不是只有五条腿，你会有一百个，他们卖你的钱。

所以这里的收益比这里的收益要小得多，如果你继续前进，确实如此，但即使他们上升，它们是以一种只导致一个子游戏的方式设计的，完美的平衡板将在每一个地方缺陷，纸张的周期会在这里的每个地方下降，所以唯一的结果。

子游戏的完美结局是第一个玩家的缺陷立即下降，这当然类似于囚徒困境，有点违背直觉，因为如果他们有理智继续前进，他们会在这个或这个的范围内得到一些东西，两者都比这里好得多，但尽管如此，当你检查。

你看只有一个，呃，呃，一次一次子游戏，这里的完美平衡，事实上只有一个均衡结果，就是这个，你可以通过再做一次来看到它，逆向归纳法，进展并实际上到达了这个节点，一号玩家会做得很好，他们会得到四分而不是三分。

但二号玩家知道这一点，所以知道一号玩家会倒下，他宁愿下去，因为他会得到四分而不是三分，这里也一样，一号玩家知道二号玩家会倒下，选择来到这里因为他们会得到三个而不是两个等等，这实际上是逆向归纳法的论点。

所以说，一方面，嗯，清楚地说明了这场比赛会发生什么，但是有两个问题，其中一个是简单的实验和常识，另一个是更理论化的，在务实层面，常识只是告诉你这不是会发生的事情，玩家会合作一段时间，直到某个时候。

事实上，有人会下去结束比赛，他们知道前进会有很多收获，他们会，如果你愿意，就抓住机会，这一直觉在实验中得到了反复的证实，人们确实合作了一段时间，直到，事实上，他们最终叛逃了，所以这是理论上的问题。

但还有一个理论上的问题，所以我们知道唯一的子博弈完美均衡是代理人叛逃，现在随时下去，想象一下游戏开始了，一号玩家穿过，不下去，2号玩家擅长什么？一方面，你可以说好，唯一的子博弈完美均衡，他们应该下去。

因为他们会经历背景演绎的争论，它会告诉他们对他们来说最好的事情是下去，但同样的论点告诉他们二号玩家，一号球员会立刻倒下，但他们没有，所以也许他们不会再下去了，但他们会怎么做呢。

基本上这里发生的事情是你有一个穿过它的事件，标准理论告诉你会以零概率发生，你如何对一个先前概率为零的事件进行条件，有一个，有，有大量关于这方面的文献，这是一个非常有趣的深层问题博弈论，我们不会再深究了。

