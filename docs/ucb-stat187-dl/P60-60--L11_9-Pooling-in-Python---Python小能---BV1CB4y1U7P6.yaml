- en: P60：60. L11_9 Pooling in Python - Python小能 - BV1CB4y1U7P6
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's have a look at how pooling works in practice。 So the first thing we need
    to do is we need to actually define our pooling function。 It's very easy。 Okay，
    we need to import MXNet。 The next thing is we define our pooling function。 The
    important argument is the pool size， so I'm going to get the height and the width。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: by querying the pool size。 And I'm going to distinguish between maximum and
    average pooling。 Default is a max pooling。 First thing I need to do is I need
    to allocate some memory。 That is of the size that I'm going to get by performing
    pooling over the input X。 So I need X shape minus pooling height plus one， the
    same thing for the width。
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: So it's exactly the same semantics as what we have for convolutions。 just that
    we don't have any parameters。 And then I just iterate over all the pixels in the
    output。 So for iron j in the range of Y， I now perform the following operation。
    Yij is the maximum over this patch here。 This patch goes from i to i plus 8 pH
    and from j to j plus pw。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: And if I were to use mean pooling， well， I'd do this。 Now this is a very poor
    implementation of pooling because it completely ignores channels。 And it also
    ignores padding and strides。 But since this is just for illustrative purposes。
    I'm going to skip this here。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/de1b1c1dba5f0fc2e23deaef9abaea88_1.png)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
- en: '![](img/de1b1c1dba5f0fc2e23deaef9abaea88_2.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
- en: So let's have a look at what happens。 So we're going to apply 2x2 max pooling
    to this matrix which has entry 0 to 8。 And of course， if I have the first 2x2
    block， then well， that's exactly the maximum is 4。 because it has entry 0， 1，
    3 and 4， and so on。 Now if I were to perform average pooling， well。 let's get
    something very similar。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/de1b1c1dba5f0fc2e23deaef9abaea88_4.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
- en: So for this first block here 0， 1， 3 and 4， the sum overall the entry is 8。
    8 divided by 4 is 2。 If I were to take those entries 1， 2， 4 and 5， the sum of
    those entries is 12， and so I get 3。 and so on。 So that's good。 Let's have a look
    at how things progress if we do something a little bit more fancy。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/de1b1c1dba5f0fc2e23deaef9abaea88_6.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
- en: The next thing is we might want to look at padding and stride。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/de1b1c1dba5f0fc2e23deaef9abaea88_8.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
- en: So I'm going to create a matrix that's 4x4 with entries ranging from 0 to 15。
    Now。 if I perform max pooling and I use the built-in functioning glue-on。 then
    by default if I have a 3x3 pooling， then the stride is also 3。 so therefore if
    I apply this 4x4 matrix， there's really only that first 3x3 block that I can grab。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: So the output is going to be 1x1。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/de1b1c1dba5f0fc2e23deaef9abaea88_10.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
- en: And behold， that's exactly what happens。 Mind you， the entry is 10， because
    well。 the largest entry in that first 3x3 block is 10。 Okay。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/de1b1c1dba5f0fc2e23deaef9abaea88_12.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
- en: Now， let's say I want to actually change this。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/de1b1c1dba5f0fc2e23deaef9abaea88_14.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
- en: Well， I could for instance have padding of 1 and stride of 2， in which case。
    well because I have 3x3 applied to a 4x4， so that's actually a 6x6。 But then with
    a stride of 2。 that gives me a 2x2 matrix as a result。 I could have arbitrary
    windows with different widths and different heights and different padding and
    different strides。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我可以比如说使用填充为1，步幅为2，在这种情况下，因为我把3x3应用到4x4的矩阵上，实际上得到了一个6x6的矩阵。但接着使用步幅为2，这样我就会得到一个2x2的矩阵作为结果。我可以使用任意大小的窗口，宽度和高度不同，填充和步幅也可以不同。
- en: '![](img/de1b1c1dba5f0fc2e23deaef9abaea88_16.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/de1b1c1dba5f0fc2e23deaef9abaea88_16.png)'
- en: And I'll leave that to anybody to verify in their own piece and quiet that the
    result would actually be a 3x2 matrix。 So 3 rows， 2 columns。 And yeah， so I can
    do that and therefore reshape the result in arbitrary ways。 Mind you， the number
    of input and output channels remains unchanged。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我会把这个留给每个人自己去验证，在他们自己的安静环境中，结果实际上会是一个3x2的矩阵。所以3行，2列。是的，我可以这么做，因此可以以任意方式重塑结果。请注意，输入和输出通道的数量保持不变。
- en: '![](img/de1b1c1dba5f0fc2e23deaef9abaea88_18.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/de1b1c1dba5f0fc2e23deaef9abaea88_18.png)'
- en: So let's do that。 So I'm going to create a matrix that has， well， 3， well， it
    has 2 channels。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们来做这个吧。我要创建一个矩阵，它有，嗯，3，实际上它有2个通道。
- en: '![](img/de1b1c1dba5f0fc2e23deaef9abaea88_20.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/de1b1c1dba5f0fc2e23deaef9abaea88_20.png)'
- en: Right， so that's basically my 4x4 matrix just that in one case I have the entries
    going from 0 to 15。 the next case from 1 to 16。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对，所以基本上这是我的4x4矩阵，只不过在一种情况下，我的条目是从0到15，另一种情况下是从1到16。
- en: '![](img/de1b1c1dba5f0fc2e23deaef9abaea88_22.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/de1b1c1dba5f0fc2e23deaef9abaea88_22.png)'
- en: Okay， so now if I were to apply pulling again， so padding of 1 strides of 2，
    3x3 pulling。 I still get to output channels。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在如果我再次应用池化操作，使用填充为1，步幅为2，3x3的池化，我仍然得到2个输出通道。
- en: '![](img/de1b1c1dba5f0fc2e23deaef9abaea88_24.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/de1b1c1dba5f0fc2e23deaef9abaea88_24.png)'
- en: And since the second channel has all the entries 1 large as in the first one，
    well， I get exactly 5。 7， 13 and 15， and then for the next 1， 6， 8， 14 and 16。
    That's exactly what's to be expected。 So as you can see， pulling is a very easy
    operation。 It's straightforward to apply。 And it can be used to manipulate the
    dimensionality of the images in order to reduce their size as needed。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 由于第二个通道的所有条目都像第一个通道一样都为1，因此，我得到了精确的5，7，13和15，然后对于下一个1，6，8，14和16。这正是预期的结果。所以正如你所看到的，池化是一个非常简单的操作。它易于应用，且可以用来操控图像的维度，以根据需要减小它们的大小。
- en: This concludes our conversation about convolutional layers。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们关于卷积层的讨论。
- en: '![](img/de1b1c1dba5f0fc2e23deaef9abaea88_26.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/de1b1c1dba5f0fc2e23deaef9abaea88_26.png)'
