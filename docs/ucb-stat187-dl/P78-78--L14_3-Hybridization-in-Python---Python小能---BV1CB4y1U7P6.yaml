- en: P78：78. L14_3 Hybridization in Python - Python小能 - BV1CB4y1U7P6
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So let's start with， let me do， to min a little bit。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51e689b9fd720f52d52ecec55198d75e_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: So let's start with how to define imperative programming in Python。 So here
    we define function called add， given a and a b， we just return a plus b。 And some
    fancy function that given a， a， b， c， d inputs， and just to do three ads and return
    g。 If it causes function given data， one， two， three， four， we're going to get
    the results。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: That's as normal as what we have before。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51e689b9fd720f52d52ecec55198d75e_3.png)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
- en: You may be don't know that in Python you can actually use in symbolic programming。
    That is。 we first define function， it do add， but doesn't actually compute that。
    There returns a stream function which is doing the thing， which is going to do
    the work for you。 Similar thing， for the fancy function we just return a string
    of the function which you do the workload。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: The program here is that we get add definition， get the fancy function definition。
    and then we print the evaluation here。 So far， until this moment we didn't get
    anything wrong。 we just defined function。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51e689b9fd720f52d52ecec55198d75e_5.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
- en: So we know that if we print this one we cannot get a bunch of definition here。
    Then we compile this function， this string function， to get as good for y。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51e689b9fd720f52d52ecec55198d75e_7.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
- en: And this is， this Python's， uh， as good to run the function。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51e689b9fd720f52d52ecec55198d75e_9.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
- en: And then finally we cannot get the final result， let me do it。 You find out
    we get the results 10 here。 Okay， so this is symbolic programming in Python。 You
    may be never used that before， it's so hard to use。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51e689b9fd720f52d52ecec55198d75e_11.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
- en: Okay， so then， in M's net， let's show example how to use a hybrid sequential。
    Let's import library and the only difference here is to， from。 undors sequential
    to undors hybrid sequential。 That's the only difference we have。 The following
    string lines we just add three dense layers， it's as same as before。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: And then we initialize the network， return the network。 Next we create a random
    variable x and get the network and feed x into net， work， get the results。 That
    is what we had before。 Okay， so this one， it's， uh， executed in the imperative
    model。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51e689b9fd720f52d52ecec55198d75e_13.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
- en: Now we can call net for hybridize。 We have， for the back end。 we're going to
    switch to this symbolic execution。 Um， so， but nothing have changed on the front。
    You feed the same x， we get the same results。 Like， as here， the results should
    be similar to here。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51e689b9fd720f52d52ecec55198d75e_15.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
- en: Nothing have been changed in terms of the results。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51e689b9fd720f52d52ecec55198d75e_17.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
- en: Okay， so that's using net or hybridize， we can switch to the hybridize model。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51e689b9fd720f52d52ecec55198d75e_19.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
- en: We can benchmark the performance here。 So we define benchmark function。 which
    can run the forward pass by 1000 times。 And then wait。 we're going to show why
    we have a wait all here， but wait all the。 competition have been finished and
    the printed time。 First。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这里基准测试性能。所以我们定义了基准函数，能够运行1000次前向传播。然后等待。我们将展示为什么在这里我们使用了`wait all`，但所有竞争任务已经完成，并打印了时间。首先。
- en: we create a network and a right benchmark it without hybridizing。 Then we call
    hybridize a benchmark again。 You can see that， like without hybridizing， take
    about 0。2 seconds。 With hybridizing， it can be a two-time speed up here。 Okay。
    the reason is because we explained before， after hybridizing。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个网络并进行了基准测试，但没有进行混合化。然后我们再次调用混合化进行基准测试。你可以看到，没有混合化时大约需要0.2秒。进行了混合化后，速度提高了两倍。好的。原因如我们之前所解释，混合化后。
- en: we just compiled code one and run for the back end。 So we can get rid of the
    Python overhead here。 And because the network itself is pretty simple and we run
    thousands of， network and in 0。1 seconds。 which means the network workload is
    pretty small， the Python overhead is a relative large component to the workload。
    In this case， you can think about like at least 0。1， 3 seconds is due to the Python
    overhead。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是编译了代码并在后端运行。所以我们可以消除Python的开销。因为网络本身非常简单，我们在0.1秒内运行了成千上万次网络，这意味着网络工作负载非常小，Python的开销是工作负载中的相对大部分。在这种情况下，你可以认为至少0.1到0.3秒是由于Python的开销。
- en: Question。 >> So in this example before hybridizing， when you call net， events。
    are you seeing like in the forward function， it has to step through each line。
    >> So yes。 we can uncover that in detail in a little bit later。 >> Yeah。 >> Can
    I cover how it works？
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 问题。>> 那么在这个例子中，在混合化之前，当你调用net，事件时，你看到在前向函数中，它必须逐行执行吗？ >> 是的。我们稍后会详细展开讲解。 >>
    是的。 >> 我可以介绍它是如何工作的？
- en: '>> And when you hybridize it， what do you compile it to like C， C++ or something？
    >> Yes。 we''re going to do。 Yeah。 Another question？ >> What are the 30 cases in
    which a line that does hybridize。 takes a very long time？ >> You mean the cases
    after hybridizing take a long time？ >> Yeah。 >> The operation of hybridizing the
    network leaves a lot。'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '>> 当你混合化时，你是将其编译成C、C++还是其他什么？ >> 是的，我们会这么做。好的。还有其他问题吗？ >> 有哪些情况是混合化处理的时间特别长？
    >> 你是指混合化后花很长时间的情况吗？ >> 是的。 >> 混合化网络操作会消耗很多时间。'
- en: '>> Usually hybridizing is always faster than the imperative model。 >> And then
    what happens in hybridize？ Just taking the network in hybridize。 So the line that
    does hybridize about time and a long time。 >> Well。 we probably will not dive
    into so much deep how hybridize works。'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '>> 通常来说，混合化总是比命令式模型更快。 >> 那么在混合化中发生了什么？仅仅是将网络进行混合化。那么混合化处理需要很长时间的情况呢？ >> 嗯，我们可能不会深入探讨混合化如何工作。'
- en: but usually you don't need differences like hybridizing。 Maybe you don't give
    too much benefit。 but usually at most you， don't worth your computation。 That's
    all。 But the compiler itself is pretty fast。 It's like you can ignore that。 Okay。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 但通常你不需要像混合化那样的差异化。也许它不会带来太大的好处。但通常最多你，不值得为了计算而做混合化。就这些。不过编译器本身相当快，可以忽略不计。好的。
- en: '![](img/51e689b9fd720f52d52ecec55198d75e_21.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/51e689b9fd720f52d52ecec55198d75e_21.png)'
- en: So then once you hybridize that， you can export this one， the。 network definition
    into intermediate representation。 When you do that。 it is going to save into the
    name of your workload。 and dash symbol with a symbolic representation and a JSON
    fire。 We print the first 20 lines for the code。 You can see that this is a bunch
    of nodes。 This is a computation graph actually。 Define the network。 So this fire，
    let's own， is a JSON fire。 It's independent of Python。 Let's load back into C++
    or Java back end or you can load back into。 Python as well。 Which means it's portable。
    You can get this JSON fire and deploy into mobile phone。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成混合化，你可以将网络定义导出为中间表示。当你这样做时，它会保存为你的工作负载名称，后面加上符号表示和一个JSON文件。我们打印了代码的前20行。你可以看到这是一堆节点。这实际上是一个计算图。定义了网络。所以这个文件，实际上是一个JSON文件。它与Python无关。你可以加载回C++或Java后端，或者也可以加载回Python。这意味着它是可移植的。你可以获取这个JSON文件并部署到手机上。
- en: Okay。 Question。 >> Are there Java fun ends for nx？ >> Yes。 So we have Java and
    Scala front end。 You may have a Java script。 That's a joke。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。问题。>> 是否有用于nx的Java前端？ >> 是的。我们有Java和Scala前端。你可能有JavaScript。这是个玩笑。
- en: '![](img/51e689b9fd720f52d52ecec55198d75e_23.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/51e689b9fd720f52d52ecec55198d75e_23.png)'
- en: Let me go through a little bit how hybridize works。 The other way we can do
    the un。habit block here。 The in-the function is not defined to before。 We defined
    two dense layers here。 The only thing here happens here。 We don't define a forward
    function。 We do a hybrid forward function。 And one change here we add in F here。
    Before we don't have F。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: F is a function of space。 In the imperative model， F is just an indian space。
    When in the symbolic model， F is just symbol module。 It's another net space。 We
    can show you a letter。 We can print what is F and input X， send thing， give X
    to the。 hidden layer and the value here。 Note that the value can form the function
    space F。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: So in normal it's just an d。 Then we print the output of the hidden layer and
    put into the。 output layer and return the result。 That's as normal as before。
    But we're just adding three print here。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51e689b9fd720f52d52ecec55198d75e_25.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
- en: Let's do that。 Define the output， initialize it， get X and run the forward，
    function here。 You can see that firstly， F is just an m send and d array。 We print
    X。 The input X is just an d array。 The hint of the output is not an array as normal。
    We see that before and we get output here。 That's normal。 How you debugging things。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51e689b9fd720f52d52ecec55198d75e_27.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
- en: We can write the game， send results。 Def is the d array， input X。 the output
    of the hidden layer and。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51e689b9fd720f52d52ecec55198d75e_29.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
- en: output layer。 Next time， here's the interesting thing。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51e689b9fd720f52d52ecec55198d75e_31.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
- en: We can hybridize switch to the symbolic mode。 Then we run another game。 You
    can see that F has been changed to the symbol module。 You can think it's almost
    identical to the undi， but it's， in the symbolic presentation。 Any function available
    in the undi namespace is also available， in the symbol namespace。 What is X？
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: X is not an d array anymore。 X is a symbol。 It's called data。 The length data。
    The hint of output。 the hint of the layer is not an d array anymore。 It's just
    a symbol。 It's a symbol symbolic of the variable。 But at the end， we still get
    output here。 Nothing changed at the end。 What we actually do here is that -- let's
    go back to the。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51e689b9fd720f52d52ecec55198d75e_33.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
- en: definition here -- remember what impiles how we do is， symbolic programming。
    So this function。 again， will not run the real workload。 It just construct the
    symbolic expression as we defined the。 program stream before。 Here， X is a symbol
    input。 F is a symbol named space。 Then up here。 we just construct the symbolic
    program。 After that， the system we compile this program and feed it。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: with the data you actually put here and run the results。 So it has an additional
    construct and new network， compiled and run the results。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51e689b9fd720f52d52ecec55198d75e_35.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
- en: So what happens if you're going to run after hybridize， you're going to run
    the game。 Right again。 you only get the results。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51e689b9fd720f52d52ecec55198d75e_37.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
- en: You will not see all the intermediate things。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你不会看到所有的中间过程。
- en: '![](img/51e689b9fd720f52d52ecec55198d75e_39.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/51e689b9fd720f52d52ecec55198d75e_39.png)'
- en: That is because we only construct the graph once。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们只构建了图一次。
- en: '![](img/51e689b9fd720f52d52ecec55198d75e_41.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/51e689b9fd720f52d52ecec55198d75e_41.png)'
- en: So which means this function can only be run to once。 The first time you write。
    we construct a graph， compile it， and cache in the back end。 The next time you're
    going to write。 I'm not going to run， all the Python code so it can reduce the
    time。 No matter how low the program you have， I don't need to execute。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着这个功能只能运行一次。第一次你写时，我们构建图，编译并在后台缓存。下次你写时，我不会运行所有的 Python 代码，这样可以减少时间。无论你的程序多低效，我都不需要执行。
- en: one by one so I can reduce all this overhead。 So this benefit from performance。
    but the problem here， yes， again， print doesn't work anymore because you don't
    get。 the data yet at this point。 At this point， at only run once。 Only the first
    time time you get the print results。 The second time you will not get any results。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一个一个地进行，这样我可以减少所有的开销。这有助于提升性能。但是这里的问题是，是的，打印不再起作用，因为你在这个阶段还没有获得数据。此时，只会运行一次。只有第一次你会得到打印结果。第二次你将不会得到任何结果。
- en: So to debug this program， you need to add the print function。 provided by the
    underlying space to get the fancy to get it wrong。 Question。 >> You said they'll
    print it the first time， but not after that。 >> Yeah。 >> The first time you need
    to run the program to construct a， computation graph。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 所以为了调试这个程序，你需要添加由底层空间提供的打印函数，以便获取出错信息。问题是：>> 你说第一次它会打印，但之后不会。 >> 是的。 >> 第一次你需要运行程序来构建计算图。
- en: When the graph is done compiled， we are not going to run this， function anymore。
    Next time。 just to call the compiled objects here。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当图完成编译后，我们将不再运行这个功能。下次只需要在这里调用编译后的对象。
- en: '![](img/51e689b9fd720f52d52ecec55198d75e_43.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/51e689b9fd720f52d52ecec55198d75e_43.png)'
- en: '>> So when you call it that equals hybridized dance。'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '>> 所以当你调用它时，就会进行混合化的处理。'
- en: '![](img/51e689b9fd720f52d52ecec55198d75e_45.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/51e689b9fd720f52d52ecec55198d75e_45.png)'
- en: '>> Yeah。 >> Hybridized， yeah。 >> So after you call it that hybridized， the
    computation graph。 is constructed？ >> No。 This one can hint the back end and not
    switch the symbolic， execution。 If you can''t run the fourth pass here， which
    is net x， we can。'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '>> 是的。 >> 混合化，是的。 >> 那么在你调用混合化之后，计算图就会构建吗？ >> 不会。这只会提示后端，但不会切换到符号执行。如果你不能在这里运行第四次传递，也就是网格
    x，我们可以。'
- en: '![](img/51e689b9fd720f52d52ecec55198d75e_47.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/51e689b9fd720f52d52ecec55198d75e_47.png)'
- en: run this function， which is going to run this function hybrid， of forward。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个函数，它将运行混合的前向函数。
- en: '![](img/51e689b9fd720f52d52ecec55198d75e_49.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/51e689b9fd720f52d52ecec55198d75e_49.png)'
- en: The first time you run it， you can construct a graph and do， the thing。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次运行时，你可以构建图并执行相关操作。
- en: '![](img/51e689b9fd720f52d52ecec55198d75e_51.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/51e689b9fd720f52d52ecec55198d75e_51.png)'
- en: Similar to what we had the beginning。 So similar thing to here， you first run
    the fourth function。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于我们开始时的做法。所以在这里，首先运行第四个函数。
- en: '![](img/51e689b9fd720f52d52ecec55198d75e_53.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/51e689b9fd720f52d52ecec55198d75e_53.png)'
- en: and actually just give the string of the program。 And then the system will automatically
    insert these three。 things， compile it， use things at the end。 But the second
    I run it， I just run the s-cut。 It's good。 why？ And without running anything here。
    >> So even though it's an end hybrid block。 it's not symbolic， until you call
    net。 >> Yes。 >> It's still imperative on net。 >> Yes。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，只是给出程序的字符串，然后系统会自动插入这三个东西，进行编译并最终使用。但是第二次运行时，我只运行了 s-cut。很好，为什么？因为这里没有运行任何东西。>>
    所以即使这是一个结束混合块，它不是符号执行，直到你调用网格。 >> 是的。 >> 它仍然是命令式的在网格上。 >> 是的。
- en: '>> So because symbolic is so hard to use， we don''t encourage。'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '>> 所以因为符号执行非常难用，我们不推荐使用。'
- en: '![](img/51e689b9fd720f52d52ecec55198d75e_55.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/51e689b9fd720f52d52ecec55198d75e_55.png)'
- en: people to use it at the beginning。 So in practice， what we do here， just using
    normal imperative。 work to debug， to write a code and to test anything。 At the
    end， you think everything is normal。 Now I can run a large dataset， switch to
    the hybrid model and， run the experiments。 And also you're going to train the
    model， you're going to， deploy into your mobile phones。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始时，大家会用它。所以实际上，我们在这里做的，只是使用普通的命令式工作来调试、编写代码并进行测试。最终，你会认为一切都很正常。现在我可以运行一个大数据集，切换到混合模型并运行实验。你还将训练模型，并将其部署到你的手机上。
- en: you can use hybrid model。 That's only thing you're going to use it。 But before
    you debug。 everything just to keep it imperative。 Okay， so that's the end of this。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用混合模型。那是你唯一会用到的东西。但是在你调试之前，所有的事情都要保持命令式。好了，这就是全部内容。
- en: '![](img/51e689b9fd720f52d52ecec55198d75e_57.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/51e689b9fd720f52d52ecec55198d75e_57.png)'
