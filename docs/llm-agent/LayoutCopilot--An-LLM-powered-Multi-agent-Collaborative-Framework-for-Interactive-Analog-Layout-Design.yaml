- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-09-08 18:42:47'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: 'LayoutCopilot: An LLM-powered Multi-agent Collaborative Framework for Interactive
    Analog Layout Design'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://ar5iv.labs.arxiv.org/html/2406.18873](https://ar5iv.labs.arxiv.org/html/2406.18873)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Bingyang Liu^(2${\dagger}$), Xiaohan Gao^(3,1), Zichen Kong¹
  prefs: []
  type: TYPE_NORMAL
- en: Xiyuan Tang^(1,4), Yibo Lin^(1,5,6*), Runsheng Wang^(1,5,6), Ru Huang^(1,5,6)
    ¹School of Integrated Circuits ²School of Electronics Engineering and Computer
    Science ³School of Computer Science ⁴Institute for Artificial Intelligence, Peking
    University, Beijing, China
  prefs: []
  type: TYPE_NORMAL
- en: ⁵Beijing Advanced Innovation Center for Integrated Circuits, Beijing, China
  prefs: []
  type: TYPE_NORMAL
- en: ⁶Institute of Electronic Design Automation, Peking University, Wuxi, China
  prefs: []
  type: TYPE_NORMAL
- en: Abstract.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Analog layout design heavily involves interactive processes between humans and
    design tools. The tools are usually designed to use scripting commands or visualized
    buttons for manipulation, especially for those interactive automation functionalities,
    which have a steep learning curve and cumbersome user experience, making a notable
    barrier to their adoption by designers. Aiming to address such a usability issue,
    this paper introduces LayoutCopilot, a pioneering multi-agent collaborative framework
    powered by Large Language Models (LLMs) for interactive analog layout design.
    LayoutCopilot simplifies human-tool interaction by converting natural language
    instructions into executable script commands, and it interprets high-level design
    intents into actionable suggestions, significantly streamlining the design process.
    Experimental results demonstrate the flexibility, efficiency, and accessibility
    of LayoutCopilot in handling real-world analog designs.
  prefs: []
  type: TYPE_NORMAL
- en: '^(${\dagger}$)Equal Contribution.^*Corresponding author: yibolin@pku.edu.cn'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Analog layout design is a critical phase in analog circuit design that relies
    heavily on the manual effort of skilled designers. This dependence is largely
    due to the complexity of analog circuit performance models and the additional
    considerations such as symmetry, matching, signal flow, and other constraints,
    which pose significant challenges in generating high-quality layouts with superior
    performance. Therefore, efficiently generating high-quality layouts of analog
    circuits is a major challenge for both commercial tools and academic research.
  prefs: []
  type: TYPE_NORMAL
- en: Commercial analog layout design platforms like Cadence Virtuoso ([virtuoso2023,](#bib.bib1)
    ) mainly provide manual layout drawing interfaces and a few interactive layout
    automation functionalities. However, the learning curve for such platforms is
    very steep due to complicated buttons, shortcut keys, and scripting commands for
    manipulation. Their interactive layout automation functionalities require designers
    to type all the constraints, which is extremely tedious and rarely adopted by
    designers in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Academic studies have focused on both fully automated analog design methodologies
    and interactive automation. Over the past four decades, a series of analog placement
    & routing algorithms have been proposed to automate layout design. These algorithms
    explore various methods and perspectives, including traditional algorithmic approaches ([391116,](#bib.bib2)
    ; [510537,](#bib.bib3) ; [malavasi1990routing,](#bib.bib4) ; [xiao2010practical,](#bib.bib5)
    ; [xu2017hierarchical,](#bib.bib6) ), domain-knowledge based methods ([basaran1993latchup,](#bib.bib7)
    ; [ou2013simultaneous,](#bib.bib8) ; [martins2016current,](#bib.bib9) ; [xu2019device,](#bib.bib10)
    ; [ho2013coupling,](#bib.bib11) ), and the integration of machine learning techniques ([li2020exploring,](#bib.bib12)
    ; [li2020customized,](#bib.bib13) ; [gusmao2020semi,](#bib.bib14) ). All are aimed
    at boosting the efficiency and performance of final layout results, paving the
    way for the development of fully automated tools. Recent advancements in fully
    automated tools for analog layout design such as ALIGN  ([kunal_align_2019,](#bib.bib15)
    ; [dhar_align_2021,](#bib.bib16) ; [sapatnekar_align_2023,](#bib.bib17) ) and
    MAGICAL  ([xu_magical_2019,](#bib.bib18) ; [chenMAGICALOpenSource2021,](#bib.bib19)
    ; [chen_magical_2021,](#bib.bib20) ), have significantly improved design efficiency
    in analog layout generation. However, despite their advancements, these tools
    often fall short of accommodating the highly customized needs of analog layout
    design. To address this, interactive analog layout editing tools  ([gaoInteracplacement,](#bib.bib21)
    ; [gao_interactive_2023,](#bib.bib22) ) have been developed to allow designers
    to modify and optimize layouts more easily. While these tools offer enhanced flexibility
    in layout design, similar to commercial tools, they also introduce a new usability
    challenge as designers must master complex command sets and effectively apply
    them in circuit optimization.
  prefs: []
  type: TYPE_NORMAL
- en: The above usability challenges come from the fundamental gap between human natural
    language and machine language. It is not easy to convert both designers’ concrete
    tasks and abstract design intents into executable commands for machines. Recent
    advances in large language models (LLMs) bring a new opportunity to bridge the
    gap. Recently prevailing models like GPT-3 ([brown2020language,](#bib.bib23) ),
    Llama ([touvron2023llama,](#bib.bib24) ; [touvron2023llama2,](#bib.bib25) ), GPT-4 ([openai_gpt-4_2024,](#bib.bib26)
    ), and Claude ([claude2,](#bib.bib27) ) ([claude3,](#bib.bib28) ) have demonstrated
    remarkable capabilities in not only understanding and generating human-like text
    but also reasoning and comprehending abstract domain knowledge, paving the way
    for innovative applications across various domains. This evolution, along with
    advances in knowledge retrieval techniques ([lewis_retrieval-augmented_nodate,](#bib.bib29)
    ) and the proven effectiveness of multi-agent approaches in tackling complex reasoning
    tasks ([wu_autogen_2023,](#bib.bib30) ; [rasal_llm_2024,](#bib.bib31) ; [hong_metagpt_2023,](#bib.bib32)
    ), sets a new stage for enhancing human-computer interaction in intricate technical
    tasks. Such advancements have led to diverse applications within EDA ([liu_rtlcoder_2024,](#bib.bib33)
    ; [thakur_verigen_2024,](#bib.bib34) ; [lu_rtllm_2023,](#bib.bib35) ; [liu_verieval_2023,](#bib.bib36)
    ; [tsai_rtlfixer_2024,](#bib.bib37) ; [liu_chipnemo_2024,](#bib.bib38) ; [he_chateda_2024,](#bib.bib39)
    ; [wang2024chatpattern,](#bib.bib40) ), but mainly focused on digital circuits,
    where mature automation solutions have been widely adopted without heavy human-tool
    interaction. Thus, the field of analog layout design presents a unique opportunity
    as it has not yet fully explored using LLMs to tackle layout tool usability challenges.
  prefs: []
  type: TYPE_NORMAL
- en: '![Refer to caption](img/45e3e958feb52f5c5b7e76225d0b3093.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1\. A brief introduction of analog layout automation and our motivation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this paper, we introduce LayoutCopilot, a pioneering multi-agent collaborative
    framework powered by LLMs for interactive analog layout design. LayoutCopilot
    is proficient in processing concrete layout adjustment requests, translating them
    into executable commands that reduce the learning curve associated with interactive
    tools. Additionally, it leverages a comprehensive knowledge base to generate practical
    suggestions according to the designer’s high-level design intents, thus addressing
    the usability challenges posed by the inherent complexity of analog design. The
    main contributions of this paper can be summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To the best of our knowledge, LayoutCopilot is the first LLM-powered interactive
    analog layout design framework, offering a novel approach to enhance design flexibility
    and efficiency in analog circuit design.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We bridge the interaction gap between designers and analog layout tools with
    a framework powered by LLMs, overcoming the usability challenge of layout tools
    and refining the methodology of interactive layout design.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We utilize a multi-agent collaborative framework that progressively transforms
    designer requirements into executable commands through coordinated efforts among
    multiple LLM agents, achieving high accuracy.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bulk testing and experiments on real-world analog designs have shown that LayoutCopilot
    can accurately address the designer’s concrete layout adjustment requests and
    offer actionable suggestions to complete layout optimization based on their high-level
    design intents.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The rest of the paper is organized as follows. Section [2](#S2 "2\. Preliminaries
    ‣ LayoutCopilot: An LLM-powered Multi-agent Collaborative Framework for Interactive
    Analog Layout Design") describes the background; Section [3](#S3 "3\. LayoutCopilot
    Framework ‣ LayoutCopilot: An LLM-powered Multi-agent Collaborative Framework
    for Interactive Analog Layout Design") explains the detailed implementation; Section [4](#S4
    "4\. Experimental Results ‣ LayoutCopilot: An LLM-powered Multi-agent Collaborative
    Framework for Interactive Analog Layout Design") demonstrates the results; Section [5](#S5
    "5\. Conclusion ‣ LayoutCopilot: An LLM-powered Multi-agent Collaborative Framework
    for Interactive Analog Layout Design") concludes the paper.'
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Preliminaries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section reviews the background concepts of our study, including the integration
    of LLMs with EDA, prompt engineering, multi-agent collaboration, and the interactive
    placement and routing in analog layout design, additionally outlining the scope
    of LayoutCopilot.
  prefs: []
  type: TYPE_NORMAL
- en: 2.1\. Integrating LLMs into EDA Applications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Recent advancements in pre-trained large language models (LLMs) have unveiled
    new opportunities for enhancing EDA applications. The ability of LLMs to generate
    human-like text and understand complex concepts makes them ideally suited for
    integration into EDA tasks, ranging from auto-generating Hardware Description
    Language (HDL) code to facilitating interactive design workflows through conversational
    interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: One segment of research has focused on harnessing LLMs to tackle textual or
    language-based tasks in EDA autonomously. This includes efforts to auto-generate
    HDL code using tools like RTLCoder and VeriGen ([liu_rtlcoder_2024,](#bib.bib33)
    ; [thakur_verigen_2024,](#bib.bib34) ), along with benchmarks like RTLLM and VerilogEval
    for assessing these capabilities ([lu_rtllm_2023,](#bib.bib35) ; [liu_verieval_2023,](#bib.bib36)
    ). Additionally, RTLFixer ([tsai_rtlfixer_2024,](#bib.bib37) ) is exploring automated
    debugging and code repair, whereas ChipNeMo ([liu_chipnemo_2024,](#bib.bib38)
    ) serves as an engineering assistant chatbot, facilitating EDA script generation
    and bug analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Another pathway seeks to help traditional design flows and existing EDA tools
    with LLMs, thus enhancing their accessibility and ease of use. This is exemplified
    by ChatEDA ([he_chateda_2024,](#bib.bib39) ) and ChatPattern ([wang2024chatpattern,](#bib.bib40)
    ), which typically feature a conversational interface that allows designers to
    express their needs in natural language, thereby facilitating the indirect manipulation
    of EDA tools via LLMs. Introducing conversational interfaces powered by LLMs helps
    tackle long-standing usability challenges in EDA tools. Inspired by conversational
    interfaces in EDA tools, we applied LLMs to interactive analog layout design.
    Considering the custom nature of analog circuits, LayoutCopilot not only facilitates
    direct command execution but also generates actionable suggestions based on high-level
    design intents, streamlining the design process.
  prefs: []
  type: TYPE_NORMAL
- en: 2.2\. Prompt Engineering
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Prompts are natural language instructions that provide context to guide the
    generative language model. Prompt engineering is the process of leveraging prompts
    to enhance model efficacy without modifying parameters of the core model ([sahoo2024systematic,](#bib.bib41)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: 'Prompt Engineering offers a lightweight solution for utilizing large models
    to solve real-world problems. Unlike traditional methods that require extensive
    data set creation, fine-tuning, and repetitive adjusting to enhance a model’s
    performance on specific tasks, prompt engineering allows practitioners to directly
    transmit knowledge and methodologies to the model through carefully designed prompts.
    This approach is especially crucial in fields where data acquisition and cleansing
    are challenging, such as EDA. Many approaches of prompt engineering such as few-shot
    learning ([LanguageModelsareFewShotLearners,](#bib.bib42) ), chain-of-thought ([ChainOfThoughtPromptingElicitsReasoninginLargeLanguageModels,](#bib.bib43)
    ), least-to-most ([LeastToMostPromptingEnablesComplexReasoningInLargeLanguageModels,](#bib.bib44)
    ), and self-refine strategy ([SelfRefineIterativeRefinementwithSelfFeedback,](#bib.bib45)
    ) have been explored and proven to enhance the reasoning capabilities and overall
    performance of LLMs. To handle complex reasoning tasks in our application, LayoutCopilot
    integrates various Prompt Engineering techniques. Each agent is tailored according
    to the specific task it performs to achieve better performance. Details about
    the structure of prompts will be presented in Section [3](#S3 "3\. LayoutCopilot
    Framework ‣ LayoutCopilot: An LLM-powered Multi-agent Collaborative Framework
    for Interactive Analog Layout Design")'
  prefs: []
  type: TYPE_NORMAL
- en: '![Refer to caption](img/c4c4afe0851801b42b67e2696ac867dc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2\. System comparison: overcoming single agent limitations through multi-agent
    collaboration.'
  prefs: []
  type: TYPE_NORMAL
- en: Apart from manually configured prompts, there are also techniques for automatic
    prompt generation. A classic example is Retrieval-Augmented Generation (RAG)  ([RetrievalAugmentedGenerationForKnowledgeIntensiveNLPTasks,](#bib.bib46)
    ), which enhances the model’s interaction with external knowledge bases. As previously
    mentioned, prompts often contain a few examples, thus aligning with the ‘few-shot’
    approach. RAG allows these examples to be automatically retrieved from a database
    or knowledgebase, providing an interface through which LLMs can access external
    knowledge and align their responses accordingly. However, the retrieved context,
    combined with system instructions and designer requests, is fed as text input
    to the LLM, which could lead to prompt dilution if the context is overly extensive.
    This can result in a decrease in response quality, an issue we have observed in
    our experiments. To address this, we employ a multi-agent methodology to segment
    different tasks among several LLM agents, ensuring that knowledge retrieval does
    not compromise the performance of other system components. By separating agents
    with distinct responsibilities, we maintain system efficiency even as we integrate
    context-extensive retrieval technologies into our framework.
  prefs: []
  type: TYPE_NORMAL
- en: 2.3\. Multi-Agent Collaboration with LLMs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The objective of multi-agent collaboration is to enable multiple autonomous
    agents to effectively collaborate towards a shared goal  ([zhang2024proagent,](#bib.bib47)
    ). Figure  [2](#S2.F2 "Figure 2 ‣ 2.2\. Prompt Engineering ‣ 2\. Preliminaries
    ‣ LayoutCopilot: An LLM-powered Multi-agent Collaborative Framework for Interactive
    Analog Layout Design") illustrates the contrast between the capabilities of single
    and multi-agent systems, highlighting how multi-agent collaboration significantly
    enhances the system’s capacity by leveraging the specialized expertise of each
    agent and preventing task interference. This allows the system to manage a considerably
    larger workload than possible without such specialization, leading to improved
    efficiency and output quality ([xi2023rise,](#bib.bib48) ).'
  prefs: []
  type: TYPE_NORMAL
- en: After role-playing capabilities were introduced into communicative agent interactions
    by ([li2023camel,](#bib.bib49) ), ([talebirad2023multi,](#bib.bib50) ) proposed
    a comprehensive LLM-based multi-agent collaboration framework that demonstrated
    efficiency enhancements in handling complex tasks. Based on these works, multi-agent
    methodologies have been successfully deployed in various applications, proving
    their effectiveness in scenarios such as text understanding, reasoning, mathematics,
    coding, and tool utilization  ([rasal2024llm,](#bib.bib51) ; [wu2023autogen,](#bib.bib52)
    ; [chen2023agentverse,](#bib.bib53) ). Furthermore, several improvements have
    been proposed to enhance multi-agent collaboration, including  ([hong2023metagpt,](#bib.bib54)
    ), which transfers professional knowledge and management experience to LLM agents
    for more structured collaboration, and  ([zhang2024proagent,](#bib.bib47) ), which
    improves cooperation by enabling agents to predict their collaborators’ actions.
  prefs: []
  type: TYPE_NORMAL
- en: In LayoutCopilot, we have developed a multi-agent collaborative framework that
    divides complex tasks into specialized subtasks. This strategic division of labor
    ensures that each agent can operate within its expertise without diluting the
    prompt or compromising other tasks’ performance.
  prefs: []
  type: TYPE_NORMAL
- en: '![Refer to caption](img/763251e2e3d319ffa6eab03844f8d862.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3\. Illustration of basic analog layout automation method.
  prefs: []
  type: TYPE_NORMAL
- en: 2.4\. Interactive Analog Layout Design
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Analog layout automation has engaged many researchers in recent years and several
    basic methodologies have emerged ([xiao2010practical,](#bib.bib5) ; [xu2017hierarchical,](#bib.bib6)
    ; [ou2013simultaneous,](#bib.bib8) ; [martins2016current,](#bib.bib9) ; [xu2019device,](#bib.bib10)
    ; [ho2013coupling,](#bib.bib11) ; [li2020customized,](#bib.bib13) ; [gusmao2020semi,](#bib.bib14)
    ; [kunal_align_2019,](#bib.bib15) ; [dhar_align_2021,](#bib.bib16) ; [sapatnekar_align_2023,](#bib.bib17)
    ; [xu_magical_2019,](#bib.bib18) ; [chenMAGICALOpenSource2021,](#bib.bib19) ;
    [chen_magical_2021,](#bib.bib20) ; [gaoInteracplacement,](#bib.bib21) ; [gao_interactive_2023,](#bib.bib22)
    ). The analog placement problem can be formulated into a nonlinear optimization
    problem. The most common objective function is half-perimeter wire length (HPWL),
    indicating the performance of wire length. Different from digital placement, analog
    placement will consider more constraints such as symmetry, array, etc. The analog
    routing problem is a pathfinding problem that can be solved by a typical shortest
    path algorithm (A-star).
  prefs: []
  type: TYPE_NORMAL
- en: 'An interactive analog layout design framework offers flexible adjustments to
    the layouts while relieving designers from tedious manual layout drawing. By introducing
    high-level interactive controllers, the framework can leverage placement and routing
    kernels to automatically adjust the layout, as shown in Figure [3](#S2.F3 "Figure
    3 ‣ 2.3\. Multi-Agent Collaboration with LLMs ‣ 2\. Preliminaries ‣ LayoutCopilot:
    An LLM-powered Multi-agent Collaborative Framework for Interactive Analog Layout
    Design"). Based on the interactive layout design framework, designers can add
    arbitrary placement constraints and refine the routing solution according to their
    design experience. After several adjustments, designers can finally obtain a high-quality
    layout.'
  prefs: []
  type: TYPE_NORMAL
- en: 2.5\. The Scope of LayoutCopilot
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'LayoutCopilot functions as a multi-agent collaborative framework designed to
    enhance the interaction between designer and layout tools, illustrated by Figure [1](#S1.F1
    "Figure 1 ‣ 1\. Introduction ‣ LayoutCopilot: An LLM-powered Multi-agent Collaborative
    Framework for Interactive Analog Layout Design"). Its primary objective is to
    interpret design intents expressed in natural language and generate actionable
    commands that effectively interact with layout tools.'
  prefs: []
  type: TYPE_NORMAL
- en: Problem 1. (Objective of LayoutCopilot) Develop an LLM-powered framework that
    accepts both high-level design intents and concrete requests in natural language
    from designers and then transforms them into precise executable commands. These
    commands aim to manipulate the layout tools directly, ensuring that the design
    intents are accurately translated into layout adjustments.
  prefs: []
  type: TYPE_NORMAL
- en: '![Refer to caption](img/12078838e7c7d264c14c748435e550a4.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4\. Overview of LayoutCopilot.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. LayoutCopilot Framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section introduces the architecture and functionality of LayoutCopilot,
    a multi-agent collaboration framework enhanced by LLMs for interactive analog
    layout design. LayoutCopilot enhances the interaction between designers and layout
    tools by understanding complex requirements in natural language, utilizing a knowledge
    base for solution generation, and automating layout design. It consists of two
    primary components: the Analog Circuit Analyzer and the Concrete Request Processor,
    as illustrated in Figure [4](#S2.F4 "Figure 4 ‣ 2.5\. The Scope of LayoutCopilot
    ‣ 2\. Preliminaries ‣ LayoutCopilot: An LLM-powered Multi-agent Collaborative
    Framework for Interactive Analog Layout Design"). The Analog Circuit Analyzer
    initiates the processing of requests, transforming them into concrete requests
    that adhere to layout tool manuals. These concrete requests are then transferred
    to the Concrete Request Processor, which generates executable commands to facilitate
    layout editing. This workflow simplifies interactions between layout tools and
    designers, enhancing the overall design process. Detailed discussions on each
    component’s functionality and the rationale for their design are provided in the
    subsequent subsections.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.1\. Analog Circuit Analyzer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Analog Circuit Analyzer plays a key role in LayoutCopilot, managing and
    processing diverse requests from designers. It performs a series of functions
    including categorization of requests, retrieval of relevant knowledge, iterative
    adjustments in collaboration with designers, and analyzing netlists to transform
    abstract requests into concrete ones that align with layout tool manuals. This
    component is powered by four specialized LLM agents, each dedicated to a specific
    aspect of the processing pipeline: classification, analysis, solution refinement,
    and solution adaptation, as shown in Figure  [4](#S2.F4 "Figure 4 ‣ 2.5\. The
    Scope of LayoutCopilot ‣ 2\. Preliminaries ‣ LayoutCopilot: An LLM-powered Multi-agent
    Collaborative Framework for Interactive Analog Layout Design"). Details of these
    agents will be shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the head of the analyzer lies a task classifier agent, determining designers’
    requirements as either concrete or abstract requests based on the manual of layout
    tools. Concrete tasks are identified by their direct translatability into commands
    or combinations explicitly supported by the layout tools, for example, ‘add symmetry
    between M6 and M7’. Conversely, abstract requests are recognized for their high-level,
    conceptual nature, necessitating a comprehensive analysis grounded in the netlist
    of circuits and knowledge of layout design to be deconstructed into executable
    steps, such as ‘Enhance the matching’ and ‘Improve the CMRR’. Building on these
    criteria, an LLM agent executes the task classification. Once classified, the
    tasks are directed into two distinct flows: concrete tasks are sent directly to
    the Concrete Request Processor for immediate processing. At the same time, abstract
    requests undergo a series of steps to be transformed into concrete requests before
    they are processed in the same manner as concrete requests. Classifying tasks
    before further processing allows for their assignment to specialized agents, simplifying
    the overall workflow and enhancing the quality of the responses.'
  prefs: []
  type: TYPE_NORMAL
- en: The Analyzer Agent is dedicated solely to the analysis and knowledge retrieval
    task, which is crucial given LLMs’ limitations with long context lengths. Tasks
    that require extensive context can use up much of this capacity, potentially diluting
    prompts and reducing the effectiveness of other tasks. Thus, this agent focuses
    exclusively on knowledge retrieval to prevent these issues. The Analyzer Agent
    operates within a vast knowledge base that spans specialized literature on the
    analog circuit and layout design, layout tool manual, and archives of previous
    tasks and solutions. It crafts high-level solutions based on knowledge, functioning
    similarly to a skilled architect drafting a blueprint before construction and
    outlining strategic approaches to the task. For example, when tasked with ‘enhancing
    the CMRR of an OTA’, the agent might suggest optimizing component placement to
    enhance symmetry and rerouting connections to improve parasitic matching, all
    tailored to the specific capabilities of the chosen layout tools.
  prefs: []
  type: TYPE_NORMAL
- en: Considering analog designers’ rich experience and highly customized requirements,
    enhancing their involvement in the workflow is crucial. The Solution Refiner Agent
    effectively facilitates this by presenting high-level solutions to designers with
    evaluations and explanations, allowing them to select from or modify these solutions
    as needed. If the designers find the solutions unsatisfactory, they can add more
    details or revert to the Analyzer Agent for adjustments. This ensures that the
    process is highly responsive to designer needs. Refined solutions are then passed
    to the Solution Adapter Agent to be transformed into concrete requests aligned
    with the circuit’s netlist.
  prefs: []
  type: TYPE_NORMAL
- en: '![Refer to caption](img/67941d8f4325d89b308387112ed5938f.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5\. Illustration of the configuration for a single agent in LayoutCopilot.
  prefs: []
  type: TYPE_NORMAL
- en: The Solution Adapter Agent is the final component of the Analog Circuit Analyzer,
    tasked with converting refined solutions into concrete, actionable requests. Depending
    on the size, netlists are either communicated directly to the LLM during dialogues
    or stored in a knowledge base accessed via the LLM’s retrieval interface. This
    agent meticulously analyzes the netlist to extract specific parameters following
    the directives from refined solutions. For example, when receiving a refined solution
    that says ‘enhance the symmetry of differential pairs and capacitors’, the Solution
    Adapter Agent locates these components in the netlist by their connectivity and
    device parameters. It then formulates concrete requests to apply symmetry constraints
    to the identified components, such as ‘add symmetry between M6 and M7’. This agent
    is also familiar with the layout tools’ manuals, which ensures that the generated
    requests are compatible with the back-end tools. This stage guarantees that the
    solutions are not merely theoretical but practically implementable, guiding further
    design steps precisely.
  prefs: []
  type: TYPE_NORMAL
- en: 3.2\. Concrete Request Processor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Concrete Request Processor is dedicated to accurately translating concrete
    tasks into executable commands that fulfill designer requirements via layout tools.
    The process begins by decomposing concrete tasks into subtasks, each corresponding
    to a command detailed in the manual of layout tools, akin to the processes used
    by ChatEDA ([he_chateda_2024,](#bib.bib39) ) and ChatPattern ([wang2024chatpattern,](#bib.bib40)
    ). However, merely adopting these methods does not guarantee that the generated
    commands will execute correctly or achieve the desired results. Distinct from
    previous works, our approach incorporates role-playing and task decomposition
    techniques while conveying the syntactic and logical rules dictated by the layout
    tools’ manuals to the Code Generator Agent. This enrichment ensures that the command
    sequences generated by the agent maintain high accuracy in syntax and logic, especially
    when dealing with complex input requests. This strategic enhancement is committed
    to improving the precision and reliability of the process, closely aligning with
    the specific operational requirements of the layout tools.
  prefs: []
  type: TYPE_NORMAL
- en: 3.3\. Agent Configuration and Prompt Design
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Each agent in the LayoutCopilot framework is equipped with prompts tailored
    to its designated task. These prompts are crafted using the prompt engineering
    techniques described in Section [2](#S2 "2\. Preliminaries ‣ LayoutCopilot: An
    LLM-powered Multi-agent Collaborative Framework for Interactive Analog Layout
    Design"), chosen to enhance the overall expressive capabilities of the agents
    based on experimental results, as illustrated in Figure [5](#S3.F5 "Figure 5 ‣
    3.1\. Analog Circuit Analyzer ‣ 3\. LayoutCopilot Framework ‣ LayoutCopilot: An
    LLM-powered Multi-agent Collaborative Framework for Interactive Analog Layout
    Design").'
  prefs: []
  type: TYPE_NORMAL
- en: 'The seven prompt sections are described in detail as follows: A. Role Play
    encourages the agent to adopt a persona that helps simulate a realistic and professional
    scenario for task handling. B. Workflow Overview provides agents with an understanding
    of their roles within the whole system, highlighting how their outputs influence
    subsequent stages of the design process. C. Task Description delineates the specific
    responsibilities and objectives of the agent, ensuring focused and relevant task
    execution. D. Pipeline guides agents through a chain-of-thought approach to tackle
    the assigned tasks efficiently. This enhances the agents’ reasoning capabilities
    and directs them to break down complex tasks into manageable sub-tasks, improving
    their ability to handle intricate problems. E. Information Verification instructs
    the agent to verify the completeness of the input before proceeding, prompting
    for additional information if required. This acts as a self-refine strategy, effectively
    preventing errors arising from incomplete or inaccurate inputs.F. Interaction
    Guideline directs the agent on interacting with the user and other agents, ensuring
    that the entire process remains cohesive and efficient. G. External Knowledge
    enables the agent to access a comprehensive repository of books, manuals, and
    experiential knowledge, which are either communicated directly to the LLM during
    dialogues or stored in a knowledge base accessed via the LLM’s retrieval interface.
    This enriches its output with domain-specific insights'
  prefs: []
  type: TYPE_NORMAL
- en: In summary, these prompt components ensure that each agent operates not only
    as a specialist in its respective domain but also as a coherent part of the larger
    system, enhancing the overall functionality and efficiency of the LayoutCopilot.
  prefs: []
  type: TYPE_NORMAL
- en: 3.4\. Interactive Layout Editor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Table 1\. Interactive command set.
  prefs: []
  type: TYPE_NORMAL
- en: '| Command | Parameters |'
  prefs: []
  type: TYPE_TB
- en: '| deviceMove | device $v_{i}$ |'
  prefs: []
  type: TYPE_TB
- en: '| deviceSwap | devices $v_{i},v_{j}$ |'
  prefs: []
  type: TYPE_TB
- en: '| arrayAdd | a list of devices ${v_{i}}$ |'
  prefs: []
  type: TYPE_TB
- en: '| arraySpace | an array group $g_{i}$ |'
  prefs: []
  type: TYPE_TB
- en: '| symAdd | devices $v_{i},v_{j}$ |'
  prefs: []
  type: TYPE_TB
- en: '| netRemove | net $n_{i}$ |'
  prefs: []
  type: TYPE_TB
- en: '| netReroute | net $n_{i}$ |'
  prefs: []
  type: TYPE_TB
- en: '| wireWidth | wire $w_{i}$ |'
  prefs: []
  type: TYPE_TB
- en: '| wireSpacing | wire $w_{i}$ |'
  prefs: []
  type: TYPE_TB
- en: '| wire $w_{i}$ |'
  prefs: []
  type: TYPE_TB
- en: '| netPriority | a list of nets ${n_{i}}$ with their priorities |'
  prefs: []
  type: TYPE_TB
- en: '| netTopology | net $n_{i}$ |'
  prefs: []
  type: TYPE_TB
- en: Table 2\. Sanity checks and comparison for single-agent with instruction vs.
    multi-agent with and without instruction.
  prefs: []
  type: TYPE_NORMAL
- en: '| Category | Single-agent w/ Instruction | Multi-agent w/o Instruction | Multi-agent
    w/ Instruction |'
  prefs: []
  type: TYPE_TB
- en: '| GPT-3.5 | GPT-4 | Claude 3 | Avg. | GPT-3.5 | GPT-4 | Claude 3 | Avg. | GPT-3.5
    | GPT-4 | Claude 3 | Avg. |'
  prefs: []
  type: TYPE_TB
- en: '| Formatting | 71.14% | 90.91% | 99.25% | 87.20% | 82.00% | 97.92% | 99.83%
    | 93.25% | 95.38% | 99.76% | 99.92% | 98.26% |'
  prefs: []
  type: TYPE_TB
- en: '| Validity | 91.36% | 93.60% | 95.44% | 93.47% | 96.88% | 99.20% | 98.40% |
    98.16% | 98.24% | 99.28% | 98.88% | 98.77% |'
  prefs: []
  type: TYPE_TB
- en: '| Syntax | 67.11% | 88.87% | 95.24% | 83.74% | 79.20% | 95.28% | 97.76% | 90.75%
    | 92.65% | 97.20% | 96.96% | 95.60% |'
  prefs: []
  type: TYPE_TB
- en: '| Logic | 66.44% | 83.04% | 91.67% | 80.38% | 76.16% | 93.44% | 95.20% | 88.27%
    | 91.24% | 94.24% | 98.80% | 94.76% |'
  prefs: []
  type: TYPE_TB
- en: '| Overall | 66.27% | 82.91% | 90.77% | 79.98% | 75.76% | 93.36% | 94.56% |
    87.89% | 90.92% | 93.92% | 96.80% | 93.75% |'
  prefs: []
  type: TYPE_TB
- en: 'Interactive layout editor bridges the gap between fully automated analog layout
    tools and real-world industrial applications. Our interactive analog editor is
    based on previous interactive works ([gaoInteracplacement,](#bib.bib21) ; [gao_interactive_2023,](#bib.bib22)
    ) with some extensions. Figure [6](#S3.F6 "Figure 6 ‣ 3.4\. Interactive Layout
    Editor ‣ 3\. LayoutCopilot Framework ‣ LayoutCopilot: An LLM-powered Multi-agent
    Collaborative Framework for Interactive Analog Layout Design") shows the overview
    of the interactive layout editor. Before the interactive adjustment flow starts,
    an initial layout is given by fully automated tools. These tools take the netlists,
    technology files, and some basic constraints as the input. Based on the initial
    layout, users can start making interactive layout adjustments more intuitively
    through the user interface. The user interface consists of a natural language
    interface and a layout GUI. Compared to the previous script-based interface ([gaoInteracplacement,](#bib.bib21)
    ; [gao_interactive_2023,](#bib.bib22) ), users can use natural language to adjust
    the analog layout directly. After converting the natural language into a list
    of commands in the command set shown in Table  [1](#S3.T1 "Table 1 ‣ 3.4\. Interactive
    Layout Editor ‣ 3\. LayoutCopilot Framework ‣ LayoutCopilot: An LLM-powered Multi-agent
    Collaborative Framework for Interactive Analog Layout Design"), the command interpreter
    will decompose each command into placement and routing operations. After the adjustment,
    the layout result will be shown in the GUI. Users can further adjust the layout
    according to the given result.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Refer to caption](img/8a1333735bdf4149e15f0e8b8eb9e383.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6\. Overview of the interactive layout editor.
  prefs: []
  type: TYPE_NORMAL
- en: For placement adjustment, users are provided with seven different commands.
    Theoretically, arbitrary placement adjustments can be achieved by the combination
    of these commands. move command can move a device to a given location. swap command
    can swap the location of two given devices. For array-based adjustment, the arrayAdd
    command adds the array constraints to a group of devices and arraySpace adjusts
    the space between devices in the array group. Symmetry constraints can be added
    by symAdd command. With these commands, users can make placement adjustments easily.
    For instance, the Solution Refiner Agent decided earlier to enhance the symmetry
    of differential pairs, and the Solution Adapter Agent identified a differential
    pair {M6, M7}. Then the layout modification can be achieved by executing symAdd
    M6 M7, generated by the Concrete Request Processor.
  prefs: []
  type: TYPE_NORMAL
- en: For routing adjustment, users are provided with six different commands. remove
    and reroute are basic commands for removing unsatisfied wires and rerouting them.
    wireWidth command can change the width of a given net or wire to improve the layout
    performance. wireSpacing command can adjust the spacing between two nets to avoid
    the signal cross-talk. netPriority command can designate a specific routing priority
    of nets. Manual guidance can be set by netTopology command, and the final routing
    solution will follow the guidance tightly. With these commands, users can accomplish
    arbitrary routing adjustments.
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Experimental Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: LayoutCopilot is designed as a multi-agent collaborative framework that incorporates
    mechanisms for agent cooperation and detailed configurations for each agent. It
    is adaptable to various LLMs and layout tools, facilitating flexible deployment
    across different environments. In our experiments, we utilize a mature interactive
    analog layout design tool  ([gaoInteracplacement,](#bib.bib21) ; [gao_interactive_2023,](#bib.bib22)
    ) for demonstration. Moreover, we employ different versions of prevailing LLMs
    to demonstrate the versatility of LayoutCopilot including GPT-3.5 ([brown2020language,](#bib.bib23)
    ), GPT-4 ([openai_gpt-4_2024,](#bib.bib26) ), and Claude3 ([claude3,](#bib.bib28)
    ). Next, we will conduct experiments separately for concrete and abstract requests,
    showcasing LayoutCopilot’s accuracy in handling basic tasks and its capacity to
    manage complex and comprehensive circuit optimization tasks.
  prefs: []
  type: TYPE_NORMAL
- en: '4.1\. Concrete Requests: Comprehensive Evaluation'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To assess the effectiveness of our framework and the quality of the outputs
    it generates, we conduct experiments on concrete requests. These requests are
    expressed in natural language that can be straightforwardly transformed into command
    sequences for back-end tools. We utilize GPT-3.5 ([LanguageModelsareFewShotLearners,](#bib.bib42)
    ) and Claude-3 ([claude3,](#bib.bib28) ) to generate a total of 1,250 cases, consisting
    of 1,134 valid concrete requests and 116 invalid requests. The invalid requests
    typically lack essential parameters or described operations in an order that violates
    the predefined rules in the manual, and we have verified these manually to confirm
    their invalidity. Each request contains between 1 to 40 commands from Table  [1](#S3.T1
    "Table 1 ‣ 3.4\. Interactive Layout Editor ‣ 3\. LayoutCopilot Framework ‣ LayoutCopilot:
    An LLM-powered Multi-agent Collaborative Framework for Interactive Analog Layout
    Design"), ensuring a variety of scenarios in requests. LayoutCopilot processes
    each concrete request to generate a command sequence that the layout tool could
    execute to fulfill the requirement. To fully validate the performance of LayoutCopilot,
    we performed sanity check and functionality check on those test cases as described
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: 4.1.1\. Sanity Check
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This subsection introduces the experimental condition settings, test criteria,
    and results of the sanity check.
  prefs: []
  type: TYPE_NORMAL
- en: 'To validate the effectiveness of our agent configuration, we execute experiments
    under two distinct settings: one with the comprehensive configuration of the LLM
    through prompt engineering as outlined in Section [3.3](#S3.SS3 "3.3\. Agent Configuration
    and Prompt Design ‣ 3\. LayoutCopilot Framework ‣ LayoutCopilot: An LLM-powered
    Multi-agent Collaborative Framework for Interactive Analog Layout Design"), and
    the other by simply providing the LLM with the layout tool manual along with a
    straightforward task description that included input-output requirements. Additionally,
    comparative experiments are conducted using a single-agent setup under instructed
    conditions to demonstrate the necessity of the multi-agent methodology. In the
    multi-agent scenario, LayoutCopilot acts as a multi-agent collaborative framework,
    employing its Concrete Request Processor to manage requests from the test set.
    Conversely, the single-agent configuration merges all agent prompts mentioned
    in Section [3](#S3 "3\. LayoutCopilot Framework ‣ LayoutCopilot: An LLM-powered
    Multi-agent Collaborative Framework for Interactive Analog Layout Design") into
    a single LLM agent aimed at encompassing the entire functionality of LayoutCopilot
    for handling the test requests. To minimize the impact of different LLM engines
    on the experimental outcomes, bulk testing is performed using GPT-3.5, GPT-4,
    and Claude-3 as the LLM engines.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Regarding testing standards, the sanity check covers formatting, validity,
    syntax, logic rules, and overall accuracy. (i) For the output format, the agent
    is required to generate processing status and results in JSON following regular
    text dialogue, ensuring that layout tools can accurately interpret the content
    and implement the necessary layout adjustments. (ii) Validity is measured by the
    rate at which the system correctly identifies and responds to invalid inputs.
    We expect LayoutCopilot to be capable of detecting invalid inputs and providing
    feedback to designers, such as commands missing specific parameters. (iii) & (iv)
    We conduct syntactic and logical verification. Based on the command set in Table
    [1](#S3.T1 "Table 1 ‣ 3.4\. Interactive Layout Editor ‣ 3\. LayoutCopilot Framework
    ‣ LayoutCopilot: An LLM-powered Multi-agent Collaborative Framework for Interactive
    Analog Layout Design"), we establish four syntactic and two logical rules to ensure
    the integrity and logic of the command sequence. For example, a syntax rule ensures
    each command contains the correct number of parameters and one of the logic rules
    says that a device cannot appear in multiple symmetry pairs. Due to the page limit,
    we do not list all the rules here. (v) Successful processing of a request that
    either generates correctly formatted code adhering to these rules or accurately
    identifies an illegal request is considered correct handling and included in the
    overall accuracy statistics.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We conduct experiments on the previously mentioned test set of 1,250 cases
    following the outlined criteria, with the results displayed in Table [2](#S3.T2
    "Table 2 ‣ 3.4\. Interactive Layout Editor ‣ 3\. LayoutCopilot Framework ‣ LayoutCopilot:
    An LLM-powered Multi-agent Collaborative Framework for Interactive Analog Layout
    Design"). Firstly, it is evident that instructions significantly enhance accuracy
    across various LLM engines, with average improvements of 6.49% in logical verification,
    4.85% in syntactic verification, and an overall increase of 5.89% in overall accuracy.
    This confirms the effectiveness of our LLM agent settings described in Subsection
    [3.3](#S3.SS3 "3.3\. Agent Configuration and Prompt Design ‣ 3\. LayoutCopilot
    Framework ‣ LayoutCopilot: An LLM-powered Multi-agent Collaborative Framework
    for Interactive Analog Layout Design") and enhances the quality of LayoutCopilot’s
    outputs. Secondly, the accuracy rates for the single-agent configuration are consistently
    lower than those for the multi-agent setup, regardless of whether instructions
    are used across different LLM engines. This demonstrates the effectiveness of
    introducing a multi-agent methodology in this application scenario. Lastly, under
    conditions using Claude-3, multi-agent configuration, and with instructions, the
    overall correctness rate of the sanity check reaches 96.80%. This confirms that
    LayoutCopilot’s comprehensive capabilities are sufficient to meet practical application
    requirements.'
  prefs: []
  type: TYPE_NORMAL
- en: 4.1.2\. Functionality Check
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '![Refer to caption](img/827bcd19fe590bddc51b14238adbd61d.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7\. Functionality check with different LLM engines across instructional
    conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To further assess the functional correctness of the outputs generated by LayoutCopilot
    on the aforementioned test set, we randomly select 25 cases from the 1,250 generated
    results that have passed the sanity check. These are subjected to a manual functionality
    check to verify if they fully implemented the corresponding requests. Like the
    standards used in ChatEDA ([he_chateda_2024,](#bib.bib39) ), we categorize the
    output results into three levels: A, B, and C. Level A corresponds to output functionally
    correct and displays clear analytical reasoning. Level B indicates outputs where
    the functionality has minor flaws, but the analytical reasoning is clear, allowing
    designers to identify and rectify issues easily through interaction with the LLM.
    Level C represents outputs that fail both functionally and conceptually, offering
    little valuable information to help diagnose issues.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We conduct tests using the Concrete Request Processor both with and without
    instructions, corresponding to the multi-agent section in Table 2\. The single-agent
    scenario is omitted due to its significantly lower pass rate in sanity check,
    which do not offer valuable comparative insights. As summarized in Figure  [7](#S4.F7
    "Figure 7 ‣ 4.1.2\. Functionality Check ‣ 4.1\. Concrete Requests: Comprehensive
    Evaluation ‣ 4\. Experimental Results ‣ LayoutCopilot: An LLM-powered Multi-agent
    Collaborative Framework for Interactive Analog Layout Design"), functionality
    check results with instructions significantly outperform those without instructions
    across different LLM engines: on one hand, the proportion of Level A increases
    by 16% to 32%, reaching up to 92% with GPT-4 at the highest; on the other hand,
    Level C, which are not uncommon without instructions, almost disappear under instructed
    conditions, with no more than 8% in GPT-3.5\. This indicates that the use of instructions,
    as discussed in Section 3.3, substantially enhances the usability of LayoutCopilot,
    where the majority of outputs are either correct or can be easily corrected through
    simple interactions. Additionally, the percentage of C level under instructed
    conditions is low regardless of the LLM engine used, thus proving its effectiveness
    across LLM engines. Overall, the functionality validation demonstrates that LayoutCopilot’s
    design significantly enhances the output quality, proving its practical utility.'
  prefs: []
  type: TYPE_NORMAL
- en: '4.2\. Abstract Requests: Case Studies'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this subsection, we illustrate LayoutCopilot’s capabilities in addressing
    abstract requests by optimizing layouts in real-world designs. To verify its versatility,
    we applied LayoutCopilot to two practical circuits, an Operational Transconductance
    Amplifier (OTA) and a Comparator (COMP), depicted respectively in Figure [8](#S4.F8
    "Figure 8 ‣ 4.2\. Abstract Requests: Case Studies ‣ 4\. Experimental Results ‣
    LayoutCopilot: An LLM-powered Multi-agent Collaborative Framework for Interactive
    Analog Layout Design") (a) and (b).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Refer to caption](img/a3807163116c4f6278a8f167a4a2d630.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8\. Interactive LLM-powered layout adjustment on OTA and COMP.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2.1\. Operational Transconductance Amplifier (OTA)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Figure [8](#S4.F8 "Figure 8 ‣ 4.2\. Abstract Requests: Case Studies ‣ 4\. Experimental
    Results ‣ LayoutCopilot: An LLM-powered Multi-agent Collaborative Framework for
    Interactive Analog Layout Design")(a) showcases the layout optimization process
    for an OTA. We employ the MAGICAL ([xu_magical_2019,](#bib.bib18) ; [chen_magical_2021,](#bib.bib20)
    ; [chenMAGICALOpenSource2021,](#bib.bib19) ) to generate the initial placement
    layout ①, without any constraints applied. The initial layout is irrelevant to
    our framework, which focuses solely on modifications rather than origins. From
    layout ①, we engage LayoutCopilot to suggest improvements during the placement
    phase, simulating real-world scenarios faced by designers. LayoutCopilot proposes
    a series of high-level solutions, briefly shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '<svg id="S4.SS2.SSS1.p2.pic1" class="ltx_picture" height="117.5" overflow="visible"
    version="1.1" width="600"><g transform="translate(0,117.5) matrix(1 0 0 -1 0 0)"
    fill="#000000" stroke="#000000" stroke-width="0.4pt"><g fill-opacity="1.0" transform="matrix(1.0
    0.0 0.0 1.0 7.87 83.92)"><foreignobject width="584.25" height="27.67" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible" color="#000000">Designer:'
  prefs: []
  type: TYPE_NORMAL
- en: 'I got an OTA layout, but it has poor performance. How can I improve it?</foreignobject></g>
    <g fill-opacity="1.0" transform="matrix(1.0 0.0 0.0 1.0 7.87 13.78)"><foreignobject
    width="584.25" height="62.27" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible"
    color="#000000">LayoutCopilot: Improving the performance of your OTA layout can
    involve… Here are some potential high-level solutions: 1. Enhance Symmetry with
    symAdd: … 2. Improve Matching with deviceMove and deviceSwap: … 3. Reduce Parasitics
    with wireWidth and wireSpacing: … 4. Prevent Crosstalk with wireSpacing: … 5.
    Improve Routing with netPriority and netTopology: … 6. …'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following this, we select the ‘Enhance Symmetry’ option and provide LayoutCopilot
    with the netlist, asking for concrete implementation steps. LayoutCopilot analyzes
    the netlist and identifies key circuit components that should have symmetry constraints
    applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '<svg id="S4.SS2.SSS1.p4.pic1" class="ltx_picture" height="191.58" overflow="visible"
    version="1.1" width="600"><g transform="translate(0,191.58) matrix(1 0 0 -1 0
    0)" fill="#000000" stroke="#000000" stroke-width="0.4pt"><g fill-opacity="1.0"
    transform="matrix(1.0 0.0 0.0 1.0 7.87 124.79)"><foreignobject width="584.25"
    height="60.88" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible" color="#000000">Designer:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, I prefer to start with the Enhance Symmetry optimization since the current
    symmetry looks terrible. Here is the circuit netlist: [Netlist].'
  prefs: []
  type: TYPE_NORMAL
- en: 'Which devices should I add symmetry to? Please help me with the corresponding
    commands.</foreignobject></g> <g fill-opacity="1.0" transform="matrix(1.0 0.0
    0.0 1.0 7.87 13.78)"><foreignobject width="584.25" height="103.14" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible" color="#000000">LayoutCopilot: Let''s proceed
    with analyzing the netlist to identify critical devices… *Devices for Symmetry:*
    1. Differential Input Pair: M34 (net0130 VIM PTAIL VDD) and M35 (net0132 VIP PTAIL
    VDD) handle the input signals … 2. Output Stage Devices: M71 (VOP VO1M VDD VDD)
    and M70 (VOM VO1P VDD VDD) are used in the output stage … 3. Tail Current Source:
    M1 (NTAIL NBIAS_TAIL GND GND) functions as a tail current source… 4. … *Command
    Sequence:*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: …
  prefs: []
  type: TYPE_NORMAL
- en: After executing these commands, the resultant layout is shown in ②. Observing
    layout ②, we note that large capacitors were not symmetrically constrained, leading
    to a loose and cluttered arrangement. Upon receiving more concrete requests from
    us, LayoutCopilot applies symmetry constraints to all capacitors based on sizing
    results and connectivity, resulting in layout ③. For the sake of simplicity, the
    subsequent replies are not shown specifically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Further, we direct LayoutCopilot to apply symmetry to all possible components,
    including resistors that were previously unconsidered. After identifying suitable
    components in the netlist, LayoutCopilot generates and executes the corresponding
    commands, yielding layout ④. With the placement appearing optimally refined visually,
    we proceed with a basic routing command to produce layout ⑤. Subsequent post-layout
    simulation reveals excessive parasitics, leading us to seek further solutions
    from LayoutCopilot. Among its suggestions—increasing power and ground wire widths,
    adjusting wire spacing to minimize crosstalk, and prioritizing critical nets for
    rerouting—we choose to increase the wire widths of power and ground lines, resulting
    in layout ⑥. With the post-layout results now meeting our specifications as shown
    in Table [4](#S4.T4 "Table 4 ‣ 4.2.1\. Operational Transconductance Amplifier
    (OTA) ‣ 4.2\. Abstract Requests: Case Studies ‣ 4\. Experimental Results ‣ LayoutCopilot:
    An LLM-powered Multi-agent Collaborative Framework for Interactive Analog Layout
    Design"), we terminated the iterative optimization process.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 3\. Placement area statistics.
  prefs: []
  type: TYPE_NORMAL
- en: '| Benchmark | Technology | Placement | Area |'
  prefs: []
  type: TYPE_TB
- en: '| Node | Area | Ratio |'
  prefs: []
  type: TYPE_TB
- en: '| OTA-1 | TSMC40 | $83.4\times 124.2\mu m^{2}$ | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| OTA-2 | $85.0\times 148.9\mu m^{2}$ | 1.22 |'
  prefs: []
  type: TYPE_TB
- en: '| OTA-3 | $80.6\times 94.3\mu m^{2}$ | 0.73 |'
  prefs: []
  type: TYPE_TB
- en: '| OTA-4 | $85.4\times 80.4\mu m^{2}$ | 0.66 |'
  prefs: []
  type: TYPE_TB
- en: '| COMP-1 | TSMC28 | $38.3\times 39.7\mu m^{2}$ | 1.00 |'
  prefs: []
  type: TYPE_TB
- en: '| COMP-2 | $24.0\times 46.9\mu m^{2}$ | 0.74 |'
  prefs: []
  type: TYPE_TB
- en: Table 4\. Comparison between LayoutCopilot and MAGICAL ([xu_magical_2019,](#bib.bib18)
    ; [chen_magical_2021,](#bib.bib20) ; [chenMAGICALOpenSource2021,](#bib.bib19)
    ) without constraints.
  prefs: []
  type: TYPE_NORMAL
- en: '| Benchmark | Schematic | MAGICAL ([xu_magical_2019,](#bib.bib18) ; [chen_magical_2021,](#bib.bib20)
    ; [chenMAGICALOpenSource2021,](#bib.bib19) ) | LayoutCopilot |'
  prefs: []
  type: TYPE_TB
- en: '| w/o Constraints |'
  prefs: []
  type: TYPE_TB
- en: '| OTA | Gain (dB) | 38.63 | -8.75 | 38.26 |'
  prefs: []
  type: TYPE_TB
- en: '| UGB (MHz) | 6.85 | – | 4.42 |'
  prefs: []
  type: TYPE_TB
- en: '| CMRR (dB) | – | 27.3 | 58.7 |'
  prefs: []
  type: TYPE_TB
- en: '| PM (degree) | 70.98 | – | 76.28 |'
  prefs: []
  type: TYPE_TB
- en: '| COMP | CMP_Delay (ns) | 3.3 | 6.3 | 6.7 |'
  prefs: []
  type: TYPE_TB
- en: '| Noise (uV) | 50.3 | 30.9 | 13.9 |'
  prefs: []
  type: TYPE_TB
- en: '| RST_Delay (ps) | 89.8 | 165.8 | 538.7 |'
  prefs: []
  type: TYPE_TB
- en: '| Power (uW) | 19.9 | 32.0 | 31.71 |'
  prefs: []
  type: TYPE_TB
- en: 'We conduct the optimization process under TSMC 40nm technology to verify the
    circuit performance after modifications, utilizing Cadence Virtuoso and Mentor
    Graphics Calibre for post-layout simulation. As we progressed through the interactive
    layout adjustment process with LayoutCopilot, the layout area initially increased
    during the placement phase but eventually reduced to 66% of its original size,
    as depicted in Table [3](#S4.T3 "Table 3 ‣ 4.2.1\. Operational Transconductance
    Amplifier (OTA) ‣ 4.2\. Abstract Requests: Case Studies ‣ 4\. Experimental Results
    ‣ LayoutCopilot: An LLM-powered Multi-agent Collaborative Framework for Interactive
    Analog Layout Design") and Figure [8](#S4.F8 "Figure 8 ‣ 4.2\. Abstract Requests:
    Case Studies ‣ 4\. Experimental Results ‣ LayoutCopilot: An LLM-powered Multi-agent
    Collaborative Framework for Interactive Analog Layout Design"). Given the complex
    relationship between placement & routing in analog circuits and their post-layout
    performance, improvements do not follow a linear progression from ① to ⑤, as described
    earlier for changes in the layout area. For simplicity, we compare the post-layout
    performance results between the initial layouts (without constraints) and the
    final layouts adjusted through interaction with LayoutCopilot, summarized in Table
    [4](#S4.T4 "Table 4 ‣ 4.2.1\. Operational Transconductance Amplifier (OTA) ‣ 4.2\.
    Abstract Requests: Case Studies ‣ 4\. Experimental Results ‣ LayoutCopilot: An
    LLM-powered Multi-agent Collaborative Framework for Interactive Analog Layout
    Design").'
  prefs: []
  type: TYPE_NORMAL
- en: In the initial layouts, due to excessive parasitics, the Gain was negative,
    the unity-gain bandwidth (UGB) and phase margin (PM) are substantially poor, and
    the common-mode rejection ratio (CMRR) is significantly low, showing a large discrepancy
    with the pre-layout schematic results which do not account for parasitic extractions.
    After adjustments made using LayoutCopilot, while there remains a disparity in
    UGB compared to the schematic results, both Gain and PM have closely approached
    the schematic levels, with CMRR showing substantial improvement over the initial
    layout. These results underscore the efficacy of LayoutCopilot in facilitating
    layout optimization through natural language interaction and reducing both the
    learning and coding time for designers, demonstrating its potential to serve as
    a powerful assistant for analog layout designers.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2.2\. Comparator (COMP)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A similar process for the COMP adjustments is employed, now utilizing the TSMC
    28nm technology as depicted in Figure [8](#S4.F8 "Figure 8 ‣ 4.2\. Abstract Requests:
    Case Studies ‣ 4\. Experimental Results ‣ LayoutCopilot: An LLM-powered Multi-agent
    Collaborative Framework for Interactive Analog Layout Design") (b). We optimize
    the symmetry for transistors and capacitors through interactions with LayoutCopilot,
    transforming an initial layout in ① into the improved layout in ②. As summarized
    in the lower half of Table [4](#S4.T4 "Table 4 ‣ 4.2.1\. Operational Transconductance
    Amplifier (OTA) ‣ 4.2\. Abstract Requests: Case Studies ‣ 4\. Experimental Results
    ‣ LayoutCopilot: An LLM-powered Multi-agent Collaborative Framework for Interactive
    Analog Layout Design"), the post-layout simulation result shows that we have significantly
    improved noise performance at the cost of delay and enhanced power efficiency
    compared to the initial layout. This adjustment process for both the OTA and CMP
    exemplifies how LayoutCopilot leverages its comprehensive knowledge base to provide
    actionable recommendations, effectively optimizing the layout of circuits with
    varying topologies and improving their post-simulation performance.'
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this work, we propose a multi-agent collaborative framework powered by LLMs
    for interactive analog layout design. LayoutCopilot can not only convert natural
    language instructions into executable script commands but also interpret high-level
    design intents into actionable suggestions for implementation. Technically, LayoutCopilot
    employs a multi-agent methodology alongside prompt engineering. Validated in both
    TSMC28 and TSMC40, the experimental results demonstrate the robustness and benefits
    of LayoutCopilot. Specifically, LayoutCopilot achieves high accuracy in handling
    concrete requests for layout adjustments and effectively improves layout performance
    in addressing abstract layout optimization requests. We believe this work can
    provide new insights into solving usability issues of interactive EDA tools and
    facilitate the development of automation tools for analog circuits.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: (1) Cadence Design Systems, *Virtuoso Layout Suite*, Cadence Design Systems,
    Inc., San Jose, CA, USA, 2023.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (2) K. Lampaert *et al.*, “A performance-driven placement tool for analog integrated
    circuits,” *IEEE Journal of Solid-State Circuits*, vol. 30, pp. 773–780, 1995.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (3) K. Lampaert *et al.*, “Analog routing for manufacturability,” in *Proceedings
    of Custom Integrated Circuits Conference*, 1996, pp. 175–178.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (4) E. Malavasi *et al.*, “A routing methodology for analog integrated circuits.”
    in *ICCAD*.   Citeseer, 1990, pp. 202–205.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (5) L. Xiao *et al.*, “Practical placement and routing techniques for analog
    circuit designs,” in *2010 IEEE/ACM International Conference on Computer-Aided
    Design (ICCAD)*.   IEEE, 2010, pp. 675–679.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (6) B. Xu *et al.*, “Hierarchical and analytical placement techniques for high-performance
    analog circuits,” in *Proceedings of the 2017 ACM on International Symposium on
    Physical Design*, 2017, pp. 55–62.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (7) B. Basaran *et al.*, “Latchup-aware placement and parasitic-bounded routing
    of custom analog cells,” in *Proceedings of 1993 International Conference on Computer
    Aided Design (ICCAD)*.   IEEE, 1993, pp. 415–421.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (8) H.-C. Ou *et al.*, “Simultaneous analog placement and routing with current
    flow and current density considerations,” in *Proceedings of the 50th Annual Design
    Automation Conference*, 2013, pp. 1–6.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (9) R. Martins *et al.*, “Current-flow and current-density-aware multi-objective
    optimization of analog ic placement,” *Integration*, vol. 55, pp. 295–306, 2016.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (10) B. Xu *et al.*, “Device layer-aware analytical placement for analog circuits,”
    in *Proceedings of the 2019 International Symposium on Physical Design*, 2019,
    pp. 19–26.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (11) K.-H. Ho *et al.*, “Coupling-aware length-ratio-matching routing for capacitor
    arrays in analog integrated circuits,” in *Proceedings of the 50th Annual Design
    Automation Conference*, 2013, pp. 1–6.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (12) Y. Li *et al.*, “Exploring a machine learning approach to performance driven
    analog ic placement,” in *2020 IEEE computer society annual symposium on VLSI
    (ISVLSI)*.   IEEE, 2020, pp. 24–29.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (13) Y. Li *et al.*, “A customized graph neural network model for guiding analog
    ic placement,” in *Proceedings of the 39th International Conference on Computer-Aided
    Design*, 2020, pp. 1–9.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (14) A. Gusmão *et al.*, “Semi-supervised artificial neural networks towards
    analog ic placement recommender,” in *2020 IEEE International Symposium on Circuits
    and Systems (ISCAS)*.   IEEE, 2020, pp. 1–5.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(15) K. Kunal *et al.*, “ALIGN: Open-Source Analog Layout Automation from the
    Ground Up,” in *Proceedings of the 56th Annual Design Automation Conference 2019*.   Las
    Vegas NV USA: ACM, Jun. 2019, pp. 1–4.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(16) T. Dhar *et al.*, “ALIGN: A System for Automating Analog Layout,” *IEEE
    Design & Test*, vol. 38, pp. 8–18, Apr. 2021.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(17) S. S. Sapatnekar, “The ALIGN Automated Analog Layout Engine: Progress,
    Learnings, and Open Issues,” in *Proceedings of the 2023 International Symposium
    on Physical Design*.   Virtual Event USA: ACM, Mar. 2023, pp. 101–102.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(18) B. Xu *et al.*, “MAGICAL: Toward Fully Automated Analog IC Layout Leveraging
    Human and Machine Intelligence: Invited Paper,” in *2019 IEEE/ACM International
    Conference on Computer-Aided Design (ICCAD)*.   Westminster, CO, USA: IEEE, Nov.
    2019, pp. 1–8.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(19) H. Chen *et al.*, “MAGICAL: An Open- Source Fully Automated Analog IC
    Layout System from Netlist to GDSII,” *IEEE Design & Test*, vol. 38, pp. 19–26,
    2021.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(20) H. Chen *et al.*, “MAGICAL 1.0: An Open-Source Fully-Automated AMS Layout
    Synthesis Framework Verified With a 40-nm 1GS/s ${\Delta\Sigma}$ ADC,” in *2021
    IEEE Custom Integrated Circuits Conference (CICC)*.   Austin, TX, USA: IEEE, Apr.
    2021, pp. 1–2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (21) X. Gao *et al.*, “Interactive analog layout editing with instant placement
    legalization,” in *2021 58th ACM/IEEE Design Automation Conference (DAC)*, 2021,
    pp. 1249–1254.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (22) X. Gao *et al.*, “Interactive Analog Layout Editing With Instant Placement
    and Routing Legalization,” *IEEE Transactions on Computer-Aided Design of Integrated
    Circuits and Systems*, vol. 42, pp. 698–711, Mar. 2023.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(23) T. B. Brown *et al.*, “Language models are few-shot learners,” in *Proceedings
    of the 34th International Conference on Neural Information Processing Systems*,
    ser. NIPS ’20.   Red Hook, NY, USA: Curran Associates Inc., 2020.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(24) H. Touvron *et al.*, “Llama: Open and efficient foundation language models,”
    [https://arxiv.org/abs/2302.13971](https://arxiv.org/abs/2302.13971), 2023.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(25) H. Touvron *et al.*, “Llama 2: Open foundation and fine-tuned chat models,”
    [https://arxiv.org/abs/2307.09288](https://arxiv.org/abs/2307.09288), 2023.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (26) OpenAI *et al.*, “GPT-4 Technical Report,” Mar. 2024, arXiv:2303.08774
    [cs].
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(27) Anthropic, “Claude 2,” [https://www.anthropic.com/news/claude-2](https://www.anthropic.com/news/claude-2),
    2023, accessed: 2023-04-10.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(28) Anthropic, “Introducing the next generation of claude,” [https://www.anthropic.com/news/claude-3-family](https://www.anthropic.com/news/claude-3-family),
    2024, accessed: 2023-04-10.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (29) P. Lewis *et al.*, “Retrieval-Augmented Generation for Knowledge-Intensive
    NLP Tasks.”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(30) Q. Wu *et al.*, “AutoGen: Enabling Next-Gen LLM Applications via Multi-Agent
    Conversation,” Oct. 2023, arXiv:2308.08155 [cs].'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(31) S. Rasal, “LLM Harmony: Multi-Agent Communication for Problem Solving,”
    Jan. 2024, arXiv:2401.01312 [cs].'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(32) S. Hong *et al.*, “MetaGPT: Meta Programming for A Multi-Agent Collaborative
    Framework,” Nov. 2023, arXiv:2308.00352 [cs].'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(33) S. Liu *et al.*, “RTLCoder: Outperforming GPT-3.5 in Design RTL Generation
    with Our Open-Source Dataset and Lightweight Solution,” Feb. 2024, arXiv:2312.08617
    [cs].'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(34) S. Thakur *et al.*, “VeriGen: A Large Language Model for Verilog Code
    Generation,” *ACM Transactions on Design Automation of Electronic Systems*, Feb.
    2024, just Accepted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(35) Y. Lu *et al.*, “RTLLM: An Open-Source Benchmark for Design RTL Generation
    with Large Language Model,” Nov. 2023, arXiv:2308.05345 [cs].'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(36) M. Liu *et al.*, “Invited Paper: VerilogEval: Evaluating Large Language
    Models for Verilog Code Generation,” in *2023 IEEE/ACM International Conference
    on Computer Aided Design (ICCAD)*.   San Francisco, CA, USA: IEEE, Oct. 2023,
    pp. 1–8.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(37) Y.-D. Tsai *et al.*, “RTLFixer: Automatically Fixing RTL Syntax Errors
    with Large Language Models,” Feb. 2024, arXiv:2311.16543 [cs].'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(38) M. Liu *et al.*, “ChipNeMo: Domain-Adapted LLMs for Chip Design,” Apr.
    2024, arXiv:2311.00176 [cs].'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(39) Z. He *et al.*, “ChatEDA: A Large Language Model Powered Autonomous Agent
    for EDA,” Mar. 2024, arXiv:2308.10204 [cs].'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(40) Z. Wang *et al.*, “Chatpattern: Layout pattern customization via natural
    language,” [https://arxiv.org/abs/2403.15434](https://arxiv.org/abs/2403.15434),
    2024.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(41) P. Sahoo *et al.*, “A systematic survey of prompt engineering in large
    language models: Techniques and applications,” *arXiv preprint arXiv:2402.07927*,
    2024.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (42) T. Brown *et al.*, “Language models are few-shot learners,” *Advances in
    neural information processing systems*, vol. 33, pp. 1877–1901, 2020.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (43) J. Wei *et al.*, “Chain-of-thought prompting elicits reasoning in large
    language models,” *Advances in neural information processing systems*, vol. 35,
    pp. 24 824–24 837, 2022.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (44) D. Zhou *et al.*, “Least-to-most prompting enables complex reasoning in
    large language models,” *arXiv preprint arXiv:2205.10625*, 2022.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(45) A. Madaan *et al.*, “Self-refine: Iterative refinement with self-feedback,”
    *Advances in Neural Information Processing Systems*, vol. 36, 2024.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (46) P. Lewis *et al.*, “Retrieval-augmented generation for knowledge-intensive
    nlp tasks,” *Advances in Neural Information Processing Systems*, vol. 33, pp.
    9459–9474, 2020.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(47) C. Zhang *et al.*, “Proagent: building proactive cooperative agents with
    large language models,” in *Proceedings of the AAAI Conference on Artificial Intelligence*,
    vol. 38, no. 16, 2024, pp. 17 591–17 599.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(48) Z. Xi *et al.*, “The rise and potential of large language model based
    agents: A survey,” *arXiv preprint arXiv:2309.07864*, 2023.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(49) G. Li *et al.*, “Camel: Communicative agents for” mind” exploration of
    large scale language model society,” 2023.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(50) Y. Talebirad and A. Nadiri, “Multi-agent collaboration: Harnessing the
    power of intelligent llm agents,” *arXiv preprint arXiv:2306.03314*, 2023.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(51) S. Rasal, “Llm harmony: Multi-agent communication for problem solving,”
    *arXiv preprint arXiv:2401.01312*, 2024.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(52) Q. Wu *et al.*, “Autogen: Enabling next-gen llm applications via multi-agent
    conversation framework,” *arXiv preprint arXiv:2308.08155*, 2023.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(53) W. Chen *et al.*, “Agentverse: Facilitating multi-agent collaboration
    and exploring emergent behaviors in agents,” *arXiv preprint arXiv:2308.10848*,
    2023.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(54) S. Hong *et al.*, “Metagpt: Meta programming for multi-agent collaborative
    framework,” *arXiv preprint arXiv:2308.00352*, 2023.</foreignobject></g></g></svg></foreignobject></g></g></svg>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
