- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-09-08 18:39:53'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: 'ReDel: A Toolkit for LLM-Powered Recursive Multi-Agent Systems'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://ar5iv.labs.arxiv.org/html/2408.02248](https://ar5iv.labs.arxiv.org/html/2408.02248)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Andrew Zhu,  Liam Dugan,  Chris Callison-Burch
  prefs: []
  type: TYPE_NORMAL
- en: University of Pennsylvania
  prefs: []
  type: TYPE_NORMAL
- en: '{andrz,ldugan,ccb}@seas.upenn.edu'
  prefs: []
  type: TYPE_NORMAL
- en: Abstract
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Recently, there has been increasing interest in using Large Language Models
    (LLMs) to construct complex multi-agent systems to perform tasks such as compiling
    literature reviews, drafting consumer reports, and planning vacations. Many tools
    and libraries exist for helping create such systems, however none support recursive
    multi-agent systems—where the models themselves flexibly decide when to delegate
    tasks and how to organize their delegation structure. In this work, we introduce
    ReDel: a toolkit for recursive multi-agent systems that supports custom tool-use,
    delegation schemes, event-based logging, and interactive replay in an easy-to-use
    web interface. We show that, using ReDel, we are able to achieve significant performance
    gains on agentic benchmarks and easily identify potential areas of improvements
    through the visualization and debugging tools. Our code, documentation, and PyPI
    package are open-source¹¹1ReDel’s source code is available at [https://github.com/zhudotexe/redel](https://github.com/zhudotexe/redel).
    and free to use under the MIT license.'
  prefs: []
  type: TYPE_NORMAL
- en: 'ReDel: A Toolkit for LLM-Powered Recursive Multi-Agent Systems'
  prefs: []
  type: TYPE_NORMAL
- en: Andrew Zhu,  Liam Dugan,  Chris Callison-Burch University of Pennsylvania {andrz,ldugan,ccb}@seas.upenn.edu
  prefs: []
  type: TYPE_NORMAL
- en: 1 Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A multi-agent system uses multiple large language models (LLMs) together to
    accomplish complex tasks or answer complex questions beyond the capabilities of
    a single LLM. Often, in such scenarios, each LLM is provided with tools Parisi
    et al. ([2022](#bib.bib8)); Schick et al. ([2023](#bib.bib11)) that it can use
    to give it additional capabilities, like searching the internet for real-time
    data or interacting with a web browser. In most cases, these systems are defined
    manually, with a human responsible for defining a static problem-decomposition
    graph and defining an agent to handle each subproblem in the graph (Hong et al.,
    [2024](#bib.bib2); Wu et al., [2023](#bib.bib13); Zhang et al., [2024](#bib.bib15);
    Qiao et al., [2024](#bib.bib10), inter alia).
  prefs: []
  type: TYPE_NORMAL
- en: 'In a recursive multi-agent system, rather than a human defining the layout
    of multiple agents, a single root agent is given a tool to spawn additional agents.
    When faced with a complex task, the root agent can decompose the task into smaller
    subtasks, then delegate those tasks to newly-created sub-agents. Each sub-agent
    can then either complete the task if it is small enough, or recursively decompose
    and delegate the task further²²2This is where the toolkit’s name, ReDel, comes
    from: it’s short for Recursive Delegation. Khot et al. ([2023](#bib.bib3)); Lee
    and Kim ([2023](#bib.bib4)); Prasad et al. ([2024](#bib.bib9)).'
  prefs: []
  type: TYPE_NORMAL
- en: In the current landscape of multi-agent systems, the majority of tooling focuses
    on human-defined static systems, and poorly handles dynamic systems where agents
    are added to a computation graph at runtime. Furthermore, much of this tooling
    is unsuitable for academic purposes Zhu et al. ([2023](#bib.bib17)) or hidden
    behind paywalls and proprietary licenses.
  prefs: []
  type: TYPE_NORMAL
- en: '![Refer to caption](img/8fda3c1fac2dd07d8d498621d0ddfc58.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1: ReDel allows developers to create systems of recursive agents, inspect
    each agent’s state, and visualize a system’s delegation graph (right). Recursive
    agents can be used to solve complex tasks, such as planning a trip to Japan (left).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this paper, we present ReDel, a fully-featured open-source toolkit for recursive
    multi-agent systems. ReDel makes it easy to experiment by providing a modular
    interface for creating tools, different delegation methods, and logs for later
    analysis. This granular logging and a central event-driven system makes it easy
    to listen for signals from anywhere in a system, and every event is automatically
    logged for post-hoc data analysis. ReDel also features a web interface that allows
    users to interact with a configured system directly and view replays of saved
    runs, making it easy for researchers and developers to build, iterate on, and
    analyze recursive multi-agent systems. In Section [4](#S4 "4 Evaluation & Case
    Study ‣ ReDel: A Toolkit for LLM-Powered Recursive Multi-Agent Systems") we use
    ReDel to run recursive multi-agent systems on three diverse agentic benchmarks,
    and in Section [5](#S5 "5 Using ReDel for Error Analysis ‣ ReDel: A Toolkit for
    LLM-Powered Recursive Multi-Agent Systems") we demonstrate how the toolkit can
    be used to explore complex behaviours of these systems.'
  prefs: []
  type: TYPE_NORMAL
- en: 2 Related Work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recursive Multi-Agent Systems.
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Recent work on recursive multi-agent systems has been done by Lee and Kim ([2023](#bib.bib4)),
    Khot et al. ([2023](#bib.bib3)), and Prasad et al. ([2024](#bib.bib9)). These
    works introduce the method of fine-tuning or few-shot prompting LLMs to decompose
    complex tasks and using sub-agents to solve each part (often called recursive
    or hierarchical decomposition). They show that as tasks grow more complex, recursive
    multi-agent systems’ performance pulls away from single-agent systems. ReDel builds
    upon the methods introduced in these works by taking advantage of modern models’
    native tool use capability Schick et al. ([2023](#bib.bib11)) to decompose and
    delegate tasks zero-shot (i.e., without human-written examples in prompt) instead
    of using few-shot prompting or fine-tuning. As a framework, we provide an extensible
    interface to apply these approaches to additional tasks and domains.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-Agent System Frameworks.
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Although there are other LLM-powered multi-agent system frameworks, each have
    various weaknesses that make them poorly suited for recursive systems and/or academic
    purposes. In Table [1](#S2.T1 "Table 1 ‣ Multi-Agent System Frameworks. ‣ 2 Related
    Work ‣ ReDel: A Toolkit for LLM-Powered Recursive Multi-Agent Systems"), we compare
    LangGraph Campos et al. ([2023](#bib.bib1)), LlamaIndex Liu et al. ([2022](#bib.bib5)),
    MetaGPT Hong et al. ([2024](#bib.bib2)), and AutoGPT Significant Gravitas ([2023](#bib.bib12))
    to ReDel, our system. Most are built around static multi-agent systems, with only
    AutoGPT supporting a single level of delegation. Only LangGraph and LlamaIndex
    allow agents to run in parallel asynchronously, whereas MetaGPT and AutoGPT run
    one agent at a time in a synchronous fashion. To log events deep within the system,
    only LlamaIndex provides a rigorous instrumentation suite to developers that allows
    them to emit events at any point while a system is running. Most do not allow
    developers to replay a system run from a log, with only LangGraph allowing replays
    by taking snapshots of each state of the system. Most do not provide a visualization
    interface, with only AutoGPT providing a simple chat-based UI. Unless one subscribes
    to a paid service, LangGraph’s replays cannot be viewed visually, and are instead
    presented as the raw data of each state. Finally, only AutoGPT and MetaGPT are
    fully open-source, with LangGraph and LlamaIndex utilizing proprietary code to
    offer more “premium” features beyond what their open-source libraries offer.'
  prefs: []
  type: TYPE_NORMAL
- en: In comparison, ReDel allows developers to customize their agents’ delegation
    strategies and build multi-level dynamic systems while providing all of these
    features out of the box and remaining fully free and open source. It is the only
    such toolkit to provide first-class support for recursive multi-agent systems
    with best-in-class support for system visualization and modern LLMs with tool
    usage.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |  ReDel  |  LangGraph  |  LlamaIndex  |  MetaGPT  |  AutoGPT  |'
  prefs: []
  type: TYPE_TB
- en: '| Dynamic Systems | \scalerel*![[Uncaptioned image]](img/d7a98974e392fa1f1d87183ec77eada6.png)○
    | \scalerel*![[Uncaptioned image]](img/5fd8de3e58d0f43fd3d197cf83f28567.png)○
    | \scalerel*![[Uncaptioned image]](img/e8151e97b3c3fd226a61416e462a526b.png)○
    | \scalerel*![[Uncaptioned image]](img/cc53aeb4cadaf7acca7db692e45f96a7.png)○
    | \scalerel*![[Uncaptioned image]](img/97b0b1bb70bbd764894306de73ad84c9.png)○
    |'
  prefs: []
  type: TYPE_TB
- en: '| Parallel Agents | \scalerel*![[Uncaptioned image]](img/f4cd8503233e769d48a33c69b7a6d3ef.png)○
    | \scalerel*![[Uncaptioned image]](img/f32eb7efdd6739b53f0484ffcf033362.png)○
    | \scalerel*![[Uncaptioned image]](img/7f44422128e4c3228117aea01319c25f.png)○
    | \scalerel*![[Uncaptioned image]](img/32fa125fb0cec22a7c297e4bb31c00e1.png)○
    | \scalerel*![[Uncaptioned image]](img/946f4b6696e9dface9cf0beea25aa825.png)○
    |'
  prefs: []
  type: TYPE_TB
- en: '| Event-Driven | \scalerel*![[Uncaptioned image]](img/acc687cd06f20e90f57da24299a614ac.png)○
    | \scalerel*![[Uncaptioned image]](img/27422094c284abfe1a8a11ceda969b00.png)○
    | \scalerel*![[Uncaptioned image]](img/70f4a3a35d505475655e6ae5e9f600ec.png)○
    | \scalerel*![[Uncaptioned image]](img/7da62b1a27dc560b9aab3696d525b3d5.png)○
    | \scalerel*![[Uncaptioned image]](img/4b212f93c2a759a793d50a0831665edc.png)○
    |'
  prefs: []
  type: TYPE_TB
- en: '| Run Replay | \scalerel*![[Uncaptioned image]](img/74a0ba00b2bdb6a7a21ee9e8c705adae.png)○
    | \scalerel*![[Uncaptioned image]](img/3611d49bd88367e646a697beed83e6c1.png)○
    | \scalerel*![[Uncaptioned image]](img/7a24733d76c0ddd62812afe43a4eb44d.png)○
    | \scalerel*![[Uncaptioned image]](img/7683103db426eed0e40c7adc657b1122.png)○
    | \scalerel*![[Uncaptioned image]](img/a6e290ffa4e6f5d65b8c8cfa4d6a241e.png)○
    |'
  prefs: []
  type: TYPE_TB
- en: '| Web Interface | \scalerel*![[Uncaptioned image]](img/ce9e2223f8752e76f8aacdabe8d33e3d.png)○
    | \scalerel*![[Uncaptioned image]](img/a48b13d672c5d0e840b4f2ac68e2e0aa.png)○
    | \scalerel*![[Uncaptioned image]](img/2b59f44436c212a175aee9be12fe2c5e.png)○
    | \scalerel*![[Uncaptioned image]](img/9e77cf51ccd2f3b1c9f1a7c56e590623.png)○
    | \scalerel*![[Uncaptioned image]](img/bbd1384b7a62e9c93f7d488628d9fade.png)○
    |'
  prefs: []
  type: TYPE_TB
- en: '| Fully Open Source | \scalerel*![[Uncaptioned image]](img/8f5764a08b9480b6972aece02c7b7198.png)○
    | \scalerel*![[Uncaptioned image]](img/3985d287b586b2d8fa698b506c395221.png)○
    | \scalerel*![[Uncaptioned image]](img/57bda214e76ee18b44a425485033ace1.png)○
    | \scalerel*![[Uncaptioned image]](img/90ae8fc98faf11c83e013964c6e35d6f.png)○
    | \scalerel*![[Uncaptioned image]](img/31abdf3b3462a855142bbc398fd5c463.png)○
    |'
  prefs: []
  type: TYPE_TB
- en: 'Table 1: A feature comparison between ReDel and competing toolkits. ReDel is
    the only fully open-source toolkit that supports dynamic multi-agent systems with
    a rich event-driven base and web interface.'
  prefs: []
  type: TYPE_NORMAL
- en: 3 System Design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ReDel consists of two main parts: a Python package to define recursive delegation
    systems, log events, and run experiments, and a web interface to quickly and interactively
    iterate on defined systems or analyze experiment logs. In the following sections,
    we discuss these components in more detail.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.1 Tool Usage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In ReDel, a “tool” is a group of functions, written in Python, that is exposed
    to an agent. The agent may generate requests to call appropriate functions from
    this tool, which interact with the environment (e.g. searching the Internet).
  prefs: []
  type: TYPE_NORMAL
- en: 'Developers can define tools in any Python file, and a tool’s methods can be
    implemented by any Python code. ReDel is implemented in pure Python, and method
    bodies will not be sent to an agent’s underlying language model, so there is no
    limit to a tool’s implementation complexity or length. Similarly, a tool can use
    functionality defined in any other external library, allowing developers to utilize
    existing application code. An example of a basic tool that provides a function
    for making HTTP requests is in Figure [2](#S3.F2 "Figure 2 ‣ 3.1 Tool Usage ‣
    3 System Design ‣ ReDel: A Toolkit for LLM-Powered Recursive Multi-Agent Systems").'
  prefs: []
  type: TYPE_NORMAL
- en: ReDel comes bundled with a web browsing tool and email tool as examples, and
    we encourage developers to implement domain-specific tools for their own purposes.
  prefs: []
  type: TYPE_NORMAL
- en: '[⬇](data:text/plain;base64,CmNsYXNzIE15SFRUUFRvb2woVG9vbEJhc2UpOgpAYWlfZnVuY3Rpb24oKQpkZWYgZ2V0KHNlbGYsIHVybDogc3RyKToKIiIiR2V0IHRoZSBjb250ZW50cyBvZiBhIHdlYnBhZ2UsCmFuZCByZXR1cm4gdGhlIHJhdyBIVE1MLiIiIgpyZXNwID0gcmVxdWVzdHMuZ2V0KHVybCkKcmV0dXJuIHJlc3AudGV4dAo=)class  MyHTTPTool(ToolBase):@ai_function()def  get(self,  url:  str):"""Get  the  contents  of  a  webpage,and  return  the  raw  HTML."""resp  =  requests.get(url)return  resp.text'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2: An example of a simple ReDel tool that exposes an HTTP GET function
    to any agent equipped with the tool.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.2 Delegation Schemes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A delegation scheme is the strategy used by an agent to send tasks to sub-agents.
    In ReDel, delegation schemes are implemented as a special type of tool that an
    LLM agent (the “parent”) can call with task instructions as an argument. These
    instructions are sent to a new sub-agent (the “child”), which can either complete
    them if they are simple enough, or break them up into smaller parts and recursively
    delegate again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking inspiration from common process management paradigms found in operating
    systems, ReDel comes with two delegation schemes:'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'DelegateOne: Block parent agent’s execution until child agent returns its result.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'DelegateWait: Do not block parent agent’s execution. Instead, provide a separate
    function to retrieve the result of a particular child.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The DelegateOne scheme is well-suited for LLMs with parallel function calling
    as it allows ReDel to let a group of spawned child agents run in parallel, and
    return their results once they all complete.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, the DelegateWait scheme is well-suited for LLMs without parallel
    function calling, as it lets these models spawn multiple agents before deciding
    to wait on any one agent’s result. The drawback is that this runs the risk of
    creating zombie agents if the parent agent never retrieves the results of a particular
    child agent.³³3From our testing, this is a fairly rare occurrence. As far as we
    are aware, ReDel is the first system to implement this type of deferred delegation
    scheme.
  prefs: []
  type: TYPE_NORMAL
- en: 'Developers can also implement their own delegation schemes modularly in a fashion
    similar to defining tools which can enable more complex behaviour like multi-turn
    delegation. We include an example of how to define a delegation scheme in Appendix
    [A](#A1 "Appendix A Custom Delegation Scheme ‣ ReDel: A Toolkit for LLM-Powered
    Recursive Multi-Agent Systems").'
  prefs: []
  type: TYPE_NORMAL
- en: '[⬇](data:text/plain;base64,CiMgZGVmaW5lIGEgY3VzdG9tIGV2ZW50CmNsYXNzIEN1c3RvbVRvb2xFdmVudChCYXNlRXZlbnQpOgp0eXBlOiBMaXRlcmFsWyJjdXN0b21fZXZlbnQiXSA9ICJjdXN0b21fZXZlbnQiCmlkOiBzdHIgIyB0aGUgSUQgb2YgdGhlIGRpc3BhdGNoaW5nIGFnZW50CmZvbzogc3RyICMgc29tZSBvdGhlciBkYXRhClxwYXIjIGRlZmluZSBhIHRvb2wgdGhhdCBkaXNwYXRjaGVzIHRoZSBldmVudApjbGFzcyBNeVRvb2woVG9vbEJhc2UpOgpAYWlfZnVuY3Rpb24oKQpkZWYgbXlfY29vbF9mdW5jdGlvbihzZWxmKToKc2VsZi5hcHAuZGlzcGF0Y2goCkN1c3RvbVRvb2xFdmVudChpZD1zZWxmLmthbmkuaWQsIGZvbz0iYmFyIikKKQojIG90aGVyIGJlaGF2aW91ciBoZXJlIC4uLgo=)#  define  a  custom  eventclass  CustomToolEvent(BaseEvent):type:  Literal["custom_event"]  =  "custom_event"id:  str  #  the  ID  of  the  dispatching  agentfoo:  str  #  some  other  data\par#  define  a  tool  that  dispatches  the  eventclass  MyTool(ToolBase):@ai_function()def  my_cool_function(self):self.app.dispatch(CustomToolEvent(id=self.kani.id,  foo="bar"))#  other  behaviour  here  …'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3: Using ReDel to define a custom event and dispatch it from a tool.
    Custom events can be used to add observability deep within a system and can be
    queried post-hoc for rich data analysis.'
  prefs: []
  type: TYPE_NORMAL
- en: '[⬇](data:text/plain;base64,CnByb21wdF90b2tzID0gQ291bnRlcigpCm91dF90b2tzID0gQ291bnRlcigpClxwYXJmb3IgZXZlbnQgaW4gcmVhZF9qc29ubCgiL3BhdGgvdG8vZXZlbnRzLmpzb25sIik6CmlmIGV2ZW50WyJ0eXBlIl0gPT0gInRva2Vuc191c2VkIjoKZWlkID0gZXZlbnRbImlkIl0KcHJvbXB0X3Rva3NbZWlkXSArPSBldmVudFsicHJvbXB0X3Rva2VucyJdCm91dF90b2tzW2VpZF0gKz0gZXZlbnRbImNvbXBsZXRpb25fdG9rZW5zIl0K)prompt_toks  =  Counter()out_toks  =  Counter()\parfor  event  in  read_jsonl("/path/to/events.jsonl"):if  event["type"]  ==  "tokens_used":eid  =  event["id"]prompt_toks[eid]  +=  event["prompt_tokens"]out_toks[eid]  +=  event["completion_tokens"]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4: Every event in a ReDel system, builtin or custom, is logged to a
    JSONL file. Developers can use data analysis tools of their choice to analyze
    event logs post-hoc. This example demonstrates token counting.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Refer to caption](img/935063ecb309b10232d30f50742ee390.png)'
  prefs: []
  type: TYPE_IMG
- en: (a) The home page of the ReDel web interface.
  prefs: []
  type: TYPE_NORMAL
- en: '![Refer to caption](img/9917c5163bb1cc3739c897741668e19d.png)'
  prefs: []
  type: TYPE_IMG
- en: (b) ReDel’s interactive view allows users to quickly iterate on prompts and
    tool design, and test end-to-end performance.
  prefs: []
  type: TYPE_NORMAL
- en: '![Refer to caption](img/f324172c8b71bfe032ec8eb974e90887.png)'
  prefs: []
  type: TYPE_IMG
- en: (c) The save browser displays logs found in configured directories on the filesystem.
    It allows developers to search for and review previous runs of ReDel systems.
  prefs: []
  type: TYPE_NORMAL
- en: '![Refer to caption](img/b9d9084161fe7971d3a9536a7f59bf98.png)'
  prefs: []
  type: TYPE_IMG
- en: (d) ReDel’s replay view allows developers to replay saved runs of ReDel systems,
    giving events temporal context when analyzing or debugging a system’s performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5: The four views of the ReDel web interface: Home (a), Interactive
    (b), Save Browser (c), and Replay (d).'
  prefs: []
  type: TYPE_NORMAL
- en: 3.3 Events & Logging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'ReDel operates as an event-driven framework, with comprehensive built-in events
    and the ability to define custom events. An event can be defined as anything from
    the creation of a sub-agent to the usage of a particular tool. Whenever ReDel
    catches an event, it logs the event to a JSONL file. This file essentially acts
    as an execution trace for a system run and users can use standard data analysis
    tools to inspect this trace and debug their runs. Figure [4](#S3.F4 "Figure 4
    ‣ 3.2 Delegation Schemes ‣ 3 System Design ‣ ReDel: A Toolkit for LLM-Powered
    Recursive Multi-Agent Systems") shows how a basic Python script can be used to
    count a system’s token usage post-hoc.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, using just the built-in events, ReDel is able to interactively
    play back any response through our web interface for extra visual debugging aid
    (see Section [3.4](#S3.SS4 "3.4 Web Interface ‣ 3 System Design ‣ ReDel: A Toolkit
    for LLM-Powered Recursive Multi-Agent Systems")). In Section [4](#S4 "4 Evaluation
    & Case Study ‣ ReDel: A Toolkit for LLM-Powered Recursive Multi-Agent Systems")
    we show a case study of how this can be used to debug complex query failures.
    We provide the set of built-in default events in Appendix [B](#A2 "Appendix B
    Application Events ‣ ReDel: A Toolkit for LLM-Powered Recursive Multi-Agent Systems")
    and an example of defining a custom event in Figure [3](#S3.F3 "Figure 3 ‣ 3.2
    Delegation Schemes ‣ 3 System Design ‣ ReDel: A Toolkit for LLM-Powered Recursive
    Multi-Agent Systems").'
  prefs: []
  type: TYPE_NORMAL
- en: 3.4 Web Interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The web interface consists of four main views:'
  prefs: []
  type: TYPE_NORMAL
- en: Home Page.
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The home page (Figure [5(a)](#S3.F5.sf1 "In Figure 5 ‣ 3.2 Delegation Schemes
    ‣ 3 System Design ‣ ReDel: A Toolkit for LLM-Powered Recursive Multi-Agent Systems"))
    is the default view when starting the interface for the first time. Users can
    transition to the interactive view by sending a message in the chat bar, or use
    the provided buttons to load a saved replay or read more about ReDel. The sidebar
    lets users switch between interactive sessions they have started, start new sessions,
    or load saved replays.'
  prefs: []
  type: TYPE_NORMAL
- en: Interactive View.
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In the interactive view (Figure [5(b)](#S3.F5.sf2 "In Figure 5 ‣ 3.2 Delegation
    Schemes ‣ 3 System Design ‣ ReDel: A Toolkit for LLM-Powered Recursive Multi-Agent
    Systems")), users can send messages to the root node to interact with the system.
    While the system is running, the top right panel contains the delegation graph:
    a visual representation of each agent in the system, their parent and children,
    and what their current status is: running (green), waiting (yellow), or done (grey).
    Users can further inspect each node in the delegation graph by clicking it, which
    displays its full message history in the bottom right panel. ReDel supports streaming,
    and LLM generations appear in real-time for every agent.'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | FanOutQA | TravelPlanner | WebArena |'
  prefs: []
  type: TYPE_TB
- en: '| System | Loose | Model Judge | CS-Micro | H-Micro | Final | SR | SR (AC)
    | SR (UA) |'
  prefs: []
  type: TYPE_TB
- en: '| ReDel (GPT-4o) | 0.687 | 0.494 | 67.49 | 9.52 | 2.78 | 0.203 | 0.179 | 0.643
    |'
  prefs: []
  type: TYPE_TB
- en: '| ReDel (GPT-3.5-turbo) | 0.300 | 0.087 | 54.58 | 0 | 0 | 0.092 | 0.066 | 0.571
    |'
  prefs: []
  type: TYPE_TB
- en: '| Baseline (GPT-4o) | 0.650 | 0.394 | 50.83 | 18.81 | 0 | 0.162 | 0.128 | 0.786
    |'
  prefs: []
  type: TYPE_TB
- en: '| Baseline (GPT-3.5-turbo) | 0.275 | 0.077 | 48.75 | 0.24 | 0 | 0.085 | 0.058
    | 0.571 |'
  prefs: []
  type: TYPE_TB
- en: '| Published SotA | 0.580 | 0.365 | 61.1 | 15.2 | 1.11 | 0.358 | — | — |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2: Systems’ performance on FanOutQA, TravelPlanner, and WebArena. The
    SotA models are GPT-4o on FanOutQA, GPT-4-turbo/Gemini Pro on TravelPlanner, and
    SteP on WebArena. We see that ReDel outperforms the corresponding single-agent
    baselines across all benchmarks and improves over published SotA in two of three.'
  prefs: []
  type: TYPE_NORMAL
- en: Save Browser.
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The save browser (Figure [5(c)](#S3.F5.sf3 "In Figure 5 ‣ 3.2 Delegation Schemes
    ‣ 3 System Design ‣ ReDel: A Toolkit for LLM-Powered Recursive Multi-Agent Systems"))
    allows users to select replays to view from the list of previous sessions. This
    allows researchers to run experiments in batches while saving their logs, and
    use the interface to review the system’s behaviour at a later date. The save list
    contains all the saves that the ReDel server found in the provided save directories,
    their titles, number of events, and when they were last edited. Users can search
    for keywords in a save’s title and can also sort saves by name, edit time, or
    number of events – the latter allowing users to quickly find outliers at a glance.'
  prefs: []
  type: TYPE_NORMAL
- en: Replay View.
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'With just the built-in default events (see Appendix [B](#A2 "Appendix B Application
    Events ‣ ReDel: A Toolkit for LLM-Powered Recursive Multi-Agent Systems")) ReDel
    saves enough information about a session to fully recreate it in a replay setting.
    Thus, the replay view (Figure [5(d)](#S3.F5.sf4 "In Figure 5 ‣ 3.2 Delegation
    Schemes ‣ 3 System Design ‣ ReDel: A Toolkit for LLM-Powered Recursive Multi-Agent
    Systems")) allows users to step through every event (both built-in and custom)
    dispatched by the system during a particular session and visualize each event’s
    impact on the system.'
  prefs: []
  type: TYPE_NORMAL
- en: The layout of the replay view is virtually identical to the interactive view
    except with the message bar replaced by replay controls. Users can use these controls
    to jump between messages in the root node, selected node in the delegation graph,
    or seek events using the slider. The message history and delegation graph update
    in real time as users seek through the replay.
  prefs: []
  type: TYPE_NORMAL
- en: 4 Evaluation & Case Study
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To evaluate ReDel, we compare its performance to a baseline single-agent system
    and to the published state-of-the-art system on three different benchmarks. We
    include the logs and source code for all experiments in our code release.
  prefs: []
  type: TYPE_NORMAL
- en: 4.1 Experimental Setup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Benchmarks.
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To properly evaluate ReDel we had to choose only datasets that contained sufficiently
    complex tasks. For our benchmarks we therefore chose the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'FanOutQA: Zhu et al. ([2024](#bib.bib18)) Agents must compile data from many
    Wikipedia articles to answer complex information-seeking queries.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'TravelPlanner: Xie et al. ([2024](#bib.bib14)) Agents must create travel plans
    using tools to search flights, restaurant, and attraction databases.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'WebArena: Zhou et al. ([2024](#bib.bib16)) Agents must do complex web tasks
    such as adding products to a shopping cart or commenting on GitLab.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Due to cost constraints we limited our evaluation to roughly 100-300 examples
    from each benchmark (see Appendix [C](#A3 "Appendix C Benchmark Comparison ‣ ReDel:
    A Toolkit for LLM-Powered Recursive Multi-Agent Systems")).'
  prefs: []
  type: TYPE_NORMAL
- en: Models.
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For our main two ReDel systems we used GPT-4o OpenAI ([2024](#bib.bib7)) and
    GPT-3.5-turbo OpenAI ([2022](#bib.bib6)) as the underlying models. In all setups,
    root nodes are not given tool usage capabilities and use the DelegateOne delegation
    scheme.
  prefs: []
  type: TYPE_NORMAL
- en: For the two baseline systems, we used the GPT-4o and GPT-3.5-turbo models as-is.
    All models were given equal access to all tools and no few-shot prompting or fine-tuning
    was performed.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2 Results
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Table [2](#S3.T2 "Table 2 ‣ Interactive View. ‣ 3.4 Web Interface ‣ 3 System
    Design ‣ ReDel: A Toolkit for LLM-Powered Recursive Multi-Agent Systems") we report
    the results of our evaluation. We see that, across all benchmarks, our recursive
    delegation system significantly outperforms its corresponding single-agent baseline.
    We even present an improvement over the previous state of the art systems in both
    FanOutQA and TravelPlanner.'
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we see that the gap between ReDel and the baseline system gets
    larger as the capabilities of the underlying model improves. We believe that this
    bodes well for the application of such techniques to future, more powerful models.
  prefs: []
  type: TYPE_NORMAL
- en: In the few cases where ReDel fails, namely H-Micro on TravelPlanner and SR on
    WebArena, these are attributable to metric failures and unequal comparisons. In
    the TravelPlanner case, on further inspection, we find that recursive systems
    tend to make more commonsense inputs for meals (e.g. “on the flight” or “packed
    lunch”) – which causes the TravelPlanner evaluation script to give a score of
    0 on the Hard Constraint metric. As for the WebArena result, the published SotA
    SteP model uses few-shot, chain-of-thought prompting, whereas our systems all
    use zero-shot prompting.
  prefs: []
  type: TYPE_NORMAL
- en: 5 Using ReDel for Error Analysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For our error analysis, we took the saved log files for each benchmark and
    manually investigated the logs of both the successful runs as well as the failed
    runs through the replay view of the ReDel web interface. Through this investigation
    we observed two common failure cases in recursive multi-agent systems. These cases
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Overcommitment: The agent attempts to complete an overly-complex task itself.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Undercommitment: The agent performs no work and re-delegates the task it was
    given.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We find that overcommitment commonly occurs when an agent performs multiple
    tool calls and fills its context window with retrieved information. This often,
    but not always, leads to failures due to the retrieved information truncating
    the original task from its context. In the ReDel web interface, this manifests
    as an abnormally small delegation graph, often consisting of only two nodes: the
    root node, and a single child which the root delegates to and which subsequently
    overcommits.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast, we find that undercommitment commonly happens when the model incorrectly
    decides that it does not have the necessary tools to solve the problem and instead
    assumes that its future child will possess the required tools to solve the problem.
    In all three benchmarks, this led to failure as agents entered an infinite loop
    of delegation until they reached a configured depth limit or timed out. In the
    web interface, this manifests as a line of nodes in the delegation graph (Figure
    [6](#S5.F6 "Figure 6 ‣ 5 Using ReDel for Error Analysis ‣ ReDel: A Toolkit for
    LLM-Powered Recursive Multi-Agent Systems")).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Table [3](#S5.T3 "Table 3 ‣ 5 Using ReDel for Error Analysis ‣ ReDel: A
    Toolkit for LLM-Powered Recursive Multi-Agent Systems") we tabulate the over-
    and undercommitment rates of ReDel with both GPT-4o and GPT-3.5-turbo for each
    benchmark. We did this heuristically by counting any delegation graph with two
    or fewer agents as overcommitted and any delegation graph with a chain of three
    or more agents with exactly zero or one children as undercommitted. We see that
    as models get stronger they have a stronger propensity to delegate. However, that
    propensity to delegate may lead to undercommitment.'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | FOQA | TP | WA |'
  prefs: []
  type: TYPE_TB
- en: '| System | OC | UC | OC | UC | OC | UC |'
  prefs: []
  type: TYPE_TB
- en: '| RD (4o) | 22.7 | 11.3 | 41.1 | 0.5 | 31.3 | 44.8 |'
  prefs: []
  type: TYPE_TB
- en: '| RD (3.5-t) | 40.8 | 1.1 | 96.7 | 0 | 54.6 | 17.7 |'
  prefs: []
  type: TYPE_TB
- en: 'Table 3: The overcommitment (OC) and undercommitment (UC) rates, in percent,
    of the two recursive multi-agent systems we tested, by benchmark.'
  prefs: []
  type: TYPE_NORMAL
- en: Given the prevalence of these two issues, we hypothesize that recursive multi-agent
    systems may still see further improvements to performance from interventions that
    target these behaviors. For example, one could fine-tune or prompt agents with
    domain-specific instructions that detail when the models should delegate and when
    they should perform tasks on their own.
  prefs: []
  type: TYPE_NORMAL
- en: While implementing such improvements is beyond the scope of this paper, we believe
    that this case study helps to demonstrate the strengths of the ReDel system. Using
    the delegation graph view, it is easy to identify and characterize errors in recursive
    multi-agent systems and we hope that through ReDel more research can be done to
    further refine such systems for maximum utility.
  prefs: []
  type: TYPE_NORMAL
- en: '![Refer to caption](img/b0ec1cfcb064f2c26a22682ed8c35c00.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6: Recursive systems exhibiting undercommitment produce long chains
    of agents (blue boxes), as seen in the ReDel delegation graph.'
  prefs: []
  type: TYPE_NORMAL
- en: 6 Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We present ReDel, a novel toolkit for working with recursive multi-agent systems.
    ReDel allows academic developers to quickly build, iterate on, and run experiments
    involving dynamic multi-agent systems. It offers a modular interface to create
    tools for agents to use, an event framework to instrument experiments for later
    analysis, and a free and open-source web interface to interact with and explore
    developer-defined systems. We use ReDel to demonstrate recursive multi-agent systems’
    performance on three diverse benchmarks, and we include the full logs of these
    runs in our demo release for reproducibility and further exploration⁴⁴4[https://datasets.mechanus.zhu.codes/redel-dist.zip](https://datasets.mechanus.zhu.codes/redel-dist.zip).
    ReDel opens the door for a new paradigm of recursive multi-agent systems, and
    we are excited to see how developers can utilize our system in the future.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Campos et al. (2023) Nuno Campos, William FH, Vadym Barda, and Harrison Chase.
    2023. [LangGraph](https://github.com/langchain-ai/langgraph).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hong et al. (2024) Sirui Hong, Mingchen Zhuge, Jonathan Chen, Xiawu Zheng,
    Yuheng Cheng, Jinlin Wang, Ceyao Zhang, Zili Wang, Steven Ka Shing Yau, Zijuan
    Lin, Liyang Zhou, Chenyu Ran, Lingfeng Xiao, Chenglin Wu, and Jürgen Schmidhuber.
    2024. [MetaGPT: Meta programming for a multi-agent collaborative framework](https://openreview.net/forum?id=VtmBAGCN7o).
    In *The Twelfth International Conference on Learning Representations*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Khot et al. (2023) Tushar Khot, Harsh Trivedi, Matthew Finlayson, Yao Fu, Kyle
    Richardson, Peter Clark, and Ashish Sabharwal. 2023. [Decomposed prompting: A
    modular approach for solving complex tasks](https://openreview.net/forum?id=_nGgzQjzaRy).
    In *The Eleventh International Conference on Learning Representations*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lee and Kim (2023) Soochan Lee and Gunhee Kim. 2023. [Recursion of thought:
    A divide-and-conquer approach to multi-context reasoning with language models](https://doi.org/10.18653/v1/2023.findings-acl.40).
    In *Findings of the Association for Computational Linguistics: ACL 2023*, pages
    623–658, Toronto, Canada. Association for Computational Linguistics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Liu et al. (2022) Jerry Liu, Logan, and Simon Siu. 2022. [LlamaIndex](https://doi.org/10.5281/zenodo.1234).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OpenAI (2022) OpenAI. 2022. [ChatGPT: Optimizing Language Models for Dialogue](https://openai.com/blog/chatgpt).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenAI (2024) OpenAI. 2024. [Hello GPT-4o](https://openai.com/index/hello-gpt-4o/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Parisi et al. (2022) Aaron Parisi, Yao Zhao, and Noah Fiedel. 2022. [TALM:
    tool augmented language models](https://arxiv.org/abs/2205.12255). *Preprint*,
    arXiv:2205.12255.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Prasad et al. (2024) Archiki Prasad, Alexander Koller, Mareike Hartmann, Peter
    Clark, Ashish Sabharwal, Mohit Bansal, and Tushar Khot. 2024. [ADaPT: As-needed
    decomposition and planning with language models](https://doi.org/10.18653/v1/2024.findings-naacl.264).
    In *Findings of the Association for Computational Linguistics: NAACL 2024*, pages
    4226–4252, Mexico City, Mexico. Association for Computational Linguistics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Qiao et al. (2024) Shuofei Qiao, Ningyu Zhang, Runnan Fang, Yujie Luo, Wangchunshu
    Zhou, Yuchen Eleanor Jiang, Chengfei Lv, and Huajun Chen. 2024. [AutoAct: automatic
    agent learning from scratch for qa via self-planning](https://arxiv.org/abs/2401.05268).
    In *Proceedings of the 62nd Annual Meeting of the Association for Computational
    Linguistics (ACL 2024)*, Bangkok, Thailand. Association for Computational Linguistics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Schick et al. (2023) Timo Schick, Jane Dwivedi-Yu, Roberto Dessi, Roberta Raileanu,
    Maria Lomeli, Eric Hambro, Luke Zettlemoyer, Nicola Cancedda, and Thomas Scialom.
    2023. [Toolformer: Language models can teach themselves to use tools](https://openreview.net/forum?id=Yacmpz84TH).
    In *Thirty-seventh Conference on Neural Information Processing Systems*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Significant Gravitas (2023) Significant Gravitas. 2023. [AutoGPT](https://github.com/Significant-Gravitas/AutoGPT).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Wu et al. (2023) Qingyun Wu, Gagan Bansal, Jieyu Zhang, Yiran Wu, Beibin Li,
    Erkang Zhu, Li Jiang, Xiaoyun Zhang, Shaokun Zhang, Jiale Liu, Ahmed Hassan Awadallah,
    Ryen W White, Doug Burger, and Chi Wang. 2023. [AutoGen: enabling next-gen llm
    applications via multi-agent conversation](https://arxiv.org/abs/2308.08155).
    *Preprint*, arXiv:2308.08155.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Xie et al. (2024) Jian Xie, Kai Zhang, Jiangjie Chen, Tinghui Zhu, Renze Lou,
    Yuandong Tian, Yanghua Xiao, and Yu Su. 2024. TravelPlanner: A benchmark for real-world
    planning with language agents. In *Forty-first International Conference on Machine
    Learning*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Zhang et al. (2024) Ceyao Zhang, Kaijie Yang, Siyi Hu, Zihao Wang, Guanghe
    Li, Yihang Sun, Cheng Zhang, Zhaowei Zhang, Anji Liu, Song-Chun Zhu, Xiaojun Chang,
    Junge Zhang, Feng Yin, Yitao Liang, and Yaodong Yang. 2024. [Proagent: Building
    proactive cooperative agents with large language models](https://doi.org/10.1609/aaai.v38i16.29710).
    *Proceedings of the AAAI Conference on Artificial Intelligence*, 38(16):17591–17599.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Zhou et al. (2024) Shuyan Zhou, Frank F. Xu, Hao Zhu, Xuhui Zhou, Robert Lo,
    Abishek Sridhar, Xianyi Cheng, Tianyue Ou, Yonatan Bisk, Daniel Fried, Uri Alon,
    and Graham Neubig. 2024. [Webarena: A realistic web environment for building autonomous
    agents](https://openreview.net/forum?id=oKn9c6ytLx). In *The Twelfth International
    Conference on Learning Representations*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Zhu et al. (2023) Andrew Zhu, Liam Dugan, Alyssa Hwang, and Chris Callison-Burch.
    2023. [Kani: A lightweight and highly hackable framework for building language
    model applications](https://doi.org/10.18653/v1/2023.nlposs-1.8). In *Proceedings
    of the 3rd Workshop for Natural Language Processing Open Source Software (NLP-OSS
    2023)*, pages 65–77, Singapore. Association for Computational Linguistics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Zhu et al. (2024) Andrew Zhu, Alyssa Hwang, Liam Dugan, and Chris Callison-Burch.
    2024. FanOutQA: a multi-hop, multi-document question answering benchmark for large
    language models. In *Proceedings of the 62nd Annual Meeting of the Association
    for Computational Linguistics (ACL 2024)*, Bangkok, Thailand. Association for
    Computational Linguistics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Appendix A Custom Delegation Scheme
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following annotated code snippet shows how to use the ReDel Python package
    to define a delegation scheme – the delegation scheme here is a reproduction of
    the bundled DelegateOne scheme.
  prefs: []
  type: TYPE_NORMAL
- en: '[⬇](data:text/plain;base64,CmNsYXNzIERlbGVnYXRlT25lKERlbGVnYXRpb25CYXNlKToKQGFpX2Z1bmN0aW9uKCkKYXN5bmMgZGVmIGRlbGVnYXRlKGluc3RydWN0aW9uczogc3RyKToKIiIiKEluc2VydCB5b3VyIHByb21wdCBmb3IgdGhlIG1vZGVsIGhlcmUuKSIiIgpccGFyIyByZXF1ZXN0IGEgbmV3IGFnZW50IGluc3RhbmNlIGZyb20gdGhlIHN5c3RlbQpzdWJhZ2VudCA9IGF3YWl0IHNlbGYuY3JlYXRlX2RlbGVnYXRlX2thbmkoaW5zdHJ1Y3Rpb25zKQpccGFyIyBzZXQgdGhlIHN0YXRlIG9mIHRoZSBkZWxlZ2F0b3IgYWdlbnQgdG8gYmUgd2FpdGluZyBvbiB0aGUgZGVsZWdhdGUKd2l0aCBzZWxmLmthbmkucnVuX3N0YXRlKFJ1blN0YXRlLldBSVRJTkcpOgojIGJ1ZmZlciB0aGUgZGVsZWdhdGUncyByZXNwb25zZSBhcyBhIGxpc3Qgb2Ygc3RyaW5ncywgZmlsdGVyaW5nIGZvciBBU1NJU1RBTlQgbWVzc2FnZXMKIyB1c2UgZnVsbF9yb3VuZF9zdHJlYW0gc28gdGhhdCB0aGUgYXBwIGF1dG9tYXRpY2FsbHkgZGlzcGF0Y2hlcyBzdHJlYW1pbmcgZXZlbnRzCnJlc3VsdCA9IFtdCmFzeW5jIGZvciBzdHJlYW0gaW4gc3ViYWdlbnQuZnVsbF9yb3VuZF9zdHJlYW0oaW5zdHJ1Y3Rpb25zKToKbXNnID0gYXdhaXQgc3RyZWFtLm1lc3NhZ2UoKQppZiBtc2cucm9sZSA9PSBDaGF0Um9sZS5BU1NJU1RBTlQgYW5kIG1zZy5jb250ZW50OgpyZXN1bHQuYXBwZW5kKG1zZy5jb250ZW50KQpccGFyIyBjbGVhbiB1cCBhbnkgb2YgdGhlIGRlbGVnYXRlJ3MgZXBoZW1lcmFsIHN0YXRlIGFuZCByZXR1cm4gcmVzdWx0IHRvIGNhbGxlcgphd2FpdCBzdWJhZ2VudC5jbGVhbnVwKCkKcmV0dXJuICJcbiIuam9pbihyZXN1bHQpCg==)class  DelegateOne(DelegationBase):@ai_function()async  def  delegate(instructions:  str):"""(Insert  your  prompt  for  the  model  here.)"""\par#  request  a  new  agent  instance  from  the  systemsubagent  =  await  self.create_delegate_kani(instructions)\par#  set  the  state  of  the  delegator  agent  to  be  waiting  on  the  delegatewith  self.kani.run_state(RunState.WAITING):#  buffer  the  delegate’s  response  as  a  list  of  strings,  filtering  for  ASSISTANT  messages#  use  full_round_stream  so  that  the  app  automatically  dispatches  streaming  eventsresult  =  []async  for  stream  in  subagent.full_round_stream(instructions):msg  =  await  stream.message()if  msg.role  ==  ChatRole.ASSISTANT  and  msg.content:result.append(msg.content)\par#  clean  up  any  of  the  delegate’s  ephemeral  state  and  return  result  to  callerawait  subagent.cleanup()return  "\n".join(result)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7: Using ReDel to define a custom delegation scheme. Delegation tools
    are responsible for the lifecycle of any agent they create.'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix B Application Events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following table lists the built-in default events that will be emitted on
    every run of a ReDel system. Each event has a type key which is used to determine
    what kind of event it is, and a timestamp key.
  prefs: []
  type: TYPE_NORMAL
- en: '| Event Name | Key | Description |'
  prefs: []
  type: TYPE_TB
- en: '| Agent Spawned | kani_spawn | A new agent was spawned. The data attached to
    the event contains the full state of the agent at the time it was spawned, which
    includes its ID, relations to other agents, a description of the LLM powering
    it, the tools it has access to, and any system prompts. |'
  prefs: []
  type: TYPE_TB
- en: '| Agent State Change | kani_state_change | The running state of an agent changed
    (e.g. from RUNNING to WAITING). Contains the ID of the agent and its new state.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Tokens Used | tokens_used | An agent made a call to the language model powering
    it. Contains the ID of the agent, the number of tokens in the prompt it sent,
    and the number of tokens in the completion the LLM returned. |'
  prefs: []
  type: TYPE_TB
- en: '| Agent Message | kani_message | An agent added a new message to its chat history.
    Contains the ID of the agent and the message’s role (e.g. USER or ASSISTANT) and
    content. |'
  prefs: []
  type: TYPE_TB
- en: '| Root Message | root_message | Similar to Agent Message, but only fires for
    messages in the root node. This is fired in addition to an Agent Message event.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Round Complete | round_complete | Fired when the root node completes a full
    chat round (i.e. there are no running children and it has generated a response
    to a user query). |'
  prefs: []
  type: TYPE_TB
- en: 'Table 4: A list of events built-in to the ReDel toolkit.'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C Benchmark Comparison
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, we tabulate each of the benchmarks tested in our experiments.
  prefs: []
  type: TYPE_NORMAL
- en: '| Benchmark | Split | # | Example | Metrics |'
  prefs: []
  type: TYPE_TB
- en: '| FanOutQA Zhu et al. ([2024](#bib.bib18)) | dev | 310 | What is the total
    number of employees in the five largest banks in the world? | Loose: The average
    proportion of reference strings found in the generated answer. Model Judge: Whether
    the reference answer and generated answer are equivalent, judged by GPT-4 (gpt-4-0613).
    |'
  prefs: []
  type: TYPE_TB
- en: '| TravelPlanner Xie et al. ([2024](#bib.bib14)) | val | 180 | Please help me
    plan a trip from St. Petersburg to Rockford spanning 3 days from March 16th to
    March 18th, 2022\. The travel should be planned for a single person with a budget
    of $1,700. | CS-Micro: The proportion of elements in a generated travel plan that
    do not demonstrate a commonsense error (e.g. visiting the same attraction twice).
    H-Micro: The proportion of elements in a generated travel plan that do not violate
    a constraint set by the user or a physical constraint (e.g. budget overruns, non-existent
    restaurants).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Final: The proportion of generated travel plans in which there are no exhibited
    commonsense errors and all constraints are met (i.e., valid travel plans). |'
  prefs: []
  type: TYPE_NORMAL
- en: '| WebArena Zhou et al. ([2024](#bib.bib16)) | test | 271 | Show me the ergonomic
    chair with the best rating | SR: Whether the task is successfully completed or
    correctly marked as unachievable. SR (AC): Whether the task is successfully completed,
    only among tasks that are achievable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'SR (UA): Whether the task is correctly marked as unachievable, only among tasks
    that are unachievable. |'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 5: The dataset split, number of queries, and example queries from each
    of the benchmarks we test.'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix D Additional Design Notes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: D.1 Prompts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we provide the prompts used for each benchmark. We use zero-shot
    prompts for each benchmark, and provide the necessary tools as defined in each
    benchmark’s paper.
  prefs: []
  type: TYPE_NORMAL
- en: '|  | Prompt |'
  prefs: []
  type: TYPE_TB
- en: '| FanOutQA Zhu et al. ([2024](#bib.bib18)) | USER: {question} |'
  prefs: []
  type: TYPE_TB
- en: '| TravelPlanner Xie et al. ([2024](#bib.bib14)) | SYSTEM: Based on the user’s
    query, make the best travel plan for the user and save it. Do not ask follow-up
    questions. USER: {question} |'
  prefs: []
  type: TYPE_TB
- en: '| WebArena Zhou et al. ([2024](#bib.bib16)) | SYSTEM: You are an autonomous
    intelligent agent tasked with navigating a web browser. You will be given web-based
    tasks. These tasks will be accomplished through the use of specific functions
    you can call. Here’s the information you’ll have:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The user’s objective: This is the task you’re trying to complete.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The current web page’s accessibility tree: This is a simplified representation
    of the webpage, providing key information.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The current web page’s URL: This is the page you’re currently navigating.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The open tabs: These are the tabs you have open. Homepage: If you want to visit
    other websites, check out the homepage at http://homepage.com. It has a list of
    websites you can visit. USER: BROWSER STATE: {observation}'
  prefs: []
  type: TYPE_NORMAL
- en: 'URL: {url}'
  prefs: []
  type: TYPE_NORMAL
- en: 'OBJECTIVE: {objective} |'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 6: The prompts used for each benchmark in our evaluation.'
  prefs: []
  type: TYPE_NORMAL
- en: D.2 Identical Delegation Prevention
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, the delegation schemes bundled in ReDel will prevent an agent from
    delegating instructions that are the same as the instructions that were given
    to it. If an agent attempts to do so, the delegation function returns a message
    instructing the agent to either attempt the task itself or break it into smaller
    pieces before delegating again. We implemented this as an early mitigation for
    undercommitment, but some undercommitment still occurs.
  prefs: []
  type: TYPE_NORMAL
