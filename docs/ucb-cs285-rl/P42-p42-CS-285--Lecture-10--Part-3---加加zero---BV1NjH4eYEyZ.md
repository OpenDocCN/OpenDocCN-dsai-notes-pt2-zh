# P42：p42 CS 285： Lecture 10, Part 3 - 加加zero - BV1NjH4eYEyZ

到目前为止，我们已经讨论了规划中的黑箱优化方法和蒙特卡洛树搜索。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_1.png)

这主要适用于种类的离散动作和随机环境，接下来我们将讨论带有导数的轨迹优化。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_3.png)

到目前为止，我们讨论的方法实际上并未使用动力学的导数。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_5.png)

但在许多连续环境中，我们可能实际上知道什么，动力学的导数是，正如我之前提到的一点，在强化学习和动态规划中。



![](img/dca975c57ee7e31d5bbfb3959315f2dd_7.png)

我们喜欢使用s_t和a_t来表示状态和动作，我们喜欢在最优控制中使用r来表示奖励，在动作中，使用xt和ut来表示状态更为常见。



![](img/dca975c57ee7e31d5bbfb3959315f2dd_9.png)

并使用成本代替奖励，因为，这堂课的部分将讨论，轨迹优化和最优控制方法，这些是最常在最优控制社区研究的方法。



![](img/dca975c57ee7e31d5bbfb3959315f2dd_11.png)

实际上，我使用x's来表示，使用，嗯，只是为了让你知道符号与教科书中的可能遇到的符号更相似，不要被这个混淆，"嗯，而且"。



![](img/dca975c57ee7e31d5bbfb3959315f2dd_13.png)

这可能是一种很好的精神锻炼，"尝试在心理上替换ss为x's，as为use"，"并思考这些方法将会是什么样子"，"如果我们在最大化奖励而不是最小化成本"，"但是基本原则完全相同"。



![](img/dca975c57ee7e31d5bbfb3959315f2dd_15.png)

"这就是一个符号和一些字母的差别"，"好的"，"所以，思考我们如何利用导数进行规划"，"让我们回到最初的约束优化问题"。



![](img/dca975c57ee7e31d5bbfb3959315f2dd_17.png)

所以当我们定义了那个嗯，基于模型的规划问题。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_19.png)

我们说嗯，我们想要最小化你的成本，或者最大化你的回报，相对于一系列的动作，但是仅仅那样还不够，你还必须将这个动态融入到这个中。



![](img/dca975c57ee7e31d5bbfb3959315f2dd_21.png)

你可以把它看作是一个约束，所以可以说，嗯，我正在最小化我的行动序列，你想要通过，U大写主语受到约束条件的限制，Xt等于f(xt-1)，逗号ut-1，当你有一个有等式约束的优化问题时。

你总是可以替换约束值为变量，并得到无约束优化，所以这是我在这里写的约束优化问题，与最小化c(x1，ut-1)相同，f的x的一次方加c，逗号u一次，逗号u二次，f的f的x的一次方加c，逗号u一次。

逗号u二次，逗号u三次，以此类推，写出来非常痛苦，但它是一个无约束优化问题。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_23.png)

所以如果我们想使用导数来优化这个，我们可以做一种显而易见的事情，我可以说好吧，我们有一个无约束优化问题。



![](img/dca975c57ee7e31d5bbfb3959315f2dd_25.png)

我们知道如何解决那些，你只需要通过反向传播计算导数并优化。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_27.png)

所以，特别是你需要为了应用链规则而计算的导数，这就是反向传播对于这个最小化问题的作用，你需要知道df dx t。



![](img/dca975c57ee7e31d5bbfb3959315f2dd_29.png)

你需要知道df du t，你需要知道dc dx t和dc d u t，所以你需要了解成本和动态的导数。



![](img/dca975c57ee7e31d5bbfb3959315f2dd_31.png)

相对于它们的输入和，嗯，在实际应用中，嗯，仅仅使用一阶，嗯，对于这种目标，虽然可能进行梯度下降，但往往工作得非常非常差，所以在实际应用中，实际上使用二阶方法解决这种优化问题非常有帮助，结果发现。

如果你想要使用二次方法，本质上是新顿法，这个问题有一个非常方便的结构，为我们提供了一个非常高效的算法。



![](img/dca975c57ee7e31d5bbfb3959315f2dd_33.png)

这个算法不需要计算巨大的海森矩阵。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_35.png)

你可以使用一阶梯度下降，而一阶梯度下降通常会产生非常差的解决方案，因为你是。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_37.png)

你知道，比如总和的最后一个项，因为你在乘以很多，很多，很多雅可比矩阵，除非所有这些雅可比矩阵恰巧具有接近一的特征值。



![](img/dca975c57ee7e31d5bbfb3959315f2dd_39.png)

你将最终得到要么消失要么爆炸的梯度。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_41.png)

但二次方法可以有效地补偿这一点，我想提到的一个侧面，在我开始描述如何二次方法用于轨迹优化工作之前。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_43.png)

是射击方法和插值之间的差异，所以如果你研究轨迹优化。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_45.png)

你可能听到这些术语被广泛提及，射击方法是一种优化动作的方法，所以这个方程描述了射击方法。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_47.png)

如果你想最小化与动作相关的总和。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_49.png)

这是因为这种方法被称为射击方法，因为你可以想象动作，在轨迹的开始部分对后来的结果有重大影响。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_51.png)

所以这就像当你选择第一个动作时，你像是在状态空间中射击，看看结果将落在哪里。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_53.png)

这也描述了为什么射击方法可能如此数值不稳定。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_55.png)

因为第一阶优化算法，因为虽然最后一个动作对你的目标影响最小。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_57.png)

但第一个动作的影响巨大，实质上，你的目标对第一个动作的敏感度非常大。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_59.png)

对于非线性目标，你知道，大多数目标至少是二次的，敏感度转化为非常差的数值条件。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_61.png)

这意味着你有一些非常大的特征值在你的海森矩阵中，和一些非常小的特征值，当你有那些后来的动作的极小特征值，和那些早期的动作的极大特征值时，结果是数值不稳定的，这是第一阶梯度下降方法难以处理的。



![](img/dca975c57ee7e31d5bbfb3959315f2dd_63.png)

共轭点法是一种方法，它优化动作和状态。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_65.png)

附加约束，所以在共轭点法中。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_67.png)

你将回到原始的约束优化问题，这是最小化成本的问题， subject to the constraint that x t equals f of x t minus one。

逗号 u t minus one，但现在你将优化过状态和动作，或者有时你只优化状态，以动作本身由等式约束确定，这有时被称为逆动力学。



![](img/dca975c57ee7e31d5bbfb3959315f2dd_69.png)

但最简单的方式是，如果你优化状态和动作。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_71.png)

那么在这种情况下，你可以想象你的优化变量是沿着这条轨迹的所有点。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_73.png)

你可以移动任何一点，但是，你请，只要约束被遵守现在，对于这种问题，条件通常更好。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_75.png)

因为现在你没有动作对这些影响巨大的。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_77.png)

你知道，直到轨迹的末尾，但它当然取决于你如何选择来强制执行这个约束，所以有各种约束执行方法，一些是松弛的，一些是精确的，一些是线性化的，它们对问题的难度都有不同的影响。

所以我今天不会在讲座中讨论共轭点法太多。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_79.png)

他们通常稍微复杂一些，但他们确实倾向于在数值上更条件良好，并且通常与一阶方法相比，射法算法工作更好。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_81.png)

我将要做的相反，然而，是我要谈论一个非常经典的射法方法，那就是一个二阶方法。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_83.png)

它基于线性二次调节器，所以在介绍线性二次调节器时，我会实际上从一个线性控制问题的特殊案例开始，然后我会告诉你非线性情况下的情况，所以这是我们的优化问题，最小化与动作相关的成本之和。

它实际上对应于那个原始的约束优化问题。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_85.png)

但我只是替换了约束变量，只是为了让你清楚地知道它实际上确实是一个无约束问题，而且约束实际上是帮助我们写的。



![](img/dca975c57ee7e31d5bbfb3959315f2dd_87.png)

线性情况指的是一个设置，其中f(x_t，u_t)是一个线性函数，意味着你可以表达f(x_t，u_t)为某个矩阵乘以向量，也就是说，嗯，你把x_t和u_t堆叠起来，再加上一些常数向量，注意到一点。

f_t是关于确定性动力学的，我们将讨论如何将lqr扩展到随机情况。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_89.png)

通过引入高斯二次，抱歉，线性二次高斯调节器，嗯，稍后我们将讨论lpg设置，但现在这是确定性的，我们假设成本函数是二次的。



![](img/dca975c57ee7e31d5bbfb3959315f2dd_91.png)

成本的二次性很重要，因为如果成本是线性的，那么我们将没有约束的完全线性目标的最小化，这在一般情况下有一个在无穷远处的解。



![](img/dca975c57ee7e31d5bbfb3959315f2dd_93.png)

这不有用，所以我们需要成本至少是二次的，这意味着它可以被写成一半的一次方形式，加上一些矩阵capital c t加上二次项，加上与小c t相关的线性项，所以，同样地，动态是线性的，成本函数是二次的。

线性和二次的，这就是为什么这个被称为线性二次调节器，我们在调节什么，我们在调节我们的轨迹，我们有线性的动态和二次的成本，所以这输入给f，这输入给c，请注意我们允许有不同的uh，在不同的c矩阵和c向量中。

我们有一个F矩阵和一个f向量，每个时间步都有所不同，即使我们有线性动力学，实际上，每个时间步都可能有不同的线性动力学，这在后面将会很重要，当我们试图将这个扩展到非线性情况时。



![](img/dca975c57ee7e31d5bbfb3959315f2dd_95.png)

好的，所以这是我们的问题设置，我们首先要开始的问题是基础情况，我们将仅解决最后一个动作，我们将解决动作，U 作为一个关于最后状态 x_t 的函数。



![](img/dca975c57ee7e31d5bbfb3959315f2dd_97.png)

所以最后状态 x_t 是未知的。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_99.png)

但我们可以做的是，我们可以表达对于这个线性二次系统的最优 ut，作为一个依赖于最后状态 x_t 的表达式，所以这就是我们可以做的，总目标中依赖于最后动作的部分，是在最后时间步的 q 函数对吗。



![](img/dca975c57ee7e31d5bbfb3959315f2dd_101.png)

因为改变最后动作不会影响奖励，或者时间步 capital t 减去一的成本。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_103.png)

所以我们知道，只有主观部分的一部分受到ut的影响，是上次时间步的代价，并且这是由一些常数给出的，加上二次代价函数，所以实际上，选择ut就是选择ut的值，那就是最小化这个表达式。



![](img/dca975c57ee7e31d5bbfb3959315f2dd_105.png)

这个表达式是关于ut的二次函数。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_107.png)

现在它也取决于xt，所以为了解决这个二次方程。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_109.png)

它会帮助我们分解大写字母C和小写字母c，影响你的部分和影响x的部分，所以xt可以写成一个由四个部分组成的矩阵，一个顶部左角cx x和一个底部右角cu u。



![](img/dca975c57ee7e31d5bbfb3959315f2dd_111.png)

然后一个底部，一个底部左角和顶部右角c u x和c x u，我们通常假设成本是对称的，所以嗯，C x u现在是c u x的转置。



![](img/dca975c57ee7e31d5bbfb3959315f2dd_113.png)

目标是二次的，是ut的二次形式，当二次项仅是cuu时，然后所有其他项都会加起来形成一个也依赖于x的线性项。



![](img/dca975c57ee7e31d5bbfb3959315f2dd_115.png)

并且，然后线性项也可以分解为一个依赖于x的项和一个依赖于u的项。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_117.png)

如果我们以u为变量对这个进行求导，我们将得到仅依赖于x的二次形式的组件，所以对它求导为0，我们将得到交叉项，它将是ucuxx和xcxuu。



![](img/dca975c57ee7e31d5bbfb3959315f2dd_119.png)

因为我们假设这些是对称的，嗯，那些的某些导数将只是cuxx，所以实际上它是cuxx的一半，再加上cxcuxx的转置，cxu的转置，但如果你把这些加起来并假设对称，那么一起它就是cuxx。

那么你就有二次项的导数， which is u的转置cxuu乘以一半。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_121.png)

如果你对这个进行导数，一半会消失，你会留下cxu，然后你有来自常数部分的成分，嗯，你把它转置就得到cu。



![](img/dca975c57ee7e31d5bbfb3959315f2dd_123.png)

所以，你取那个的导数就得到cu，所以现在你有一个表达式，其中包含一些关于你的线性项，和一些不依赖于你的项，所以你要做的，是把所有线性项移到这个方程的右边，并乘以cu的逆。



![](img/dca975c57ee7e31d5bbfb3959315f2dd_125.png)

你就得到解，哪个是u等于负cu的逆乘以cuxx加上cu，所以，这是梯度等于零的解，"那就是二次函数的最佳值"，"我们了解二次函数是凸的"，"所以，这就是对于最后行动的最佳选择"。



![](img/dca975c57ee7e31d5bbfb3959315f2dd_127.png)

"问题在于它不是一个固定的值"，实际上，这个值取决于x。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_129.png)

你可以通过将u t写成k t乘以x的形式来简化这个。"再加上一些向量的小k"，当矩阵k的阶数为负数时，cu的逆等于cu乘以x，"并且向量小k是负数除以小cu"。



![](img/dca975c57ee7e31d5bbfb3959315f2dd_131.png)

"所以，这里有很多符号和很多线性代数。"，但是实际的推导过程非常。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_133.png)

非常简单，对于最后一步的动作，你有一个二次目标函数，你通过将导数设置为零来解这个二次函数，然后你得到选择ut的规则，当然，问题是它取决于大写的x和t。



![](img/dca975c57ee7e31d5bbfb3959315f2dd_135.png)

所以为了实际上得到一个ut的数字。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_137.png)

你需要找出大写的x和t应该等于什么，所以这是我们对于最后一步的q函数，因为大写的ut完全由大写的x和t决定，我们可以通过替换来消除它。



![](img/dca975c57ee7e31d5bbfb3959315f2dd_139.png)

所以现在我们可以做的，我们可以为您插入大写字母t的规则。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_141.png)

我们在前一个幻灯片上推导出的，现在我们得到一个不依赖于您的大写字母t的表达式，所以这就是价值函数，这就是您将得到的总成本。



![](img/dca975c57ee7e31d5bbfb3959315f2dd_143.png)

如果您从状态x开始，大写字母t，然后跟随最佳行动，最小化成本的行动，所以这是一个复杂的表达式，但是仍然是二次的。



![](img/dca975c57ee7e31d5bbfb3959315f2dd_145.png)

所以它只有线性和二次项，以及常数项，并且它只依赖于大写的x和t。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_147.png)

如果你想展开这个。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_149.png)

嗯这里是这个的展开，所以我所做的只是，我只是挤压了矩阵代数。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_151.png)

在挤压了矩阵代数之后，我留下了一个混乱的方程。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_153.png)

但是如果你仔细看这个方程，你会注意到这个方程只有关于x的平方项。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_155.png)

或者是关于x的线性项，这意味着我可以将所有平方项收集到一个矩阵中。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_157.png)

我将其称为大写的v和t，我可以将所有线性项收集到一个向量中。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_159.png)

我将其称为小写的v和t，大写的v和小写的v的表达式都很复杂。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_161.png)

但它们都只是矩阵和向量的乘积。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_163.png)

我们在前一个幻灯片中看到的，虽然写起来需要很长时间。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_165.png)

但实际上非常，非常简单来推导，所以长话短说。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_167.png)

我留下了一个关于v的x t的表达式，它只有一个平方项，一半v的转置乘以x的转置乘以v乘以x和一个线性项x的转置乘以小写的v。



![](img/dca975c57ee7e31d5bbfb3959315f2dd_169.png)

所以现在让我们思考前一个时间步，让我们思考时间步t-1，我的目标在这里将是表达ut-1的值，在 terms of xt-1，以及我们之前为xt得出的表达式，ut-1影响xt，反过来它也影响ut。



![](img/dca975c57ee7e31d5bbfb3959315f2dd_171.png)

但我们已经从计算中消除了ut，所以ut-1乘以xt，当然，是由动态决定的，所以xt等于f(xt-1)，ut-1，从线性假设来看，是由矩阵f(t-1)乘以向量xt-1，ut-1，加上常数向量f(t-1)。

所以这意味着在时间步t-1的q值，是我们的时间步t-1的二次成本，加上在f(xt-1)，ut-1处评价的值，现在我要做的是，我将把我的线性方程xt替换为这个f在这里。

并将我的二次表达式替换为价值函数xt，所以，我将做以下事情，我将将我的线性方程xt替换为这个f在这里，并将我的二次表达式替换为价值函数xt，在xt处对这个函数v进行替换。



![](img/dca975c57ee7e31d5bbfb3959315f2dd_173.png)

所以我知道v是某个常数，再加上这个二次形式，这意味着我可以把那个代入那里。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_175.png)

然后我可以表达我的v以x_t-1和u_t-1的形式。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_177.png)

所以我所做的只是，我把我对v的表达式替换了。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_179.png)

并且在xt出现的所有地方，我替换它为我对xt的表达式，我为我的动态获得的表达式，再次是一个需要很长时间才能写出来的表达式。



![](img/dca975c57ee7e31d5bbfb3959315f2dd_181.png)

但实际上非常简单，因为它只包含线性和二次项，所以这里是二次项，这里是线性项，这里的一切都要么是关于x_t-1和u_t-1的二次项，要么是线性项。



![](img/dca975c57ee7e31d5bbfb3959315f2dd_183.png)

所以这就是我剩下的，我有我在时间t-1的q函数，步长t-1，它由成本组成，这是二次的，和价值函数，对于价值函数，我可以将动态的表达式插入进去，然后我会得到一些二次的，这也是二次的。

并且与xt-1和ut-1的线性有关。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_185.png)

然后我可以收集所有二次和线性项。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_187.png)

来自成本和价值函数，我可以表达我的qxt-1，Ut-1为一个二次项和一个线性项，如果你在这个点上迷失在线性代数中，我推荐的是实际上拿出一张纸，"并跟随这些衍生的步骤"，所以再次。

这些衍生物在数学上非常简单，"但他们写作需要很长时间"，所以，如果你不清楚，"只需按照步骤，你就可以对lqr算法有深入的理解。"，"与讲座和推导的写作一起"，确保每一步的推导都完全清楚给你。



![](img/dca975c57ee7e31d5bbfb3959315f2dd_189.png)

"好的"，"所以二次项和线性项的表达式在这里给出"，嗯，他们从成本中获取了二次项和一次项，再加上来自价值函数的这组第二项。



![](img/dca975c57ee7e31d5bbfb3959315f2dd_191.png)

这些形式的实际结构相当优雅。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_193.png)

价值函数的二次项只是动态矩阵在两侧的打击。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_195.png)

一次项有一个来自二次价值函数项的项。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_197.png)

这是动态矩阵的转置乘以小p的f，再加上一次项，它是动态矩阵乘以小v，所以它实际上从直觉上讲是有意义的。



![](img/dca975c57ee7e31d5bbfb3959315f2dd_199.png)

但如果对你来说还不清楚，请跟随在纸上，计算出这个问题。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_201.png)

好的，所以就像以前，我们可以写出这个q函数关于ut-1的导数，注意，它的形式与ut完全相同，只是现在。



![](img/dca975c57ee7e31d5bbfb3959315f2dd_203.png)

而不是有大写字母c和小写字母c。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_205.png)

我们有大写字母q和小写字母q，但形式完全相同，这意味着解决方案完全相同。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_207.png)

所以ut-1的解决方案只是kt-1乘以xt-1，再加上一些向量，小k减去1和大k等于负q u的逆乘以q u乘以x，并且小k等于负q u的逆乘以小q u，好的。



![](img/dca975c57ee7e31d5bbfb3959315f2dd_209.png)

所以这里的推导实际上与ut的情况相当。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_211.png)

主要区别在于我们有不同的矩阵和向量，这是我们通过结合下一个时间步的成本和价值函数得出的。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_213.png)

好的，所以这表明我们可以将我们的解决方案表达为一种递归算法。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_215.png)

我们从非常最后的时间步开始。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_217.png)

从时间步大T一直回溯到时间步1，我们计算一个q矩阵和一个q向量，其中在最后一步时间步长t为资本T，v's只是零，因为v t加一没有资本，并且v t加一没有小写，但其他的我们计算他们，使用这个公式。

我们将我们的q函数表示为二次形式，并且我们选择我们的动作ut作为这个q的论据，这是一次线性表达式，以x为变量，其中资本k是负q u，逆序的q和下划线的k是负序的q的逆序。



![](img/dca975c57ee7e31d5bbfb3959315f2dd_219.png)

然后我们将我们的价值函数表示为这些线索的二次形式。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_221.png)

价值函数的表达式有点复杂，但是，只要插入你表达式，仍然很容易推导。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_223.png)

代替你。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_225.png)

在那个q函数的公式中，然后收集所有二次和线性项，以表达价值函数，作为仅依赖于x的v的函数，有一个二次项和一个线性项再次。



![](img/dca975c57ee7e31d5bbfb3959315f2dd_227.png)

如果你到这个点有点困惑于代数，拿出一张纸，重新推导这个是非常好的建议，你知道，跟随幻灯片的内容，阅读起来相当容易，到达那里只需要花费很长时间来写，对吧，所以现在我们有一个时间步t的值函数。

这意味着我们可以重复并回到时间步t-1，并使用那个值函数来计算前面的q函数。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_229.png)

当我们完成这一切时，我们产生的是资本K和小写k在每个时间步的表达式。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_231.png)

所以通过时间倒流，我们在每个时间步长都将我们的行动表示为一个与状态线性相关的函数。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_233.png)

并且有一个常数项，当我们回到u一时，在时间步长一时，我们有实际知道x一的情况。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_235.png)

x一是我们给出的唯一东西，这意味着我们知道x一，因此，我们可以计算出u一的数值。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_237.png)

一旦我们知道了x一和u一。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_239.png)

然后，我们可以使用已知的过渡动力学来计算x二。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_241.png)

一旦我们知道了x二，然后，我们可以计算u二为资本k二乘以x二加上小写k二。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_243.png)

所以一旦我们知道，一旦我们到达开始。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_245.png)

然后，我们进行前向递归，从t等于一到大写t的每个时间步长，我们可以计算ut为kt乘以xt加上小写kt。



![](img/dca975c57ee7e31d5bbfb3959315f2dd_247.png)

我们可以通过动态计算出xt加一。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_249.png)

然后重复这个过程，所以你可以想象它是一种反向解压的方式，以xt的形式表达它，然后重新打包起来，向前走，在计算xt时插入那些x的值。



![](img/dca975c57ee7e31d5bbfb3959315f2dd_251.png)

然后我们将得到一系列xt的数值，并用它描述这个线性二次系统的最优轨迹。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_253.png)

嗯，记住，这里的q函数实际上就是q函数。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_255.png)

它是从现在到结束的总成本，如果你采取动作ut和状态xt，然后遵循最优策略。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_257.png)

这就是价值函数，从现在到结束的总成本。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_259.png)

如果你从xt开始，然后遵循最优策略。

![](img/dca975c57ee7e31d5bbfb3959315f2dd_261.png)

好的，这就是基本lqr的推导，但是再次强调，如果这里的某个地方对你不清楚，线性代数实际上很简单，只是写起来需要很长时间，如果还不清楚，我强烈建议你回去查看幻灯片并重新推导他们的证明。



![](img/dca975c57ee7e31d5bbfb3959315f2dd_263.png)