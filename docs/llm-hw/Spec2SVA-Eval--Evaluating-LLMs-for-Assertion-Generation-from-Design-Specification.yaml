- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-09-08 18:51:50'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: 'Spec2SVA-Eval: Evaluating LLMs for Assertion Generation from Design Specification'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://ar5iv.labs.arxiv.org/html/2402.00386](https://ar5iv.labs.arxiv.org/html/2402.00386)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Wenji Fang^(1,2) Mengming Li¹ Min Li Zhiyuan Yan² Shang Liu¹ Hongce Zhang^(1,2)^*
    Zhiyao Xie¹^*
  prefs: []
  type: TYPE_NORMAL
- en: 'Spec2Assert: Generating and Evaluating Assertion from Natual Language Specification'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wenji Fang^(1,2) Mengming Li¹ Min Li Zhiyuan Yan² Shang Liu¹ Hongce Zhang^(1,2)^*
    Zhiyao Xie¹^*
  prefs: []
  type: TYPE_NORMAL
- en: 'Spec2Assert: Benchmarking LLM-based Assertion Generation from Natural Language
    Specification'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wenji Fang^(1,2) Mengming Li¹ Min Li Zhiyuan Yan² Shang Liu¹ Hongce Zhang^(1,2)^*
    Zhiyao Xie¹^*
  prefs: []
  type: TYPE_NORMAL
- en: 'AssertLLM: Hardware Verification Assertion Generation and Evaluation from Design
    Specification via Multi-LLMs'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wenji Fang^(1,2) Mengming Li¹ Min Li Zhiyuan Yan² Shang Liu¹ Hongce Zhang^(1,2)^*
    Zhiyao Xie¹^*
  prefs: []
  type: TYPE_NORMAL
- en: 'AssertLLM: Hardware Verification Assertion Generation and Evaluation from Design
    Specification via Multi-LLMs'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wenji Fang^(1,2) Mengming Li¹ Min Li Zhiyuan Yan² Shang Liu¹ Hongce Zhang^(1,2)^*
    Zhiyao Xie¹^*
  prefs: []
  type: TYPE_NORMAL
- en: 'AssertLLM: Generating and Evaluating Hardware Verification Assertions from
    Design Specifications via Multi-LLMs'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wenji Fang^(1,2) Mengming Li¹ Min Li Zhiyuan Yan² Shang Liu¹ Hongce Zhang^(1,2)^*
    Zhiyao Xie¹^*
  prefs: []
  type: TYPE_NORMAL
- en: Abstract
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Assertion-based verification (ABV) is a critical method for ensuring design
    circuits comply with their architectural specifications, which are typically described
    in natural language. This process often requires significant interpretation by
    engineers to convert these specifications into functional verification assertions.
    Existing methods for generating assertions from natural language specifications
    are limited to sentences extracted by engineers, discouraging the practical application.
    In this work, we present AssertLLM, an automatic assertion generation framework
    for complete specification files. AssertLLM breaks down the complex task into
    three phases, incorporating three customized Large Language Models (LLMs) for
    extracting structural specifications, mapping signal definitions, and generating
    assertions. Additionally, we provide an open-source benchmark for assessing assertion
    generation capabilities. Our evaluation of AssertLLM on a full design, encompassing
    23 signals, demonstrates that 89% of the generated assertions are both syntactically
    and functionally accurate.
  prefs: []
  type: TYPE_NORMAL
- en: I Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Hardware functional verification is critical in the VLSI design flow, primarily
    addressing whether an implementation adheres to its specification. For instance,
    the register-transfer level (RTL) design of a processor must comply with the given
    instruction set architecture (ISA) specification. Typically, the architects first
    develop the specifications in a natural language document. Subsequently, RTL designers
    translate these specifications into RTL code, while the verification engineers
    are responsible for checking the functional correctness of the RTL designs according
    to the specifications.
  prefs: []
  type: TYPE_NORMAL
- en: During the verification process, assertion-based verification (ABV) [[1](#bib.bib1)]
    is a widely adopted technique, which utilizes assertions crafted from specifications
    to verify the functional behavior of RTL designs. ABV can be conducted either
    through simulation with testbenches or using formal property verification (FPV)
    techniques. Temporal logic, particularly SystemVerilog Assertions (SVA), is commonly
    employed for specifying these properties. However, a significant challenge in
    ABV is the generation of sufficient, high-quality assertions. Currently, designing
    SVAs manually is a time-consuming and error-prone task, demanding extensive human
    effort.
  prefs: []
  type: TYPE_NORMAL
- en: 'To address this challenge, research has focused on generating SVAs automatically.
    The automatic approaches can be categorized into two types: dynamic mining from
    simulation traces and static analysis of specifications. Dynamic methods [[2](#bib.bib2),
    [3](#bib.bib3), [4](#bib.bib4)] generate assertions by combining simulating test
    traces and static analysis of design constraints. However, a critical limitation
    of dynamic methods is that both the generation and evaluation of assertions are
    on the same RTL design without referring to a golden reference model. This could
    lead to the generation of incorrect SVAs due to flaws in the RTL design, which
    these methods might not detect. On the other hand, existing static methods depend
    either on the pre-defined templates [[5](#bib.bib5), [6](#bib.bib6)] or on machine
    learning (ML) technologies [[7](#bib.bib7), [8](#bib.bib8), [9](#bib.bib9), [10](#bib.bib10),
    [11](#bib.bib11), [12](#bib.bib12), [13](#bib.bib13), [14](#bib.bib14), [15](#bib.bib15),
    [16](#bib.bib16), [17](#bib.bib17)]. The template-based methods also require a
    deep understanding of the design function to fill in the templates. As for the
    ML-based methods, they explore both traditional natural language processing (NLP)
    and emerging Generative AI techniques like Large Language Models (LLMs). We further
    categorize the existing static ML-based methods based on their application in
    different design phases: the RTL and pre-RTL stages.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table [I](#S1.T1 "Table I ‣ I Introduction ‣ Spec2SVA-Eval: Evaluating LLMs
    for Assertion Generation from Design Specification") details these ML-based SVA
    generation methods in both the RTL stage and the pre-RTL stage. During the RTL
    stage, the process typically involves using LLMs to process both human-written
    specification sentences and the RTL design to generate SVAs describing security
    or functional properties [[7](#bib.bib7), [8](#bib.bib8), [9](#bib.bib9)]. However,
    similar to the dynamic methods, inaccuracies in RTL implementations could result
    in flawed SVAs.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Refer to caption](img/a51376d283432468ce1f183a70abcb0c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1: AssertLLM in VLSI design and verification flow. AssertLLM automatically
    generates SVAs from natural language specifications, facilitating functional verification
    for both bug avoidance and bug hunting.'
  prefs: []
  type: TYPE_NORMAL
- en: '| Stage | Works | Generation Method | NL Specification | Evaluation |'
  prefs: []
  type: TYPE_TB
- en: '| Auto Extract. | Source | Full Design | Target |'
  prefs: []
  type: TYPE_TB
- en: '&#124; Open-Source &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; Benchmark &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| RTL | [[7](#bib.bib7)] | LLM-based | ✗ | Sentences from Engineers | ✗ | Security
    | ✗ |'
  prefs: []
  type: TYPE_TB
- en: '| [[8](#bib.bib8), [9](#bib.bib9)] | Function | ^⋆ |'
  prefs: []
  type: TYPE_TB
- en: '| Pre-RTL | [[10](#bib.bib10), [11](#bib.bib11), [12](#bib.bib12), [13](#bib.bib13),
    [14](#bib.bib14), [15](#bib.bib15), [16](#bib.bib16), [17](#bib.bib17)] | NLP-based
    | ✗ |'
  prefs: []
  type: TYPE_TB
- en: '&#124; Sentences &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; from SPEC file &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '&#124; Function (specialized &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; checkers/ artificial cases) &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '| ✗ |'
  prefs: []
  type: TYPE_TB
- en: '| Ours | LLM-based |  | Entire SPEC file |  |'
  prefs: []
  type: TYPE_TB
- en: '&#124; Function &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; (general benchmark) &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ^⋆ Work[[8](#bib.bib8)] only open-source the result on a FIFO, while work[[9](#bib.bib9)]
    only demonstrate based on tiny designs such as FSM and DFF.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Table I: Existing works on generating SVAs from natural language specifications.
    AssertLLM is the first work that can handle full-size specification files and
    generate comprehensive types of SVAs for each architectural signal. We also propose
    the first open-source benchmark for assertion generation and evaluation from natural
    language specifications.'
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the pre-RTL stage, with the natural language specification
    document finalized, RTL designers proceed to implement behavior satisfying this
    golden specification. Numerous studies [[10](#bib.bib10), [11](#bib.bib11), [12](#bib.bib12),
    [13](#bib.bib13), [14](#bib.bib14), [15](#bib.bib15), [16](#bib.bib16), [17](#bib.bib17)]
    have employed NLP techniques to generate SVAs from sentences extracted by humans.
    These works focused on processing sentences identified from a comprehensive document
    of specification. However, specification extraction requires tremendous human
    efforts, and the NLP-based generation process faces challenges in generalizing
    across diverse grammatical variations. Additionally, the evaluation of SVAs generated
    through these methods typically depends on design-specific checkers, such as protocol
    and processor checkers, and is therefore difficult to extend to other design types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we summarize three key challenges that currently hinder the practical
    application of SVA generation from natural language specifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Natural language VLSI specifications are inherently unstructured and are hard
    to be directly used for assertion generation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Even with structured specifications, translating natural language into assertions
    remains a highly complex task, requiring both a deep understanding of the design
    functionality and specialized expertise in SVA.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Currently, there is a lack of a universal evaluation method and benchmarks capable
    of addressing the diverse types of VLSI designs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To tackle the identified challenges in SVA generation, in our work, we propose
    AssertLLM, a novel automatic assertion generation framework incorporating multiple
    specialized LLMs to deal with the decomposed tasks separately. This framework
    is designed to process complete natural language specification files, automatically
    producing SVAs for each architectural signal. This approach significantly benefits
    both design-time bug prevention and verification-time bug detection. The role
    of AssertLLM within the standard VLSI design and verification flow is illustrated
    in Fig. [1](#S1.F1 "Figure 1 ‣ I Introduction ‣ Spec2SVA-Eval: Evaluating LLMs
    for Assertion Generation from Design Specification"). AssertLLM effectively addresses
    the outlined challenges by combining three customized LLMs, each focused on a
    specific task: extracting relevant information from specifications, mapping signal
    definitions, and translating natural language specifications into SVAs. The resulting
    SVAs contain various types, including bit-width, connectivity, and functional
    assertions.'
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, our work provides an open-source benchmark, designed to evaluate
    the quality of the generated SVAs. This benchmark, coupled with a general evaluation
    method, is adaptable to various design types.
  prefs: []
  type: TYPE_NORMAL
- en: To the best of our knowledge, AssertLLM is the first automatic assertion generation
    method that can handle full-size specification files and generate various types
    of SVAs for each architectural signal. It also provides the first open-source
    benchmark for assertion generation and evaluation from design specifications,
    which can deal with different design types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our contributions in this work are summarized below:'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To the best of our knowledge, AssertLLM is the first automatic assertion generation
    method that can handle the complete specification files and generate comprehensive
    types of SVAs for each architectural signal.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We incorporate three customized LLMs, each enhanced with specific techniques
    for the decomposed tasks: extracting structural information from specifications,
    mapping signal declarations, and translating specifications into various SVA types.
    These SVAs support checks for bit-width, connectivity, and function.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We provide the first open-source benchmarks¹¹1It will be open-sourced in https://github.com/hkust-zhiyao/AssertLLM
    for assertion generation and evaluation, which include both golden specification
    documents and golden RTL designs. The generated SVAs are evaluated on the golden
    RTL implementations using model checking tools. Our evaluation method is designed
    to be applicable across a variety of design types.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To demonstrate the effectiveness of AssertLLM, we conducted a comprehensive
    evaluation on a complete design. This resulted in the generation of 56 SVAs for
    23 signals, with 23 for bit-width, 16 for interface, and 17 for function. Impressively,
    89% of these generated SVAs are evaluated to be correct both syntactically and
    functionally.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: II Preliminaries and Problem Formulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: II-A Natural Language Specification
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A well-defined natural language specification mainly contains the following
    six parts: (1) introduction: introduces the concepts and the features of the target
    design. (2) IO ports: provides detailed information on the prime input and prime
    output ports essential for interfacing. (3) registers: describe all the architecture-level
    registers in the design. (4) operation: explains the operational procedures for
    dataflow and control. (5) architecture: the high-level workflow and dataflow of
    the design. (6) usage examples: offers basic usage scenarios and corresponding
    waveform illustrations for the design.'
  prefs: []
  type: TYPE_NORMAL
- en: Specifically for the signals, the specification only defines the necessary architecture-level
    IO ports and registers, while leaving the definition of the internal signals used
    in the detailed RTL implementations for the RTL designers.
  prefs: []
  type: TYPE_NORMAL
- en: II-B LLM for EDA
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Recent advancements in LLMs like ChatGPT [[18](#bib.bib18)] have not only demonstrated
    remarkable capability in content generation but also evolved to assist humans
    in various roles as agents. The application of LLMs in the field of electronic
    design automation (EDA) is an emerging area of exploration. Besides employing
    LLMs for assertion generation [[7](#bib.bib7), [8](#bib.bib8), [9](#bib.bib9)],
    recent studies have employed LLMs for tasks such as RTL code generation [[19](#bib.bib19),
    [20](#bib.bib20), [21](#bib.bib21), [22](#bib.bib22), [23](#bib.bib23), [24](#bib.bib24),
    [25](#bib.bib25), [26](#bib.bib26)] and syntax correction [[27](#bib.bib27)].
    Additionally, LLM-based solutions have been developed to facilitate the interaction
    with EDA tools [[26](#bib.bib26), [28](#bib.bib28)], design architecture for AI
    accelerators [[29](#bib.bib29), [30](#bib.bib30)], fix security bugs [[31](#bib.bib31)],
    generate and review specification documents [[32](#bib.bib32)], etc. These diverse
    applications and research efforts indicate a highly promising future for LLMs
    in enhancing and revolutionizing chip design processes.
  prefs: []
  type: TYPE_NORMAL
- en: II-C Problem Fromulation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We denote a well-defined specification file as $\mathcal{S}$ and generate a
    comprehensive set of assertions $\mathcal{A}$. The assertion generation can be
    expressed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Problem 1 (Assertion Generation from Specification).
  prefs: []
  type: TYPE_NORMAL
- en: '|  | ${\forall}sg_{i}\in\mathcal{S},Gen(S,sg_{i})\rightarrow\ \mathcal{A}(sg_{i})$
    |  | (1) |'
  prefs: []
  type: TYPE_TB
- en: 'Following the generation of assertions, it is crucial to evaluate their quality.
    We denote this evaluation process as $Eval$. The evaluation can be formulated
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: Problem 2 (Generated Assertion Evaluation).
  prefs: []
  type: TYPE_NORMAL
- en: '|  | $1$2 |  | (2) |'
  prefs: []
  type: TYPE_TB
- en: III Methodology
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: III-A Workflow Overview
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![Refer to caption](img/8c7d8fb58a65d34cce4a743a827ed80e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2: AssertLLM generation and evaluation workflow. AssertLLM incorporates
    three customized LLMs, each enhanced with specific techniques for the decomposed
    tasks: extracting structural information from specifications, mapping signal definitions,
    and translating specifications into various SVA types. To evaluate the performance
    of the generation methods, the generated SVAs are further assessed based on the
    golden RTL implementations using model checking tools.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fig. [2](#S3.F2 "Figure 2 ‣ III-A Workflow Overview ‣ III Methodology ‣ Spec2SVA-Eval:
    Evaluating LLMs for Assertion Generation from Design Specification") illustrates
    the SVA generation and evaluation flow for AssertLLM. Our approach to generating
    hardware verification assertions from natural language specifications, particularly
    from comprehensive specification documents, involves the integration of three
    customized LLMs. These LLMs are designed to break down this complex task into
    manageable components, thereby facilitating a comprehensive generation workflow.
    Additionally, we contribute an open-source benchmark and establish evaluation
    methodologies to assess the quality of the generated SVAs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The assertion generation process is decomposed into three primary steps: (1)
    Extraction of relevant information from the original specification necessary for
    SVA generation. (2) Alignment of signal names between the natural language specifications
    and their corresponding declarations in HDL code. (3) Generation of high-quality
    SVAs based on the extracted natural language specifications.'
  prefs: []
  type: TYPE_NORMAL
- en: In the subsequent subsections, we will detail the functionalities of each customized
    LLM of the comprehensive assertion generation flow. Following this, our SVA evaluation
    methodology will be presented.
  prefs: []
  type: TYPE_NORMAL
- en: III-B Specification Information Extraction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first step of our AssertLLM framework is to extract structured information
    from natural language specification documents to enable SVA generation. As we
    discussed in Section [I](#S1 "I Introduction ‣ Spec2SVA-Eval: Evaluating LLMs
    for Assertion Generation from Design Specification"), the first key challenge
    of SVA generation lies in the inherent unstructured nature of the original specifications,
    which contain background information, functional descriptions, microarchitecture
    designs, and various diagrams, including dataflow and waveform, etc. Meanwhile,
    the existence of assertion-relevant information across different sections further
    complicates the direct utilization of the original specifications for SVA generation.'
  prefs: []
  type: TYPE_NORMAL
- en: Facing this challenge, existing methods can only deal with sentence-level specifications.
    Some works [[14](#bib.bib14), [16](#bib.bib16)] utilize ML methods to assess the
    relevance of manually extracted specification sentences to the intended assertions.
    Other studies [[10](#bib.bib10), [11](#bib.bib11), [12](#bib.bib12), [15](#bib.bib15),
    [17](#bib.bib17)] directly use the human-identified or human-written assertion-related
    sentences. This reliance on sentence-level analysis limits the ability of the
    above NLP-based methods to fully automate SVA generation for practical applications
  prefs: []
  type: TYPE_NORMAL
- en: To address the challenge of processing original, unstructured, full-size specification
    documents, we propose a customized LLM, tailored to extract structural and relevant
    information for each defined signal, thereby further facilitating the SVA generation
    process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, in our LLM <svg id="S3.SS2.p4.1.pic1" class="ltx_picture" height="12.15"
    overflow="visible" version="1.1" width="12.15"><g transform="translate(0,12.15)
    matrix(1 0 0 -1 0 0) translate(6.07,0) translate(0,6.07)" fill="#000000" stroke="#000000"
    stroke-width="0.4pt"><g transform="matrix(0.8 0.0 0.0 0.8 -2.77 -3.57)" fill="#000000"
    stroke="#000000"><foreignobject width="6.92" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">1</foreignobject></g></g></svg> SPEC Analyzer,
    we first utilize system instructions to customize the LLM, shown as Fig. [3](#S3.F3
    "Figure 3 ‣ III-B Specification Information Extraction ‣ III Methodology ‣ Spec2SVA-Eval:
    Evaluating LLMs for Assertion Generation from Design Specification"). The model
    takes the full-size specification file as the input, and the multi-modal function
    is employed to analyze the file containing text, table, figures, etc. Then for
    each signal, the LLM is required to extract all the related information of the
    signal. Here, we design a structured template to guide the LLM in extracting all
    essential signal-related information. This template contains three key components:
    the signal’s name, its description, and the interconnection signals. We demonstrate
    the details of each part as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Name: The identifier of the signal in the specification, ensuring clear and
    unambiguous reference.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Description: To facilitate SVA generation, we divide the descriptions into
    four categories, including (1) definitions such as bit-width and signal type.
    (2) functionality which contains all the function-related information of the target
    signal in the entire specification file. (3) interconnection relationship with
    all other signals. (4) additional information that is not included in the above
    three types.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Interconnection Signals: A list of signals that interact or are associated
    with the target signal, which are essential for the assertion generation, and
    will be processed in the next LLM.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that the extracted information is summarized across different sections
    of the original specification, which contains all the information needed for assertion
    generation.
  prefs: []
  type: TYPE_NORMAL
- en: '![Refer to caption](img/7473b6df0fd7d36e42c57fe8179039f7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3: Custom Instructions for LLM <svg id="S3.F3.2.pic1" class="ltx_picture"
    height="12.15" overflow="visible" version="1.1" width="12.15"><g transform="translate(0,12.15)
    matrix(1 0 0 -1 0 0) translate(6.07,0) translate(0,6.07)" fill="#000000" stroke="#000000"
    stroke-width="0.4pt"><g transform="matrix(0.8 0.0 0.0 0.8 -2.77 -3.57)" fill="#000000"
    stroke="#000000"><foreignobject width="6.92" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">1</foreignobject></g></g></svg>SPEC Analyzer'
  prefs: []
  type: TYPE_NORMAL
- en: '![Refer to caption](img/e31b3b87b2554c347de5baa3a0d8ace2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4: Prompt and Response Example of LLM <svg id="S3.F4.2.pic1" class="ltx_picture"
    height="12.15" overflow="visible" version="1.1" width="12.15"><g transform="translate(0,12.15)
    matrix(1 0 0 -1 0 0) translate(6.07,0) translate(0,6.07)" fill="#000000" stroke="#000000"
    stroke-width="0.4pt"><g transform="matrix(0.8 0.0 0.0 0.8 -2.77 -3.57)" fill="#000000"
    stroke="#000000"><foreignobject width="6.92" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">1</foreignobject></g></g></svg>SPEC Analyzer'
  prefs: []
  type: TYPE_NORMAL
- en: III-C Signal Definition Mapping
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After extracting the structural specification information, we also face another
    problem: the target assertion contains internal signals that are not clearly defined
    in the specification file. As we illustrated in Subsection [II-A](#S2.SS1 "II-A
    Natural Language Specification ‣ II Preliminaries and Problem Formulation ‣ Spec2SVA-Eval:
    Evaluating LLMs for Assertion Generation from Design Specification"), the specification
    document typically details only the input/output ports and architecture-level
    registers, while leaving the internal signals used to implement the detailed functions
    in RTL code (e.g., internal wires and registers) undefined.'
  prefs: []
  type: TYPE_NORMAL
- en: To solve this problem, we introduce the second customized LLM <svg id="S3.SS3.p2.1.pic1"
    class="ltx_picture" height="12.15" overflow="visible" version="1.1" width="12.15"><g
    transform="translate(0,12.15) matrix(1 0 0 -1 0 0) translate(6.07,0) translate(0,6.07)"
    fill="#000000" stroke="#000000" stroke-width="0.4pt"><g transform="matrix(0.8
    0.0 0.0 0.8 -2.77 -3.57)" fill="#000000" stroke="#000000"><foreignobject width="6.92"
    height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">2</foreignobject></g></g></svg>
    Signal Mapper to analyze the signal definitions in the initialized HDL code and
    align these signal declarations with the natural language signal names found in
    the specification document.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we also use the custom instructions to guide LLM to specialize
    in the mapping task, shown in Fig. [5](#S3.F5 "Figure 5 ‣ III-C Signal Definition
    Mapping ‣ III Methodology ‣ Spec2SVA-Eval: Evaluating LLMs for Assertion Generation
    from Design Specification"). The model processes both the original specification
    file and the signal definition HDL code as inputs. It employs a code interpreter
    to carefully examine both the declarations and the comments within the HDL code
    snippet. Subsequently, the LLM analyzes the contents of the two files to establish
    a mapping relationship between the specification and the HDL code.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Refer to caption](img/5b7c0ce3043a808bfb3659c25467e61f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5: Custom Instructions for LLM <svg id="S3.F5.2.pic1" class="ltx_picture"
    height="12.15" overflow="visible" version="1.1" width="12.15"><g transform="translate(0,12.15)
    matrix(1 0 0 -1 0 0) translate(6.07,0) translate(0,6.07)" fill="#000000" stroke="#000000"
    stroke-width="0.4pt"><g transform="matrix(0.8 0.0 0.0 0.8 -2.77 -3.57)" fill="#000000"
    stroke="#000000"><foreignobject width="6.92" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">2</foreignobject></g></g></svg>Signal Mapper'
  prefs: []
  type: TYPE_NORMAL
- en: '![Refer to caption](img/63013b43b5268c285944e33df41d7681.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6: Prompt and Response Example of LLM <svg id="S3.F6.2.pic1" class="ltx_picture"
    height="12.15" overflow="visible" version="1.1" width="12.15"><g transform="translate(0,12.15)
    matrix(1 0 0 -1 0 0) translate(6.07,0) translate(0,6.07)" fill="#000000" stroke="#000000"
    stroke-width="0.4pt"><g transform="matrix(0.8 0.0 0.0 0.8 -2.77 -3.57)" fill="#000000"
    stroke="#000000"><foreignobject width="6.92" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">2</foreignobject></g></g></svg>Signal Mapper'
  prefs: []
  type: TYPE_NORMAL
- en: III-D Automatic Assertion Generation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While previous research has delved into SVA generation using either traditional
    NLP techniques at the pre-RTL stage or LLM-based approaches for RTL designs, these
    methods have their limitations. NLP-based techniques demand careful analysis of
    the syntax and semantics of assertion-related sentences, which limit their adaptability
    to variations in sentence structures. LLM-based methods, typically focused on
    the RTL stage, rely on HDL code and accompanying human-written comments or properties,
    but their dependence on the unverified RTL code poses a risk of generating inaccurate
    SVAs that could mislead the verification process.
  prefs: []
  type: TYPE_NORMAL
- en: To address these challenges, our work introduces the LLM <svg id="S3.SS4.p2.1.pic1"
    class="ltx_picture" height="12.15" overflow="visible" version="1.1" width="12.15"><g
    transform="translate(0,12.15) matrix(1 0 0 -1 0 0) translate(6.07,0) translate(0,6.07)"
    fill="#000000" stroke="#000000" stroke-width="0.4pt"><g transform="matrix(0.8
    0.0 0.0 0.8 -2.77 -3.57)" fill="#000000" stroke="#000000"><foreignobject width="6.92"
    height="8.92" transform="matrix(1 0 0 -1 0 16.6)" overflow="visible">3</foreignobject></g></g></svg>
    SVA Generator, dedicated to generating assertions for each signal utilizing the
    previously extracted structural specifications and the established signal relationships.
  prefs: []
  type: TYPE_NORMAL
- en: Considering the precise syntax and writing rules inherent to SVAs and the potential
    for the original LLM failing to generate syntactically correct SVAs, as discussed
    in [[8](#bib.bib8)], we incorporate the Retrieval Augmented Generation (RAG) technique
    to enhance the LLM’s capability for SVA generation. This approach is enriched
    by a knowledge database comprising tutorials and textbooks on SVA and formal property
    verification [[33](#bib.bib33), [34](#bib.bib34), [35](#bib.bib35)], providing
    a robust foundation for the LLM to access and retrieve relevant SVA knowledge
    based on the input query, thereby enhancing the quality of the generated SVAs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides the RAG technique, we also provide custom instructions for SVA Generator,
    shown in Fig. [7](#S3.F7 "Figure 7 ‣ III-D Automatic Assertion Generation ‣ III
    Methodology ‣ Spec2SVA-Eval: Evaluating LLMs for Assertion Generation from Design
    Specification"). After uploading the overall architecture diagram of the design,
    for each signal, the extracted structural specifications and the mapped signal
    relationship from the above two LLMs are provided. Then the LLM is required to
    generate SVAs strictly according to the specification, and as much and high coverage
    as possible. To guide the LLM to generate high-quality SVAs, we define five SVA
    categories as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the RAG technique, we improve the SVA Generator with custom
    instructions, as illustrated in Fig. [7](#S3.F7 "Figure 7 ‣ III-D Automatic Assertion
    Generation ‣ III Methodology ‣ Spec2SVA-Eval: Evaluating LLMs for Assertion Generation
    from Design Specification"). Upon inputting the overall architecture diagram of
    the design, the LLM is provided with the structured specifications and mapped
    signal relationships from the previous LLMs for each signal. Then the LLM is required
    to generate SVAs that adhere strictly to the specifications, aiming for maximal
    quantity and quality. To facilitate the generation of high-quality SVAs, we categorize
    SVAs into three distinct groups, guiding the LLM toward producing comprehensive
    and accurate assertions for effective verification.'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Width: Check if the signal bit width is satisfied with the specification.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Connectivity: Check if the signal can be correctly exercised and also the value
    propagation among all connected signals.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Function: Check if the function defined in the specification is implemented
    as expected.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Based on these well-designed SVA types, the customized LLM can generate numerous
    SVAs for each signal. Fig. [8](#S3.F8 "Figure 8 ‣ III-D Automatic Assertion Generation
    ‣ III Methodology ‣ Spec2SVA-Eval: Evaluating LLMs for Assertion Generation from
    Design Specification") demonstrates an example of generating SVAs for a signal.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Refer to caption](img/c69f77d83e663c35d8c01db44e0afd09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7: Custom Instructions for LLM <svg id="S3.F7.2.pic1" class="ltx_picture"
    height="12.15" overflow="visible" version="1.1" width="12.15"><g transform="translate(0,12.15)
    matrix(1 0 0 -1 0 0) translate(6.07,0) translate(0,6.07)" fill="#000000" stroke="#000000"
    stroke-width="0.4pt"><g transform="matrix(0.8 0.0 0.0 0.8 -2.77 -3.57)" fill="#000000"
    stroke="#000000"><foreignobject width="6.92" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">3</foreignobject></g></g></svg>SVA Generator'
  prefs: []
  type: TYPE_NORMAL
- en: '![Refer to caption](img/006296b3ae0e56ed4197fb2a924d15d9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8: Prompt and Response Example of LLM <svg id="S3.F8.2.pic1" class="ltx_picture"
    height="12.15" overflow="visible" version="1.1" width="12.15"><g transform="translate(0,12.15)
    matrix(1 0 0 -1 0 0) translate(6.07,0) translate(0,6.07)" fill="#000000" stroke="#000000"
    stroke-width="0.4pt"><g transform="matrix(0.8 0.0 0.0 0.8 -2.77 -3.57)" fill="#000000"
    stroke="#000000"><foreignobject width="6.92" height="8.92" transform="matrix(1
    0 0 -1 0 16.6)" overflow="visible">3</foreignobject></g></g></svg>SVA Generator'
  prefs: []
  type: TYPE_NORMAL
- en: III-E Generated Assertion Evaluation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After the SVAs are generated, evaluating their effectiveness is crucial. While
    some previous studies such as [[12](#bib.bib12), [14](#bib.bib14)] suggest using
    specific property checkers for this purpose, such an approach is limited to particular
    design types like protocols and processors and lacks generalizability to all VLSI
    designs. Other methods like [[8](#bib.bib8)] involve manual verification by engineers
    using EDA tools, which is vulnerable to human error.
  prefs: []
  type: TYPE_NORMAL
- en: In our approach, we propose leveraging the golden RTL implementations to assess
    the quality of the generated SVAs. Our generation method is solely based on the
    specification file, and the bug-free golden RTL designs serve as a robust benchmark
    to evaluate our generation technique’s efficacy.
  prefs: []
  type: TYPE_NORMAL
- en: 'For evaluation, we utilize the formal property verification (FPV) method. The
    generated SVAs and the golden RTL designs are inputted into a model checker tool.
    After executing FPV, we employ the following two metrics to evaluate the quality
    of SVAs for each target signal:'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Syntax: Check if the generated SVAs have syntax errors.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'FPV Pass/Fail: Given the RTL designs are bug-free, an SVA that passes the FPV
    check is considered correct, and conversely, a failure indicates an incorrect
    SVA.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: III-F Proposed Benchmark
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Recognizing the absence of open-source benchmarks for evaluating LLMs in the
    generation of SVAs from natural language specifications, we introduce a comprehensive
    benchmark suite tailored for this purpose. Our benchmark consists of 20 open-source
    designs, covering a diverse array of applications including microprocessors, system-on-chip
    architectures, communication protocols, arithmetic units, and cryptographic modules.
    For each design within the benchmark, the benchmark provides the following components
    across three distinct files:'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Specification: This file contains the complete natural language specification
    for the design, offering a detailed description of the system’s intended architecture
    and functionality.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Signal Definition: Presented in HDL code format, this file outlines the signal
    declarations essential for the generation of SVAs. It includes definitions for
    both input/output ports and internal signals, providing the foundation for assertion
    generation.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Golden RTL Implementation: This file comprises the RTL design implementations
    that are strictly implemented according to the specification. The designs are
    verified to ensure it is free from bugs, serving as a reliable standard for evaluating
    the accuracy and effectiveness of generated SVAs.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: IV Experimental Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: IV-A Experimental Setup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our study, the original specification documents are provided in PDF format,
    including a variety of multi-modal content including text, tables, and figures.
    The signal definition files and the golden RTL designs are formatted in Verilog.
    To assess the quality of the generated SVAs, we utilize Cadence JasperGold^®,
    one of the leading commercial model checking tools. This evaluation leverages
    the FPV app in JasperGold to ensure a thorough analysis.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our experimental setup involves the evaluation of three types of LLMs using
    our developed generation and evaluation methodology:'
  prefs: []
  type: TYPE_NORMAL
- en: '1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'GPT-3.5: This model is the freely available commercial version, GPT-3.5 Turbo,
    which supports a context window of up to 16K tokens.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'GPT-4: The state-of-the-art commercial solution, GPT-4 Turbo, offers a 128K
    token context window and multi-modal capabilities, making it adept at handling
    the diverse content found in specification documents.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'AssertLLM: Cutomized GPT-4 Turbo by incorporating specialized techniques such
    as RAG and custom instructions, tailoring the models specialized to the SVA generation
    task.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In our experimental evaluation, we focus on the quality of the SVAs generated
    for each signal across the designs. Note that all SVAs are produced from a single
    query to the LLMs without any subsequent iterative modifications. The SVA containing
    unmapped signals is considered an unsuccessful attempt at SVA generation. These
    SVAs are identified and excluded by human engineers prior to the evaluation process.
  prefs: []
  type: TYPE_NORMAL
- en: '|  | AssertLLM | GPT-4 | GPT-3.5 |'
  prefs: []
  type: TYPE_TB
- en: '| Signal | Assertion Evaluation (#. Generated/#. Syntax Correct/#. FPV Pass)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Type | Name | Width | Connect. | Function | Signal Total | Function |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | Clock | wb_clk_i | 1/1/1 | / | 1/1/1 | 3/1/0 |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | wb_rst_i | 1/1/1 |  | 1/1/1 | 3/1/0 |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | Reset | arst_i | 1/1/1 | / | 1/1/1 | 3/1/0 |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | wb_stb_i | 1/1/1 | 2/2/1 |  | 3/3/2 | 3/1/0 |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | wb_ack_o | 1/1/1 | 1/1/0 |  | 2/2/1 | 3/1/0 |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | Control | wb_inta_o | 1/1/1 | 1/1/0 | / | 2/2/1 | 3/1/0 |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | wb_adr_i | 1/1/1 |  |  | 1/1/1 | 3/1/0 |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | wb_dat_i | 1/1/1 |  |  | 1/1/1 | 3/1/0 |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | wb_cyc_i | 1/1/1 |  |  | 1/1/1 | 3/1/0 |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | wb_dat_o | 1/1/1 |  |  | 1/1/1 | 3/1/0 |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | wb_we_i | 1/1/1 |  |  | 1/1/1 | 3/1/0 |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | scl_pad_i | 1/1/1 |  |  | 1/1/1 | 3/1/0 |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | scl_pad_o | 1/1/1 |  |  | 1/1/1 | 3/1/0 |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | sda_pad_i | 1/1/1 |  |  | 1/1/1 | 3/1/0 |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | sda_pad_o | 1/1/1 |  |  | 1/1/1 | 3/1/0 |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | scl_pad_oe | 1/1/1 |  |  | 1/1/1 | 3/1/0 |  |'
  prefs: []
  type: TYPE_TB
- en: '| IO Port | Data | sda_pad_oe | 1/1/1 | / | / | 1/1/1 | 3/1/0 |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | ctr | 1/1/1 | 4/4/4 | 5/5/5 | 10/10/10 | 3/1/1 |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | Control | sr | 1/1/1 | 6/6/5 | 8/8/8 | 15/15/14 | 3/1/1 |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | prer | 1/1/1 | / | 3/3/1 | 4/4/2 | 4/1/1 |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | txr | 1/1/1 | / | 1/1/1 | 2/2/2 | 3/1/1 |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | rxr | 1/1/1 | / | 1/1/1 | 2/2/2 | 3/1/1 |  |'
  prefs: []
  type: TYPE_TB
- en: '| Register | Data | cr | 1/1/1 | / | 1/1/1 | 2/2/2 | 4/1/1 |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | 23/23/23 | 16/16/12 | 17/17/15 | 56/56/50 | 71/23/6 |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | Design Total | 100%/100% | 100%/75% | 100%/88% | 100%/89% | 32%/8% | Can
    not handle the original specification files. |'
  prefs: []
  type: TYPE_TB
- en: 'Table II: Evaluation of the generated SVAs for design ”I2C”. AssertLLM generates
    56 SVAs for a total of 23 signals, with 23 for bit-width, 16 for connectivity,
    and 17 for function. 89% of these generated SVAs are evaluated to be correct both
    syntactically and functionally.'
  prefs: []
  type: TYPE_NORMAL
- en: IV-B Evaluation Metrics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To conduct a thorough evaluation of the generated SystemVerilog SVAs, we propose
    a set of metrics that align with our evaluation methodology. This approach ensures
    a detailed assessment of the SVAs’ quality on both a per-signal and per-design
    basis.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each assertion type of an individual signal, our evaluation includes the
    following metrics: (1) number of generated SVAs. (2) number of syntax-correct
    SVAs. (3) number of FPV-passed SVAs.'
  prefs: []
  type: TYPE_NORMAL
- en: Once the evaluation for each signal is complete, we aggregate the statistics
    of the generated SVAs for each design and then calculate the proportion of these
    SVAs that are syntactically correct and passed the FPV checks, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: IV-C Assertion Generation Quality
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To illustrate the efficacy of AssertLLM, we apply it to a comprehensive design
    case: the ”I2C” protocol. The I2C specification describes the architecture of
    a serial communication bus that provides a simple and efficient method of data
    exchange between devices. The complete specification document for the ”I2C” design
    is structured into six main sections, similar to those illustrated in Subsection [II-A](#S2.SS1
    "II-A Natural Language Specification ‣ II Preliminaries and Problem Formulation
    ‣ Spec2SVA-Eval: Evaluating LLMs for Assertion Generation from Design Specification").
    Note that for each signal, the specification is unstructured and mainly across
    the IO ports, registers, and operation sections.'
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we provide the signal definition file containing not only the
    IO ports and architectural registers but also all the internal wires and registers
    defined for detailed RTL implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To facilitate the generation of SVAs, the AssertLLM framework processes specification
    and signal definition files using two specialized LLMs: SPEC Analyzer for extracting
    structured specifications for each signal and Signal Mapper for mapping signal
    relationships. Then the SVA Generator is utilized to automatically generate three
    types of SVAs based on the processed information from the first two LLMs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The specification for the ”I2C” design defines 23 signals, comprising 17 IO
    ports and 6 architecture-level registers. For the IO ports, we categorize them
    into 4 functional types: clock, reset, control signal, and data signal. The architecture-level
    registers are similarly categorized, based on their functionality, into control
    and data types.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The evaluation of SVAs generated by our AsserLLM is demonstrated in Table [II](#S4.T2
    "Table II ‣ IV-A Experimental Setup ‣ IV Experimental Results ‣ Spec2SVA-Eval:
    Evaluating LLMs for Assertion Generation from Design Specification"). For each
    signal, we first verify each type of the generated SVAs separately. Then we summarize
    all the SVAs to provide a design-level inspection. We have multiple interesting
    observations in Table [II](#S4.T2 "Table II ‣ IV-A Experimental Setup ‣ IV Experimental
    Results ‣ Spec2SVA-Eval: Evaluating LLMs for Assertion Generation from Design
    Specification") as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AssertLLM demonstrates excellent proficiency in generating SVAs for bit-width
    checking. Although bit-width checking is relatively straightforward, it is crucial
    for early design stages to avoid potential bugs that cannot be checked through
    a syntax checker.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the connectivity SVAs, since clear guidelines are provided only for control
    signals within the architecture-level specification documents, AssertLLM can only
    generate connectivity SVAs for them. The connectivity of data signals often depend
    on specific internal signals defined in the RTL implementation, which are not
    detailed in the specification document.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the function SVAs, the specification provides explicit details only for
    registers. The descriptions of IO ports are primarily focused on data transformation
    functions, without extensive functional details, which results in the lack of
    related SVAs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the quantity of generated SVAs, AssertLLM produced a total of 56 SVAs, with
    23 dedicated to width checking, 16 to connectivity checking, and 17 to function
    checking.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regarding the quality of generated SVAs, all SVAs related to bit-width checking
    performed correctly. However, a minor portion of connectivity and function SVAs
    contained errors, attributed mainly to misinterpretations of the specification
    or LLM-generated hallucinations. Overall, AssertLLM achieved a correct accuracy
    rate of 89% for the entire I2C design.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: IV-D Ablation Study
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to assessing AssertLLM’s performance, we conducted an ablation study
    to compare the SVA generation capabilities of the original GPT-4 and GPT-3.5 models
    without the additional techniques. This study provides insights into the effectiveness
    of enhancements incorporated in AssertLLM.
  prefs: []
  type: TYPE_NORMAL
- en: 'The evaluation results for the two commercial solutions are demonstrated in
    Table [II](#S4.T2 "Table II ‣ IV-A Experimental Setup ‣ IV Experimental Results
    ‣ Spec2SVA-Eval: Evaluating LLMs for Assertion Generation from Design Specification").
    For GPT-3.5, since the lack of multi-modal processing capabilities, it is unable
    to directly generate SVAs from the original, multi-modal specification files.'
  prefs: []
  type: TYPE_NORMAL
- en: When utilizing the original GPT-4, the unstructured specification file and signal
    definitions are provided, with prompts designed to guide SVA generation to the
    best of the model’s ability. The generation results indicate that the absence
    of a mechanism to extract structured specifications for each signal significantly
    hampers GPT-4’s ability to compile all useful information for SVA generation,
    resulting in a maximum of only 4 SVAs generated per signal. Additionally, without
    specific assertion type guidance, GPT-4 only generates functional assertions.
  prefs: []
  type: TYPE_NORMAL
- en: For the SVA quality of commercial solutions, the original GPT-4 model tends
    to produce SVAs with syntax errors, similar to observations made in the previous
    study [[8](#bib.bib8)]. This issue is addressed in AssertLLM through the application
    of RAG techniques, which enrich the model with specific knowledge on SVA and Formal
    Property Verification (FPV). In the evaluation results, GPT-4 failed to generate
    any correct SVAs for IO ports and only succeeded in creating accurate reset check
    assertions for registers, leading to an overall correct proportion of only 8%.
  prefs: []
  type: TYPE_NORMAL
- en: V Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: V-A Coverage in SVA Evaluation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some works [[8](#bib.bib8)] propose to leverage the coverage metric, especially
    the cone-of-influence (COI) coverage to evaluate the quality of generated SVAs.
    COI coverage relies on analyzing the signals exercised during simulation or formal
    verification, which significantly involves internal signals within the design.
  prefs: []
  type: TYPE_NORMAL
- en: Given that our SVA generation process is based solely on the information available
    in the specification documents, which typically detail external interfaces like
    IO ports and architectural-level registers rather than internal signals, COI coverage
    does not align well with our evaluation criteria. This coverage metric assumes
    a level of design implementation detail that goes beyond the scope of natural
    language specifications, making it less applicable for assessing the completeness
    or effectiveness of SVAs generated at this pre-RTL stage.
  prefs: []
  type: TYPE_NORMAL
- en: V-B Evaluating and Enhancing Specification Quality with AssertLLM
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The generation of high-quality SVAs from natural language specifications relies
    not only on the capabilities of LLMs but also on the intrinsic quality of the
    specification documents themselves. A specification that provides only the basic
    information of signals, such as their names and simple descriptions, without delving
    into detailed functionalities or connectivities, inherently limits the potential
    for generating meaningful SVAs, regardless of the power of the LLMs employed.
    Conversely, specifications that offer comprehensive details, including clear definitions
    of signal functionalities and connectivities, can facilitate the generation of
    SVAs even with relatively simple LLMs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we identify a novel application for AssertLLM beyond its primary role
    in verification: utilizing AssertLLM as a tool for assessing the quality of natural
    language specifications. This application leverages AssertLLM’s ability to process
    and interpret specification documents to determine their verification-friendliness.
    Specifications that enable AssertLLM to generate a broad and accurate range of
    SVAs can be considered high-quality and well-suited for verification purposes.
    This approach to evaluating specification quality offers several benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Identifying Gaps between Specifications and Verification: AssertLLM can highlight
    contents within a specification that lack sufficient detail for SVA generation,
    guiding architects to provide more comprehensive information.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Enhancing Verification: Ensuring specifications are verification-friendly can
    potentially reduce the time and effort required for verification.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Standardizing Specification Writing: The feedback from AssertLLM can help establish
    best practices for writing specifications to facilitate the automated verification,
    and promote consistency across design stages.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: VI Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this study, we introduce AssertLLM, an automated framework designed for generating
    assertions from entire specification documents. AssertLLM breaks down the intricate
    task into three sequential phases, leveraging specialized LLMs for structural
    specification extraction, signal definition mapping, and assertion creation. We
    also offer an open-source benchmark to evaluate the efficacy of assertion generation.
    Evaluating AssertLLM on a comprehensive design with 23 signals revealed that 89%
    of the assertions generated were accurate both syntactically and functionally.
    We also discuss the potential of using AssertLLM to evaluate and enhance the quality
    of specifications.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[1] H. Witharana, Y. Lyu, S. Charles, and P. Mishra, “A survey on assertion-based
    hardware verification,” *ACM Computing Surveys (CSUR)*, vol. 54, no. 11s, pp.
    1–33, 2022.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[2] S. Germiniani and G. Pravadelli, “Harm: a hint-based assertion miner,”
    *IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems*,
    vol. 41, no. 11, pp. 4277–4288, 2022.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[3] A. Danese, N. D. Riva, and G. Pravadelli, “A-team: Automatic template-based
    assertion miner,” in *Proceedings of the 54th Annual Design Automation Conference
    2017*, 2017, pp. 1–6.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[4] S. Vasudevan, D. Sheridan, S. Patel, D. Tcheng, B. Tuohy, and D. Johnson,
    “Goldmine: Automatic assertion generation using data mining and static analysis,”
    in *2010 Design, Automation & Test in Europe Conference & Exhibition (DATE 2010)*.   IEEE,
    2010, pp. 626–629.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[5] M. Orenes-Vera, A. Manocha, D. Wentzlaff, and M. Martonosi, “Autosva: Democratizing
    formal verification of rtl module interactions,” in *2021 58th ACM/IEEE Design
    Automation Conference (DAC)*.   IEEE, 2021, pp. 535–540.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[6] W. Fang, G. Hu, and H. Zhang, “r-map: Relating implementation and specification
    in hardware refinement checking,” *IEEE Transactions on Computer-Aided Design
    of Integrated Circuits and Systems*, 2023.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[7] R. Kande, H. Pearce, B. Tan, B. Dolan-Gavitt, S. Thakur, R. Karri, and
    J. Rajendran, “Llm-assisted generation of hardware assertions,” *arXiv preprint
    arXiv:2306.14027*, 2023.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[8] M. Orenes-Vera, M. Martonosi, and D. Wentzlaff, “Using llms to facilitate
    formal verification of rtl,” *arXiv e-prints*, pp. arXiv–2309, 2023.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[9] C. Sun, C. Hahn, and C. Trippel, “Towards improving verification productivity
    with circuit-aware translation of natural language to systemverilog assertions,”
    in *First International Workshop on Deep Learning-aided Verification (DAV)*, 2023.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[10] C. B. Harris and I. G. Harris, “Glast: Learning formal grammars to translate
    natural language specifications into hardware assertions,” in *2016 Design, Automation
    & Test in Europe Conference & Exhibition (DATE)*.   IEEE, 2016, pp. 966–971.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[11] R. Krishnamurthy and M. S. Hsiao, “Controlled natural language framework
    for generating assertions from hardware specifications,” in *2019 IEEE 13th International
    Conference on Semantic Computing (ICSC)*.   IEEE, 2019, pp. 367–370.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[12] J. Zhao and I. G. Harris, “Automatic assertion generation from natural
    language specifications using subtree analysis,” in *2019 Design, Automation &
    Test in Europe Conference & Exhibition (DATE)*.   IEEE, 2019, pp. 598–601.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[13] R. Krishnamurthy and M. S. Hsiao, “Ease: Enabling hardware assertion synthesis
    from english,” in *Rules and Reasoning: Third International Joint Conference,
    RuleML+ RR 2019, Bolzano, Italy, September 16–19, 2019, Proceedings 3*.   Springer,
    2019, pp. 82–96.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[14] S. J. Frederiksen, J. Aromando, and M. S. Hsiao, “Automated assertion
    generation from natural language specifications,” in *2020 IEEE International
    Test Conference (ITC)*.   IEEE, 2020, pp. 1–5.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[15] O. Keszocze and I. G. Harris, “Chatbot-based assertion generation from
    natural language specifications,” in *2019 Forum for Specification and Design
    Languages (FDL)*.   IEEE, 2019, pp. 1–6.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[16] G. Parthasarathy, S. Nanda, P. Choudhary, and P. Patil, “Spectosva: Circuit
    specification document to systemverilog assertion translation,” in *2021 Second
    Document Intelligence Workshop at KDD*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[17] F. Aditi and M. S. Hsiao, “Hybrid rule-based and machine learning system
    for assertion generation from natural language specifications,” in *2022 IEEE
    31st Asian Test Symposium (ATS)*.   IEEE, 2022, pp. 126–131.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[18] J. Achiam, S. Adler, S. Agarwal, L. Ahmad, I. Akkaya, F. L. Aleman, D. Almeida,
    J. Altenschmidt, S. Altman, S. Anadkat *et al.*, “Gpt-4 technical report,” *arXiv
    preprint arXiv:2303.08774*, 2023.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[19] S. Liu, W. Fang, Y. Lu, Q. Zhang, H. Zhang, and Z. Xie, “Rtlcoder: Outperforming
    gpt-3.5 in design rtl generation with our open-source dataset and lightweight
    solution,” *arXiv preprint arXiv:2312.08617*, 2023.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[20] J. Blocklove, S. Garg, R. Karri, and H. Pearce, “Chip-chat: Challenges
    and opportunities in conversational hardware design,” *arXiv preprint arXiv:2305.13243*,
    2023.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[21] Y. Lu, S. Liu, Q. Zhang, and Z. Xie, “Rtllm: An open-source benchmark
    for design rtl generation with large language model,” *arXiv preprint arXiv:2308.05345*,
    2023.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[22] M. Liu, N. Pinckney, B. Khailany, and H. Ren, “Verilogeval: Evaluating
    large language models for verilog code generation,” *arXiv preprint arXiv:2309.07544*,
    2023.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[23] S. Thakur, B. Ahmad, Z. Fan, H. Pearce, B. Tan, R. Karri, B. Dolan-Gavitt,
    and S. Garg, “Benchmarking large language models for automated verilog rtl code
    generation,” in *DATE*, 2023.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[24] S. Thakur, J. Blocklove, H. Pearce, B. Tan, S. Garg, and R. Karri, “Autochip:
    Automating hdl generation using llm feedback,” *arXiv preprint arXiv:2311.04887*,
    2023.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[25] M. Nair, R. Sadhukhan, and D. Mukhopadhyay, “Generating secure hardware
    using chatgpt resistant to cwes,” *Cryptology ePrint Archive*, 2023.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[26] M. Liu, T.-D. Ene, R. Kirby, C. Cheng, N. Pinckney, R. Liang, J. Alben,
    H. Anand, S. Banerjee, I. Bayraktaroglu *et al.*, “Chipnemo: Domain-adapted llms
    for chip design,” *arXiv preprint arXiv:2311.00176*, 2023.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[27] Y. Tsai, M. Liu, and H. Ren, “Rtlfixer: Automatically fixing rtl syntax
    errors with large language models,” *arXiv preprint arXiv:2311.16543*, 2023.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[28] Z. He, H. Wu, X. Zhang, X. Yao, S. Zheng, H. Zheng, and B. Yu, “Chateda:
    A large language model powered autonomous agent for eda,” in *MLCAD Workshop*,
    2023.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[29] Y. Fu, Y. Zhang, Z. Yu, S. Li, Z. Ye, C. Li, C. Wan, and Y. Lin, “Gpt4aigchip:
    Towards next-generation ai accelerator design automation via large language models,”
    *arXiv preprint arXiv:2309.10730*, 2023.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[30] Z. Yan, Y. Qin, X. S. Hu, and Y. Shi, “On the viability of using llms
    for sw/hw co-design: An example in designing cim dnn accelerators,” *arXiv preprint
    arXiv:2306.06923*, 2023.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[31] B. Ahmad, S. Thakur, B. Tan, R. Karri, and H. Pearce, “Fixing hardware
    security bugs with large language models,” *arXiv preprint arXiv:2302.01215*,
    2023.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[32] M. Li, W. Fang, Q. Zhang, and Z. Xie, “Specllm: Exploring generation and
    review of vlsi design specification with large language model,” *arXiv preprint
    arXiv:2401.13266*, 2024.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[33] E. Seligman, T. Schubert, and M. A. K. Kumar, *Formal verification: an
    essential toolkit for modern VLSI design*.   Elsevier, 2023.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[34] A. B. Mehta, *SystemVerilog Assertions and Functional Coverage*.   Springer,
    2020.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[35] S. Vijayaraghavan and M. Ramanathan, *A practical guide for SystemVerilog
    assertions*.   Springer Science & Business Media, 2005.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
