- en: <!--yml
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 'category: 未分类'
- en: 'date: 2024-09-08 18:51:29'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '日期: 2024-09-08 18:51:29'
- en: -->
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: 'C2HLSC: Can LLMs Bridge the Software-to-Hardware Design Gap?'
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'C2HLSC: LLMs 能否弥合软件与硬件设计之间的差距？'
- en: 来源：[https://ar5iv.labs.arxiv.org/html/2406.09233](https://ar5iv.labs.arxiv.org/html/2406.09233)
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[https://ar5iv.labs.arxiv.org/html/2406.09233](https://ar5iv.labs.arxiv.org/html/2406.09233)
- en: Luca Collini , Siddharth Garg , Ramesh Karri
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Luca Collini，Siddharth Garg，Ramesh Karri
- en: Abstract
  id: totrans-7
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 摘要
- en: High Level Synthesis (HLS) tools offer rapid hardware design from C code, but
    their compatibility is limited by code constructs. This paper investigates Large
    Language Models (LLMs) for refactoring C code into HLS-compatible formats. We
    present several case studies by using an LLM to rewrite C code for NIST 800-22
    randomness tests, a QuickSort algorithm and AES-128 into HLS-synthesizable c.
    The LLM iteratively transforms the C code guided by user prompts, implementing
    functions like streaming data and hardware-specific signals. This evaluation demonstrates
    the LLM’s potential to assist hardware design refactoring regular C code into
    HLS synthesizable C code.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 高级综合（HLS）工具通过 C 代码提供快速的硬件设计，但它们的兼容性受到代码结构的限制。本文探讨了大语言模型（LLMs）在将 C 代码重构为 HLS
    兼容格式中的应用。我们通过使用 LLM 将 C 代码重写为 NIST 800-22 随机性测试、快速排序算法和 AES-128 的 HLS 可综合 C 的几个案例研究。LLM
    在用户提示的指导下迭代地转换 C 代码，实现了如数据流和硬件特定信号等功能。这项评估展示了 LLM 在协助硬件设计方面的潜力，将常规 C 代码重构为 HLS
    可综合 C 代码。
- en: 'Index Terms:'
  id: totrans-9
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 索引词：
- en: 'Chip Design, LLM, Catapult HLS, Cryptocores.^†^†publicationid: pubid: 979-8-3503-7608-1/24$31.00
    ©2024 IEEE'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '芯片设计，LLM，Catapult HLS，加密核心。^†^†出版号: pubid: 979-8-3503-7608-1/24$31.00 ©2024
    IEEE'
- en: I Introduction
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: I 引言
- en: 'High-Level Synthesis (HLS) is a promising chip design methodology that enables
    rapid hardware design from high-level specifications. HLS tools convert a high-level
    specification (C, C++) into an register transfer level (RTL) description [[1](#bib.bib1)]:
    (1) HLS uses state-of-the-art compilers (e.g., LLVM or GCC) to extract a high-level
    control data flow graph (CDFG). (2) They then assign operations to time (scheduling)
    and space (allocation and binding) to determine the micro-architecture. HLS tools
    also support pragmas and directives to explore architectural choices for a C specification.
    Software and hardware paradigms are different. Hence HLS tools support a subset
    of C constructs that map to hardware. For instance, hardware does not support
    dynamic memory allocation and recursive constructs. Outputs can only communicate
    through parameters, arrays sizes need to be static, limit support for pointers
    and multiple processes can be modeled through independent function instances mapped
    into hardware blocks. Designers manually refactor C code to remove these constructs
    and make it compatible with HLS tools. However, manual refactoring is time consuming,
    and error prone [[2](#bib.bib2)].'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 高级综合（HLS）是一种有前景的芯片设计方法论，它能够从高级规格中快速设计硬件。HLS 工具将高级规格（C、C++）转换为寄存器传输级（RTL）描述 [[1](#bib.bib1)]：（1）HLS
    使用最先进的编译器（如 LLVM 或 GCC）来提取高级控制数据流图（CDFG）。 (2) 然后，它们将操作分配到时间（调度）和空间（分配和绑定）以确定微架构。HLS
    工具还支持 pragmas 和指令，以探索 C 规格的架构选择。软件和硬件范式不同。因此，HLS 工具支持一部分映射到硬件的 C 结构。例如，硬件不支持动态内存分配和递归结构。输出只能通过参数通信，数组大小需要静态，限制对指针的支持，多进程可以通过映射到硬件块的独立函数实例来建模。设计师手动重构
    C 代码以删除这些结构，使其与 HLS 工具兼容。然而，手动重构既费时又容易出错 [[2](#bib.bib2)]。
- en: I-A Large Language Models (LLMs)
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: I-A 大语言模型（LLMs）
- en: LLMs are trained on massive amounts of text data and excel at tasks like code
    generation and translation, particularly in languages like C, Cc++, and Python.
    However, their performance suffers on Hardware Description Languages (HDLs) like
    Verilog or VHDL due to the limited amount of training data available in those
    languages [[3](#bib.bib3)]. This paper explores LLMs for refactoring C code, transforming
    it into a subset C compatible with HLS tools. LLMs can analyze generic C code
    and refactor it to HLS-synthesizable C. This leverages the power of LLMs in generating
    and manipulating C code and bypassing their limitations in generating HDL code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: LLMs 在大量文本数据上进行训练，在代码生成和翻译等任务中表现出色，特别是在 C、C++ 和 Python 等语言中。然而，由于这些语言中可用的训练数据有限，它们在硬件描述语言（HDLs）如
    Verilog 或 VHDL 上的表现不佳 [[3](#bib.bib3)]。本文探讨了 LLMs 用于重构 C 代码，将其转换为与 HLS 工具兼容的子集
    C。LLMs 可以分析通用 C 代码并将其重构为 HLS 可综合 C。这利用了 LLMs 在生成和操控 C 代码方面的能力，绕过了其在生成 HDL 代码时的限制。
- en: I-B Contributions and Roadmap
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: I-B 贡献和路线图
- en: 'LLMs have limited success in generating Verilog code [[4](#bib.bib4), [5](#bib.bib5)].
    This is due to the scarcity online of hardware description language (HDL) data
    compared to code in C, C++ and other software. We explore use of LLMs to assist
    developers in refactoring generic C specification into synthesizable C that is
    compatible with HLS as shown in Figure [1](#S1.F1 "Figure 1 ‣ I-B Contributions
    and Roadmap ‣ I Introduction ‣ C2HLSC: Can LLMs Bridge the Software-to-Hardware
    Design Gap?"). Out work has two main contributions. First, we present case studies
    of deriving HLS-usable C codes derived from generic C codes. The study compares
    development time and resource use achieved using LLM-assisted development in lieu
    of cumbersome manual methods. Second, we discuss the results and present a prototype
    hands-free C2HLSC LLM-based tool, which will be open-source. The paper road-map
    is as follows: 1. Section [II](#S2 "II Related Work ‣ C2HLSC: Can LLMs Bridge
    the Software-to-Hardware Design Gap?") presents related work, highlighting the
    novelties of the approach. 2. Section [III](#S3 "III Case Study ‣ C2HLSC: Can
    LLMs Bridge the Software-to-Hardware Design Gap?") illustrates the case study,
    presenting the tasks and methodologies and results. 3. Section [IV](#S4 "IV Hands-Free
    C2HSLC Prototype ‣ C2HLSC: Can LLMs Bridge the Software-to-Hardware Design Gap?")
    presents the prototype hands-free C2HLSC tool, discussing capabilities and limitations.
    4. Section [V](#S5 "V Conclusions ‣ C2HLSC: Can LLMs Bridge the Software-to-Hardware
    Design Gap?") concludes the paper.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 'LLM 在生成 Verilog 代码方面取得的成功有限 [[4](#bib.bib4), [5](#bib.bib5)]。这是因为与 C、C++ 和其他软件代码相比，硬件描述语言
    (HDL) 数据在线上较为稀缺。我们探讨了使用 LLM 来协助开发者将通用 C 规范重构为与 HLS 兼容的可综合 C，如图 [1](#S1.F1 "图 1
    ‣ I-B 贡献与路线图 ‣ I 介绍 ‣ C2HLSC: LLM 是否可以弥合软件与硬件设计的差距？") 所示。我们的工作有两个主要贡献。首先，我们展示了从通用
    C 代码中推导出适用于 HLS 的 C 代码的案例研究。该研究比较了使用 LLM 辅助开发与繁琐的手动方法在开发时间和资源使用方面的差异。其次，我们讨论了结果并展示了一个原型免手动
    C2HLSC LLM 工具，该工具将开源。论文的路线图如下：1. [II](#S2 "II 相关工作 ‣ C2HLSC: LLM 是否可以弥合软件与硬件设计的差距？")
    节展示相关工作，突出了方法的创新。2. [III](#S3 "III 案例研究 ‣ C2HLSC: LLM 是否可以弥合软件与硬件设计的差距？") 节说明了案例研究，介绍了任务、方法和结果。3.
    [IV](#S4 "IV 免手动 C2HSLC 原型 ‣ C2HLSC: LLM 是否可以弥合软件与硬件设计的差距？") 节展示了免手动 C2HLSC 工具的原型，讨论了其能力和局限性。4.
    [V](#S5 "V 结论 ‣ C2HLSC: LLM 是否可以弥合软件与硬件设计的差距？") 节总结了论文。'
- en: '![Refer to caption](img/1dbbe43ac3d13f93384e2a2eba246631.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![参见说明](img/1dbbe43ac3d13f93384e2a2eba246631.png)'
- en: 'Figure 1: Flow for the proposed C2HLSC approach.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1：所提出的 C2HLSC 方法的流程。
- en: II Related Work
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: II 相关工作
- en: Previous work explored LLMs to design hardware. Verigen fine-tuned an LLM to
    improve its ability to produce Verilog [[4](#bib.bib4)]. The fine tuned LLM though
    performed marginally better than ChatGPT3.5-turbo with an accuracy $\sim$65%.
    ChipChat [[5](#bib.bib5)] was the first to tapeout a design written by an AI model.
    However, the single shot performance of the AI model was low and needed several
    iterations in order for the LLM to get to the correct result. We target generating
    synthesizable C code as LLMs are more capable at C than at hardware languages [[3](#bib.bib3)].
    In [[6](#bib.bib6)] an LLM was used to write Amaranth HDL, a Python based HDL,
    that allows to model synchronous logic at the RTL. For this reason, while it uses
    a high level language, its semantics are close to verilog, and targets hardware
    designers. While the LLM came up with parts of the design, it fell short in some
    tasks, like generating interfaces. Software developers use HLS to design hardware
    and as such the code only provides the functionality¹¹1Whereas the hardware architecture
    and interface specification are instructed using HLS pragmas and directives..
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的工作探索了使用 LLMs 设计硬件。Verigen 对 LLM 进行了微调，以提高其生成 Verilog 的能力 [[4](#bib.bib4)]。虽然微调后的
    LLM 的表现略优于 ChatGPT3.5-turbo，准确率约为 $\sim$65%。ChipChat [[5](#bib.bib5)] 是第一个由 AI
    模型生成并完成 tapeout 的设计。然而，AI 模型的一次性表现较低，需要多次迭代才能获得正确结果。我们的目标是生成可综合的 C 代码，因为 LLM 在
    C 语言上比在硬件语言上更具能力 [[3](#bib.bib3)]。在 [[6](#bib.bib6)] 中，LLM 被用来编写 Amaranth HDL，一种基于
    Python 的 HDL，允许在 RTL 上建模同步逻辑。出于这个原因，虽然它使用的是高级语言，但其语义接近于 Verilog，并且针对硬件设计师。虽然 LLM
    提出了部分设计，但在生成接口等任务上表现不佳。软件开发者使用 HLS 设计硬件，因此代码只提供功能¹¹1而硬件架构和接口规范则通过 HLS 指令和指示进行指导。.
- en: III Case Study
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: III 案例研究
- en: III-A Overview
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: III-A 概述
- en: 'We evaluated Gemini LLM [[7](#bib.bib7)] to transform C code into synthesizable
    C suitable for HLS. The evaluation consisted of two tasks. The first task involved
    rewriting reference C implementations of the Frequency test, Frequency Block test,
    Cumulative Sums, and Overlapping Template Matching tests from the NIST 800-22
    suite [[8](#bib.bib8)] into synthesizable C code. These tests are designed to
    assess the randomness of a sequence. A first challenge arose due to the inherent
    differences between software and hardware implementations. The reference C implementations
    operate on a pre-loaded random sequence stored in memory. Conversely, hardware
    implementations require on-the-fly analysis, processing the sequence bit-by-bit.
    This necessitates modifying the code to handle a streaming data input rather than
    a pre-loaded array. A second challenge stemmed from the p-value calculation. In
    software context, the precise p-value is critical and computed on-the-fly. However,
    since the hardware implementations primarily focus on distinguishing random from
    non-random sequences one can simplify this by pre-computing certain values offline
    and reducing the computational burden during on-the-fly analysis. Both these challenges
    are non-trivial for human developers and LLMs. The second task assesses the LLM’s
    ability to rewrite code constructs that are not supported by HLS tools. We used
    two algorithms: a QuickSort containing pointers and recursion [[9](#bib.bib9)],
    and the AES128 encrypt from the tinyAES library [[10](#bib.bib10)] with six functions.
    The goal was for the LLM to generate code without pointers and recursion, making
    it suitable for (Catapult) HLS.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们评估了 Gemini LLM [[7](#bib.bib7)] 来将 C 代码转换为适用于 HLS 的可综合 C 代码。评估包含两个任务。第一个任务涉及将
    NIST 800-22 套件中的频率测试、频率块测试、累积和测试和重叠模板匹配测试的参考 C 实现 [[8](#bib.bib8)] 改写为可综合 C 代码。这些测试旨在评估序列的随机性。第一个挑战源于软件和硬件实现之间的固有差异。参考
    C 实现操作在预加载的存储在内存中的随机序列上。相比之下，硬件实现需要实时分析，将序列逐位处理。这要求修改代码以处理流数据输入，而不是预加载的数组。第二个挑战来自
    p 值计算。在软件环境中，精确的 p 值至关重要，并且需要实时计算。然而，由于硬件实现主要关注区分随机序列和非随机序列，因此可以通过离线预计算某些值并减少实时分析中的计算负担来简化这一过程。这两个挑战对于人类开发者和
    LLM 都并非简单。第二个任务评估了 LLM 改写不被 HLS 工具支持的代码结构的能力。我们使用了两个算法：一个包含指针和递归的 QuickSort [[9](#bib.bib9)]
    和来自 tinyAES 库的 AES128 加密 [[10](#bib.bib10)]，后者包含六个函数。目标是使 LLM 生成不包含指针和递归的代码，使其适合（Catapult）HLS。
- en: III-B Methodology
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: III-B 方法论
- en: 'We broke down the process into small steps to allow the LLM to transform the
    original C into synthesizable C. For the first task we followed the following
    steps for the three tests: 1. Present task to the LLM: ”Hi, I have this code in
    C that I need to rewrite such that I can use it with an HLS tool to generate hardware.”.
    2. Ask to remove print statements. 3. Ask to rewrite the function as a streaming
    interface: ”Now I need to rewrite the function such that it will get inferred
    as a streaming interface, to do so, I need to get rid of the epsilon array and
    have the function take a parameter to accept a bit at each function call.” 4.
    Ask to remove math steps to be computed offline (in some cases, ask to write a
    script to run them). 5. Ask to add is_random and valid signals as parameters.
    6. Ask to optimize data types using arbitrary width integers and fixed point arithmetic
    using HLSLIBS [[11](#bib.bib11)]. 7. Ask to write a main function to test the
    function passing random bits. 8. Ask to fix mistakes passing errors from HLS tool.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将过程分解为小步骤，以便 LLM 将原始 C 转换为可综合 C。对于第一个任务，我们遵循以下步骤进行三个测试：1. 向 LLM 介绍任务：“你好，我有这段
    C 代码，我需要将其改写，以便我可以使用 HLS 工具生成硬件。” 2. 请求去除打印语句。 3. 请求将函数改写为流接口：“现在我需要将函数改写为流接口，以便能够推断出来，为此，我需要去掉
    epsilon 数组，并使函数接收一个参数以接受每次函数调用中的一位数据。” 4. 请求去除离线计算的数学步骤（在某些情况下，请求编写一个脚本来运行这些步骤）。
    5. 请求添加 is_random 和 valid 信号作为参数。 6. 请求使用任意宽度整数和固定点算术进行数据类型优化，使用 HLSLIBS [[11](#bib.bib11)]。
    7. 请求编写一个主函数以测试传递随机位的函数。 8. 请求修复传递 HLS 工具中的错误。
- en: 'For QuickSort we followed these steps: 1. Present the task to the LLM: ”Hi,
    I have this code in C that I need to rewrite such that I can use it with an HLS
    tool to generate hardware.”. 2. Ask to remove print statements. 3. Ask to rewrite
    function without using pointers. 4. Ask to rewrite function without recursion.
    5. Ask to fix array sizes in function parameters. 6. Ask to optimize data types
    using arbitrary width integers and fixed point arithmetic using HLSLIBS. 7. Ask
    to write a main function to test the function passing an array to sort. 8. Ask
    to fix mistakes by passing errors from HLS tool.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于QuickSort，我们遵循了以下步骤：1. 向LLM提出任务：“你好，我有这段C代码需要重写，以便我可以用HLS工具生成硬件。”。2. 请求去除打印语句。3.
    请求重写函数，不使用指针。4. 请求重写函数，不使用递归。5. 请求修正函数参数中的数组大小。6. 请求使用任意宽度整数和固定点算术通过HLSLIBS优化数据类型。7.
    请求编写一个主函数来测试函数，传递一个数组进行排序。8. 请求通过传递HLS工具的错误来修复错误。
- en: 'For the AES 128 from tinyAES [[10](#bib.bib10)] we followed the following steps
    asking to fix one function at a time: 1. Present the task to the LLM: ”Hi, I have
    this code in C that I need to rewrite such that I can use it with an HLS tool
    to generate hardware.”. 2. Ask to rewrite for loops with fixed bounds and no pointer
    usage. 3. Ask to rewrite the function parameters to using fixed size arrays. 4.
    Ask to fix eventual mistakes passing errors from the HLS tool. When the LLM responds
    with sub optimal answers, we check alternative answers, and if none fully satisfied
    the request we instruct the LLM with additional prompts including more details
    pointing out where the problem was, and, if not sufficient, hinting at possible
    solutions.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于tinyAES中的AES 128 [[10](#bib.bib10)]，我们遵循以下步骤，逐个请求修复一个函数：1. 向LLM提出任务：“你好，我有这段C代码需要重写，以便我可以用HLS工具生成硬件。”。2.
    请求将for循环重写为固定边界且不使用指针。3. 请求将函数参数重写为使用固定大小的数组。4. 请求通过传递HLS工具的错误来修复可能的错误。当LLM提供次优答案时，我们检查替代答案，如果没有一个完全满足请求，我们会用额外的提示，包括更多细节指出问题所在，如果还不够，提示可能的解决方案。
- en: III-C Results
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: III-C 结果
- en: 'The aim of this study is to evaluate how LLMs perform at rewriting C code such
    that it is HLS synthesizable²²2Finding pragmas to optimize the hardware architecture
    is an orthogonal problem for which LLMs could be employed, left as future work..
    We run the code through Catapult HLS to check correctness after synthesis, but
    we do not focus on the resource utilization, as it is depends on the architectural
    decisions. We targeted the nangate45 library at 50 MHz with a synchronous active
    high reset for all the tests. The LLM was able to rewrite all C codes to run on
    Catapult HLS. We performed simulations with Modelsim to check result equivalency
    between the original C and the synthesized Verilog obtained from the LLM-generated
    C. The original C codes (without printfs) and the HLS C code rewritten by the
    LLM are in Appendix [-A](#A0.SS1 "-A LLM generated HLS compatible C codes ‣ C2HLSC:
    Can LLMs Bridge the Software-to-Hardware Design Gap?"), links to the conversations
    are in Appendix [-C](#A0.SS3 "-C Conversations ‣ C2HLSC: Can LLMs Bridge the Software-to-Hardware
    Design Gap?"). We can classify the errors in the LLM generated code into compile/synthesis
    errors, and functional errors. The former where easier to fix instructing the
    LLM with the error message and affected line. For functional errors caught by
    the failing tests, it was harder for the LLM to identify the cause and propose
    a fix. Manual effort was needed to point out sources of the issues for the LLM
    to propose an effective fix. Typical functional issues where mistaken loop readjustments,
    widths and arbitrary widths types.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '本研究的目的是评估LLM在重写C代码以使其具备HLS合成能力方面的表现²²2找到优化硬件架构的pragma是一个正交问题，LLM可以被用来解决，但留待未来工作中进行。我们通过Catapult
    HLS运行代码以检查合成后的正确性，但不关注资源利用率，因为它依赖于架构决策。我们在所有测试中以50 MHz的频率和同步高电平复位针对nangate45库进行测试。LLM能够重写所有C代码以便在Catapult
    HLS上运行。我们使用Modelsim进行仿真，以检查原始C代码和LLM生成的C代码合成后的Verilog之间的结果等效性。原始C代码（没有printf语句）和LLM重写的HLS
    C代码见附录[-A](#A0.SS1 "-A LLM生成的HLS兼容C代码 ‣ C2HLSC: LLM能否弥合软件与硬件设计的差距？")，对话链接见附录[-C](#A0.SS3
    "-C 对话 ‣ C2HLSC: LLM能否弥合软件与硬件设计的差距？")。我们可以将LLM生成的代码中的错误分为编译/合成错误和功能错误。前者更容易修复，通过向LLM提供错误消息和受影响的行来进行。对于被失败测试捕获的功能错误，LLM更难识别原因并提出修复方案。需要人工努力指出问题来源，以便LLM提出有效的修复方案。典型的功能问题包括错误的循环调整、宽度和任意宽度类型。'
- en: III-C1 C2HLSC of NIST 800-22 Randomness Tests
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: III-C1 C2HLSC 的 NIST 800-22 随机性测试
- en: 'The LLM performed well in most steps, especially in rewriting the function
    as a streaming interface, which is one of the more complex steps. Figure [2](#S3.F2
    "Figure 2 ‣ III-C1 C2HLSC of NIST 800-22 Randomness Tests ‣ III-C Results ‣ III
    Case Study ‣ C2HLSC: Can LLMs Bridge the Software-to-Hardware Design Gap?") shows
    the streaming interface rewriting for the Frequency Block test. For all the three
    tests this step was performed correctly at the first shot. However, the LLM did
    stumble on tasks that seemd more trivial. For example, when asked to remove the
    abs function in this line of code (abs(sum.to_int()) <= SUM_THRESHOLD); it came
    up with convoluted ways that did not work like (sum.to_int() <0) ? -sum.to_int()
    : sum.to_int()) <= SUM_THRESHOLD and it took many tries to eventually get the
    expected result (sum <SUM_THRESHOLD) && (sum <-SUM_THRESHOLD). The test function
    generation was always generated effectively.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 'LLM 在大多数步骤中表现良好，特别是在将函数重写为流式接口这一复杂步骤上。图 [2](#S3.F2 "Figure 2 ‣ III-C1 C2HLSC
    of NIST 800-22 Randomness Tests ‣ III-C Results ‣ III Case Study ‣ C2HLSC: Can
    LLMs Bridge the Software-to-Hardware Design Gap?") 显示了频率块测试的流式接口重写。对于所有三个测试，这一步骤都在第一次尝试时正确执行。然而，LLM
    在处理看似更琐碎的任务时却出现了问题。例如，当被要求移除这行代码中的 abs 函数 (abs(sum.to_int()) <= SUM_THRESHOLD)
    时，它提出了一些复杂且无效的方式，比如 (sum.to_int() <0) ? -sum.to_int() : sum.to_int()) <= SUM_THRESHOLD，经过多次尝试才最终得到预期结果
    (sum <SUM_THRESHOLD) && (sum <-SUM_THRESHOLD)。测试函数生成总是有效生成。'
- en: '1I  need  to  rewrite  the  function  such  that  it2will  get  inferred  as  a  streaming  interface,3to  do  so,  I  need  to  get  rid  of  the  epsilon4array  and  have  the  function  take  a  parameter5to  accept  a  bit  at  each  function  call.1void  BlockFrequency(int  M,  int  n)  {2int  i,  j,  N,  blockSum;3double  p_value,  sum,  pi,  v,  chi2;4N  =  n  /  M;  /*  #  OF  SUBSTRING  BLOCKS  */5sum  =  0.0;6for  (i  =  0;  i  <  N;  i++)  {7  blockSum  =  0;8  for  (j  =  0;  j  <  M;  j++)  {9  blockSum  +=  epsilon[j  +  i  *  M];10  }11  pi  =  (double)blockSum  /  (double)M;12  v  =  pi  -  0.5;13  sum  +=  v  *  v;14}15chi2  =  4.0  *  M  *  sum;16p_value  =  cephes_igamc(N  /  2.0,  chi2  /  2.0);}1Here’s  the  code  rewritten  to  accept  a  single2bit  per  function  call,  making  it  more  suitable3for  a  streaming  interface:1void  BlockFrequency(int  M,  int  n,  bool  bit)  {2static  int  i  =  0,  j  =  0,  blockSum  =  0;3static  double  sum  =  0.0;4double  pi,  v,  chi2;5if  (j  ==  0)  {  //  Reset  on  new  block6  i++;7  blockSum  =  0;8}9blockSum  +=  bit;  //  Accumulate  bit10j++;11if  (j  ==  M)  {  //  Block  complete12  pi  =  (double)blockSum  /  (double)M;13  v  =  pi  -  0.5;14  sum  +=  v  *  v;15  j  =  0;16}17if  (i  ==  (n  /  M))  {  //  All  blocks  processed18  chi2  =  4.0  *  M  *  sum;19  p_value=cephes_igamc(n  /  2.0,  chi2  /  2.0);20}}'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '1I 需要重写函数，使其可以推断为流式接口。为此，我需要去除 epsilon 数组，并使函数接受一个参数，以便每次调用函数时接收一个位。1void BlockFrequency(int
    M, int n) {2int i, j, N, blockSum;3double p_value, sum, pi, v, chi2;4N = n / M;
    /* # OF SUBSTRING BLOCKS */5sum = 0.0;6for (i = 0; i < N; i++) {7 blockSum = 0;8
    for (j = 0; j < M; j++) {9 blockSum += epsilon[j + i * M];10 }11 pi = (double)blockSum
    / (double)M;12 v = pi - 0.5;13 sum += v * v;14}15chi2 = 4.0 * M * sum;16p_value
    = cephes_igamc(N / 2.0, chi2 / 2.0);}1这里是重写的代码，每次函数调用时接受一个位，使其更适合流式接口：1void BlockFrequency(int
    M, int n, bool bit) {2static int i = 0, j = 0, blockSum = 0;3static double sum
    = 0.0;4double pi, v, chi2;5if (j == 0) {  // 新块时重置6 i++;7 blockSum = 0;8}9blockSum
    += bit;  // 累积位10j++;11if (j == M) {  // 块完成12 pi = (double)blockSum / (double)M;13
    v = pi - 0.5;14 sum += v * v;15 j = 0;16}17if (i == (n / M)) {  // 所有块处理完成18 chi2
    = 4.0 * M * sum;19 p_value=cephes_igamc(n / 2.0, chi2 / 2.0);20}}'
- en: 'Figure 2: Transforming into a streaming pipeline.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2：转化为流式管道。
- en: III-C2 C2HLSC of QuickSort
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: III-C2 C2HLSC 的快速排序
- en: 'The original QuickSort used a function to swap elements in the arrays using
    pointers. Inlining the function and removing pointers was flawless as reported
    in Figure [3](#S3.F3 "Figure 3 ‣ III-C2 C2HLSC of QuickSort ‣ III-C Results ‣
    III Case Study ‣ C2HLSC: Can LLMs Bridge the Software-to-Hardware Design Gap?").
    However, in the subsequent steps it reverted to using the function and needed
    re-prompting to inline. The LLM got rid of recursion in one shot, using a fixed
    size stack to track the high and low values. However, the stack management logic
    was not correct. The problem was identified at the end, when running the generated
    test, which caused a segmentation fault. The LLM fixed the problem in a few tries
    by feeding the errors from gdb and showing intermediate values of high and low.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '原始的QuickSort使用了一个函数来通过指针交换数组中的元素。内联该函数并去除指针的过程完美无瑕，如图[3](#S3.F3 "图3 ‣ III-C2
    C2HLSC的QuickSort ‣ III-C 结果 ‣ III 案例研究 ‣ C2HLSC: LLM能否弥合软件与硬件设计之间的差距？")所述。然而，在后续步骤中，它又恢复使用该函数并需要重新提示进行内联。LLM一次性去掉了递归，使用固定大小的栈来跟踪高低值。然而，栈管理逻辑不正确。这个问题在运行生成的测试时被发现，导致了段错误。LLM通过提供来自gdb的错误信息和显示高低值的中间值，经过几次尝试修复了这个问题。'
- en: 1Can  we  get  rid  of  the  swap  function  and  replace2it  inline?1void  swap(int*  a,  int*  b)  {2  int  temp  =  *a;3  *a  =  *b;4  *b  =  temp;}5...6  if  (i  <  j)  {7  swap(arr[i],  arr[j]);  //  Call  to  modified  swap  function8  }}9swap(&arr[low],  &arr[j]);10...1Yes,  you  can  definitely  get  rid  of  the  swap2function  and  replace  it  inline  within  the3partition  function.  Here’s  the  modified  code:1...2  if  (i  <  j)  {3  //  Inline  swap  using  temporary  variable4  int  temp  =  arr[i];5  arr[i]  =  arr[j];6  arr[j]  =  temp;7  }}8//  Swap  pivot  element  with  element  at  index  j9int  temp  =  arr[low];10arr[low]  =  arr[j];11arr[j]  =  temp;12return  j;13...
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以去掉`swap`函数，并将其内联吗？`void swap(int* a, int* b) { int temp = *a; *a = *b; *b
    = temp; }`... `if (i < j) { swap(arr[i], arr[j]); // 调用修改后的 swap 函数 } }` `swap(&arr[low],
    &arr[j]);`... 是的，你完全可以去掉`swap`函数，并将其内联到`partition`函数中。以下是修改后的代码：... `if (i < j)
    { // 使用临时变量进行内联交换 int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } }` // 交换主轴元素与索引`j`处的元素
    `int temp = arr[low]; arr[low] = arr[j]; arr[j] = temp; return j;`...
- en: 'Figure 3: Removing pointers and inlining.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图3：去除指针和内联。
- en: III-C3 C2HLSC of AES 128 Encrypt
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: III-C3 C2HLSC的AES 128加密
- en: 'We fed one function at a time to the LLM starting from the top function Cipher.
    We tested the generated C code and found errors. We prompted the LLM to correct
    the errors. The LLM made major changes in the MixColumn and ShiftRows functions,
    so we asked it to double check that the new code was correct. ShiftRow function
    was corrected in 2 iterations, without extra context on the error. Results are
    in Figure [4](#S3.F4 "Figure 4 ‣ III-C3 C2HLSC of AES 128 Encrypt ‣ III-C Results
    ‣ III Case Study ‣ C2HLSC: Can LLMs Bridge the Software-to-Hardware Design Gap?").
    Fixing MixColumn function took more iterations even though the error was simple.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '我们一次性将一个函数输入到LLM，从顶部函数Cipher开始。我们测试了生成的C代码并发现了错误。我们提示LLM修正这些错误。LLM对MixColumn和ShiftRows函数进行了重大修改，因此我们要求它再次检查新代码是否正确。ShiftRow函数在没有额外错误上下文的情况下在2次迭代中被修正。结果见图[4](#S3.F4
    "图4 ‣ III-C3 C2HLSC的AES 128加密 ‣ III-C 结果 ‣ III 案例研究 ‣ C2HLSC: LLM能否弥合软件与硬件设计之间的差距？")。修复MixColumn函数则需要更多的迭代，即使错误很简单。'
- en: 1Can  you  fix  possible  problems  in  this  function?1static  void  ShiftRows(state_t*  state){2  uint8_t  temp;3  //  Rotate  first  row  1  columns  to  left4  temp  =  (*state)[0][1];5  (*state)[0][1]  =  (*state)[1][1];6  (*state)[1][1]  =  (*state)[2][1];7  (*state)[2][1]  =  (*state)[3][1];8  (*state)[3][1]  =  temp;9  //  Rotate  second  row  2  columns  to  left10  temp  =  (*state)[0][2];11  (*state)[0][2]  =  (*state)[2][2];12  (*state)[2][2]  =  temp;13  temp  =  (*state)[1][2];14  (*state)[1][2]  =  (*state)[3][2];15  (*state)[3][2]  =  temp;16  //  Rotate  third  row  3  columns  to  left17  temp  =  (*state)[0][3];18  (*state)[0][3]  =  (*state)[3][3];19  (*state)[3][3]  =  (*state)[2][3];20  (*state)[2][3]  =  (*state)[1][3];21  (*state)[1][3]  =  temp;}22...1LLM  result  after  2  tries  telling  the  LLM  that2the  loop  logic  was  wrong.1static  void  ShiftRows(state_t  state[4][4])  {2uint8_t  temp;3int  i,  j;4//  Loop  over  rows  1  to  3  (0-based  indexing)5for  (i  =  1;  i  <  4;  ++i)  {6//  Number  of  positions  to  left  shift  for  current  row7  int  shift  =  i;8  //  Use  a  separate  loop  for  the  number  of  shifts9  for  (j  =  0;  j  <  shift;  ++j)  {10  temp  =  state[0][i];  //  Store  the  element  to  be  shifted11  //  Shift  all  elements  by  one  position  to  the  left12  for  (int  k  =  0;  k  <  3;  ++k)  {13  state[k][i]  =  state[k  +  1][i];14  }15  state[3][i]  =  temp;  //  Place  the  temp  value  at  the  end16}}}
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 1你能修复这个函数中的可能问题吗？1static  void  ShiftRows(state_t*  state){2  uint8_t  temp;3  //  将第一行的
    1 列向左旋转4  temp  =  (*state)[0][1];5  (*state)[0][1]  =  (*state)[1][1];6  (*state)[1][1]  =  (*state)[2][1];7  (*state)[2][1]  =  (*state)[3][1];8  (*state)[3][1]  =  temp;9  //  将第二行的
    2 列向左旋转10  temp  =  (*state)[0][2];11  (*state)[0][2]  =  (*state)[2][2];12  (*state)[2][2]  =  temp;13  temp  =  (*state)[1][2];14  (*state)[1][2]  =  (*state)[3][2];15  (*state)[3][2]  =  temp;16  //  将第三行的
    3 列向左旋转17  temp  =  (*state)[0][3];18  (*state)[0][3]  =  (*state)[3][3];19  (*state)[3][3]  =  (*state)[2][3];20  (*state)[2][3]  =  (*state)[1][3];21  (*state)[1][3]  =  temp;}22...1LLM  经过  2
    次尝试后  告诉  LLM  循环  逻辑  是  错误的。1static  void  ShiftRows(state_t  state[4][4])  {2uint8_t  temp;3int  i,  j;4//  遍历第
    1 行到第 3 行（基于 0 的索引）5for  (i  =  1;  i  <  4;  ++i)  {6//  当前行的左移位置数7  int  shift  =  i;8  //  使用一个单独的循环进行移位次数9  for  (j  =  0;  j  <  shift;  ++j)  {10  temp  =  state[0][i];  //  存储要移位的元素11  //  将所有元素左移一位12  for  (int  k  =  0;  k  <  3;  ++k)  {13  state[k][i]  =  state[k  +  1][i];14  }15  state[3][i]  =  temp;  //  将
    temp 值放到末尾16}}}
- en: 'Figure 4: Removing pointers and inlining.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4：移除指针和内联。
- en: III-D Discussion
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: III-D 讨论
- en: Using LLMs for refactoring C code into HLS-compatible formats is a promising
    avenue in LLM aided design. The LLM, in our case Google’s Gemini, refactored reference
    C implementations of NIST 800-22 randomness tests, QuickSort, and AES-128\. The
    LLM’s ability to iteratively refactor the code based on user instructions significantly
    reduces manual effort in adapting code for HLS tools. This can streamline the
    hardware design process, especially for repetitive tasks. The LLM effectively
    addressed challenges like converting code from memory-based data processing to
    streaming, from recursion to iteration and pointers. While the LLM achieved core
    functionalities, it occasionally struggled with minor details requiring several
    iterations to guide it to the correct solution. In a practical scenario, a developer
    can rectify these minor errors. However, for an automated flow, a feedback loop
    is crucial, like that in [[5](#bib.bib5)].
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 LLM 将 C 代码重构为 HLS 兼容格式是 LLM 辅助设计中的一个有前景的方向。LLM，以谷歌的 Gemini 为例，重构了 NIST 800-22
    随机性测试、快速排序和 AES-128 的参考 C 实现。LLM 根据用户指令迭代重构代码的能力显著减少了将代码适配 HLS 工具的手动工作。这可以简化硬件设计过程，特别是对于重复性任务。LLM
    有效地解决了将代码从基于内存的数据处理转换为流处理、从递归到迭代和指针等挑战。虽然 LLM 实现了核心功能，但它偶尔在处理需要多个迭代以引导到正确解决方案的细节时遇到困难。在实际情况下，开发者可以修正这些小错误。然而，对于自动化流程来说，像[[5](#bib.bib5)]那样的反馈循环至关重要。
- en: 'TABLE I: Resource Utilization and Latency Results'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 表 I：资源利用率和延迟结果
- en: '| Design | Area Score | # Operations | Latency |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 设计 | 面积分数 | 操作数 | 延迟 |'
- en: '| This work | Manual | This work | Manual | This work | Manual |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 这项工作 | 手动 | 这项工作 | 手动 | 这项工作 | 手动 |'
- en: '| NIST-Monobit | 244 | 225.3 | 19 | 19 | 1 | 1 |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| NIST-Monobit | 244 | 225.3 | 19 | 19 | 1 | 1 |'
- en: '| NIST-Monobit Block | 702.3 | 826.0 | 24 | 20 | 1 | 1 |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| NIST-Monobit Block | 702.3 | 826.0 | 24 | 20 | 1 | 1 |'
- en: '| NIST-Cusums | 677.4 | 632 | 24 | 28 | 1 | 1 |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| NIST-Cusums | 677.4 | 632 | 24 | 28 | 1 | 1 |'
- en: '| NIST-Overlapping | 9933.4 | 7172.1 | 165 | 118 | 1 | 1 |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| NIST-Overlapping | 9933.4 | 7172.1 | 165 | 118 | 1 | 1 |'
- en: '| QuickSort | 18115.8 | n.a. | 67 | n.a. | 18 | n.a. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| QuickSort | 18115.8 | n.a. | 67 | n.a. | 18 | n.a. |'
- en: '| AES | 38604.5 | n.a. | 1924 | n.a. | 160 | n.a. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| AES | 38604.5 | n.a. | 1924 | n.a. | 160 | n.a. |'
- en: 'Table [I](#S3.T1 "Table I ‣ III-D Discussion ‣ III Case Study ‣ C2HLSC: Can
    LLMs Bridge the Software-to-Hardware Design Gap?") shows area for the implemented
    designs. For NIST test implementation we have reference designs that were implemented
    by a graduate student. We used the same directives for a fair comparison between
    the 2\. Area scores from Catapult are close. The manual implementations took around
    4 hours each while C2HLSC took between 30 to 60 minutes each. Although the sample
    size is limited, this shows the potential of LLMs in speeding up the process effectively
    and efficiently.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '表 [I](#S3.T1 "表 I ‣ III-D 讨论 ‣ III 案例研究 ‣ C2HLSC: LLM 能否弥合软件到硬件设计的差距？") 显示了实施设计的区域。对于
    NIST 测试实施，我们有由研究生实现的参考设计。我们使用了相同的指令，以便在两个设计之间进行公平比较。来自 Catapult 的区域评分接近。手动实现每个大约需要
    4 小时，而 C2HLSC 则需要 30 到 60 分钟。虽然样本量有限，但这显示了 LLM 在有效且高效地加速过程中的潜力。'
- en: IV Hands-Free C2HSLC Prototype
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IV 免提 C2HSLC 原型
- en: 'With the experience of the engineer-in-the-loop case studies, we implemented
    a hands-free C2HLSC prototype. The first insight from the case study was the twofold
    nature of the errors that can occur in the generated C — functional/compile errors
    and synthesis errors. The former kind can be caught by gcc. The latter kind can
    be caught by running the Catapult HLS tool. For this reason we setup a double
    feedback loop as shown in Figure [5](#S4.F5 "Figure 5 ‣ IV Hands-Free C2HSLC Prototype
    ‣ C2HLSC: Can LLMs Bridge the Software-to-Hardware Design Gap?"). One checks that
    the generated code compiles and passes reference tests, and one that checks that
    the code is synthesizable by Catapult HLS. We selected ChatGPT 3.5 Turbo as we
    did not have access to Gemini APIs. The flow is implemented in Python and will
    be made open source.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '利用工程师介入的案例研究经验，我们实现了一个免提 C2HLSC 原型。案例研究的第一个见解是生成的 C 代码中可能出现的双重错误性质——功能/编译错误和合成错误。前者可以通过
    gcc 捕捉到。后者可以通过运行 Catapult HLS 工具捕捉到。因此，我们设置了如图 [5](#S4.F5 "图 5 ‣ IV 免提 C2HSLC
    原型 ‣ C2HLSC: LLM 能否弥合软件到硬件设计的差距？") 所示的双重反馈循环。一个检查生成的代码是否编译和通过参考测试，另一个检查代码是否能被
    Catapult HLS 合成。我们选择了 ChatGPT 3.5 Turbo，因为我们没有访问 Gemini API。该流程用 Python 实现，并将开源发布。'
- en: '![Refer to caption](img/19db92c791fe51fe72eb734807f8f2b3.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![参见说明](img/19db92c791fe51fe72eb734807f8f2b3.png)'
- en: 'Figure 5: Hands-free C2HSLC LLM-based prototype flow.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5：免提 C2HSLC 基于 LLM 的原型流程。
- en: We ran the flow on the QuickSort and AES C codes used in the case study. In
    the current version, the flow can handle only a limited number of functions at
    a time and so for AES we broke the code down into the individual functions.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在案例研究中使用了 QuickSort 和 AES C 代码运行了该流程。在当前版本中，流程一次只能处理有限数量的函数，因此对于 AES，我们将代码拆分为各个函数。
- en: 'TABLE II: Hands-free C2HLSC LLM-based flow.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 表 II：免提 C2HLSC 基于 LLM 的流程。
- en: '| Design | # Prompts | Area Score | # Ops | Latency |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 设计 | # 提示 | 区域评分 | # 操作 | 延迟 |'
- en: '| QuickSort | 6 | 52184 | 1961 | 8 |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| QuickSort | 6 | 52184 | 1961 | 8 |'
- en: '| AddRoundKey | 9 | 702.3 | 837 | 210 |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| AddRoundKey | 9 | 702.3 | 837 | 210 |'
- en: '| ShiftRows | 1 | 23.9 | 3 | 0 |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| ShiftRows | 1 | 23.9 | 3 | 0 |'
- en: '| MixColumns | 1 | 635.9 | 225 | 6 |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| MixColumns | 1 | 635.9 | 225 | 6 |'
- en: '| SubBytes | 1 | 1176.5 | 53 | 33 |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| SubBytes | 1 | 1176.5 | 53 | 33 |'
- en: 'The flow was able to automatically rewrite the functions without any human
    intervention. We plan to expand it by allowing more functions at a time, and include
    better optimizations. The generated codes are in Appendix [-A](#A0.SS1 "-A LLM
    generated HLS compatible C codes ‣ C2HLSC: Can LLMs Bridge the Software-to-Hardware
    Design Gap?").'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '该流程能够在没有人工干预的情况下自动重写函数。我们计划通过允许同时处理更多函数并包含更好的优化来扩展它。生成的代码见附录 [-A](#A0.SS1 "-A
    LLM 生成的 HLS 兼容 C 代码 ‣ C2HLSC: LLM 能否弥合软件到硬件设计的差距？")。'
- en: V Conclusions
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: V 结论
- en: The case studies demonstrated the potential of LLMs in aiding HLS. The implemented
    prototype shows the potential of LLMs in aiding hardware design leveraging HLS.
    Future work includes the use of LLMs to discover architectural trade-offs by applying
    pragmas and directives. Together with the proposed flow, it will enable a seamless
    transition from C to HLS C to optimized hardware architectures.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 案例研究展示了 LLM 在帮助 HLS 方面的潜力。实施的原型展示了 LLM 在利用 HLS 帮助硬件设计方面的潜力。未来的工作包括使用 LLM 通过应用
    pragma 和指令发现架构权衡。结合提出的流程，这将实现从 C 到 HLS C 以及优化硬件架构的无缝过渡。
- en: References
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[1] R. Nane, V.-M. Sima, C. Pilato, J. Choi, B. Fort, A. Canis, Y. T. Chen,
    H. Hsiao, S. Brown, F. Ferrandi, J. Anderson, and K. Bertels, “A survey and evaluation
    of fpga high-level synthesis tools,” *IEEE Transactions on CAD*, vol. 35, no. 10,
    pp. 1591–1604, 2016.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[1] R. Nane, V.-M. Sima, C. Pilato, J. Choi, B. Fort, A. Canis, Y. T. Chen,
    H. Hsiao, S. Brown, F. Ferrandi, J. Anderson, 和 K. Bertels, “FPGA高级综合工具的调查与评估”，*IEEE
    CAD 交易期刊*，第35卷，第10期，第1591–1604页，2016年。'
- en: '[2] D. Soni, M. Nabeel, K. Basu, and R. Karri, “Power, area, speed, and security
    (pass) trade-offs of nist pqc signature candidates using a c to asic design flow,”
    in *IEEE International Conference on Computer Design*, 2019, pp. 337–340.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[2] D. Soni, M. Nabeel, K. Basu, 和 R. Karri, “使用C到ASIC设计流的NIST PQC签名候选者的功耗、面积、速度和安全性（PASS）权衡”，发表于*IEEE
    国际计算机设计会议*，2019年，第337–340页。'
- en: '[3] H. Pearce, B. Ahmad, B. Tan, B. Dolan-Gavitt, and R. Karri, “Asleep at
    the keyboard? assessing the security of github copilot’s code contributions,”
    in *IEEE Symposium on Security and Privacy*, 2022, pp. 754–768.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[3] H. Pearce, B. Ahmad, B. Tan, B. Dolan-Gavitt, 和 R. Karri, “在键盘上打盹？评估GitHub
    Copilot的代码贡献的安全性”，发表于*IEEE 安全与隐私研讨会*，2022年，第754–768页。'
- en: '[4] S. Thakur, B. Ahmad, H. Pearce, B. Tan, B. Dolan-Gavitt, R. Karri, and
    S. Garg, “Verigen: A large language model for verilog code generation,” *ACM Trans.
    Des. Autom. Electron. Syst.*, feb 2024, just Accepted. [Online]. Available: [https://doi.org/10.1145/3643681](https://doi.org/10.1145/3643681)'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[4] S. Thakur, B. Ahmad, H. Pearce, B. Tan, B. Dolan-Gavitt, R. Karri, 和 S.
    Garg, “Verigen: 一种用于Verilog代码生成的大型语言模型”，*ACM 设计自动化电子系统期刊*，2024年2月，刚刚接受。[在线]. 可用:
    [https://doi.org/10.1145/3643681](https://doi.org/10.1145/3643681)'
- en: '[5] J. Blocklove, S. Garg, R. Karri, and H. Pearce, “Chip-chat: Challenges
    and opportunities in conversational hardware design,” in *2023 ACM/IEEE 5th Workshop
    on Machine Learning for CAD (MLCAD)*, 2023, pp. 1–6.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[5] J. Blocklove, S. Garg, R. Karri, 和 H. Pearce, “Chip-chat: 交互硬件设计中的挑战与机遇”，发表于*2023
    ACM/IEEE 第五届计算机辅助设计机器学习研讨会（MLCAD）*，2023年，第1–6页。'
- en: '[6] J. T. Meech, “Leveraging high-level synthesis and large language models
    to generate, simulate, and deploy a uniform random number generator hardware design,”
    2024.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[6] J. T. Meech, “利用高级综合和大型语言模型生成、模拟和部署统一的随机数生成器硬件设计”，2024年。'
- en: '[7] “Bard: A large language model from google ai,” [https://blog.google/technology/ai/bard-google-ai-search-updates/](https://blog.google/technology/ai/bard-google-ai-search-updates/),
    accessed on 2024-04-06.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[7] “Bard: 来自Google AI的大型语言模型”，[https://blog.google/technology/ai/bard-google-ai-search-updates/](https://blog.google/technology/ai/bard-google-ai-search-updates/)，访问时间：2024-04-06。'
- en: '[8] “A statistical test suite for random and pseudorandom number generators
    for cryptographic applications (revision 1a),” April 2010, accessed on 2024-04-06\.
    [Online]. Available: [https://nvlpubs.nist.gov/nistpubs/legacy/sp/nistspecialpublication800-22r1a.pdf](https://nvlpubs.nist.gov/nistpubs/legacy/sp/nistspecialpublication800-22r1a.pdf)'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[8] “用于加密应用的随机和伪随机数生成器的统计测试套件（修订版1a）”，2010年4月，访问时间：2024-04-06。[在线]. 可用: [https://nvlpubs.nist.gov/nistpubs/legacy/sp/nistspecialpublication800-22r1a.pdf](https://nvlpubs.nist.gov/nistpubs/legacy/sp/nistspecialpublication800-22r1a.pdf)'
- en: '[9] GeeksforGeeks, “Quick sort in c,” [https://www.geeksforgeeks.org/quick-sort-in-c/](https://www.geeksforgeeks.org/quick-sort-in-c/),
    accessed on 2024-04-06.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[9] GeeksforGeeks, “C语言中的快速排序”，[https://www.geeksforgeeks.org/quick-sort-in-c/](https://www.geeksforgeeks.org/quick-sort-in-c/)，访问时间：2024-04-06。'
- en: '[10] K. [kokke], “tiny-aes-c,” [https://github.com/kokke/tiny-AES-c](https://github.com/kokke/tiny-AES-c),
    accessed on 2024-04-06.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[10] K. [kokke], “tiny-aes-c”，[https://github.com/kokke/tiny-AES-c](https://github.com/kokke/tiny-AES-c)，访问时间：2024-04-06。'
- en: '[11] HLSLibs, “Hlslibs - high-level synthesis libraries,” [https://hlslibs.org/](https://hlslibs.org/),
    accessed on 2024-04-06.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[11] HLSLibs, “Hlslibs - 高级综合库”，[https://hlslibs.org/](https://hlslibs.org/)，访问时间：2024-04-06。'
- en: -A LLM generated HLS compatible C codes
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '- 一个由LLM生成的与HLS兼容的C代码'
- en: In this section we report original codes and final codes of our case study.
    We cut print statements from the originals and comments from the results.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们报告了案例研究的原始代码和最终代码。我们从原始代码中删除了打印语句，从结果中删除了注释。
- en: '1Original  c  code  (after  removing  printf  s)  \end{lstlisting}2\vspace{-7pt}3  \end{subfigure}4  \begin{subfigure}[t]{.9\columnwidth}5  \begin{lstlisting}[language=c]6void  Frequency(int  n)7{8  int  i;9  double  f,  s_obs,  p_value,  sum,  sqrt2  =  1.41421356237309504880;10  sum  =  0.0;11  for  (  i=0;  i<n;  i++  )12  sum  +=  2*(int)epsilon[i]-1;13  s_obs  =  fabs(sum)/sqrt(n);14  f  =  s_obs/sqrt2;15  p_value  =  erfc(f);16}1HLS  compatible  code  rewritten  by  the  LLM1#define  TARGET_BITS  1282#define  P_VALUE_THRESHOLD  0.013#define  THRESHOLD  294typedef  ac_int<9,  true>  sum_type;  //  true  for  signed5typedef  ac_int<8,  false>  count_type;  //  false  for  unsigned6typedef  ac_int<1,  false>  bit_type;7void8Frequency_Bit(bit_type  *bit,  bit_type  *valid,  bit_type  *result)9{10  static  sum_type  sum  =  0;11  static  count_type  count  =  0;12  sum  +=  (*bit)  ?  sum_type(1)  :  sum_type(-1);13  count++;14  if  (count  ==  TARGET_BITS)  {15  //  Check  if  sum  is  within  the  threshold  range16  *result  =  (sum  <=  THRESHOLD)  &&  (sum  >=  -THRESHOLD);17  *valid  =  1;18  count  =  0;19  sum  =  0;20  }  else  {21  *result  =  0;22  *valid  =  0;23}}'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '1原始c代码（去除printf语句后）\end{lstlisting}2\vspace{-7pt}3\end{subfigure}4\begin{subfigure}[t]{.9\columnwidth}5\begin{lstlisting}[language=c]6void
    Frequency(int n)7{8  int i;9  double f, s_obs, p_value, sum, sqrt2 = 1.41421356237309504880;10  sum
    = 0.0;11  for (i=0; i<n; i++)12  sum += 2*(int)epsilon[i]-1;13  s_obs = fabs(sum)/sqrt(n);14  f
    = s_obs/sqrt2;15  p_value = erfc(f);16}1HLS兼容代码由LLM重写1#define TARGET_BITS 1282#define
    P_VALUE_THRESHOLD 0.013#define THRESHOLD 294typedef ac_int<9, true> sum_type;  //
    true表示有符号5typedef ac_int<8, false> count_type;  // false表示无符号6typedef ac_int<1,
    false> bit_type;7void8Frequency_Bit(bit_type *bit, bit_type *valid, bit_type *result)9{10  static
    sum_type sum = 0;11  static count_type count = 0;12  sum += (*bit) ? sum_type(1)
    : sum_type(-1);13  count++;14  if (count == TARGET_BITS) {15  // 检查sum是否在阈值范围内16  *result
    = (sum <= THRESHOLD) && (sum >= -THRESHOLD);17  *valid = 1;18  count = 0;19  sum
    = 0;20  } else {21  *result = 0;22  *valid = 0;23}}'
- en: 'Figure 6: Human-in-the-loop Monobit'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图6：人机协作单比特
- en: '1Original  c  code  (after  removing  printf  s)  \end{lstlisting}2\vspace{-7pt}3  \end{subfigure}4  \begin{subfigure}[t]{.9\columnwidth}5  \begin{lstlisting}[language=c]6void  BlockFrequency(int  M,  int  n)7{8  int  i,  j,  N,  blockSum;9  double  p_value,  sum,  pi,  v,  chi_squared;10  N  =  n/M;  /*  #  OF  SUBSTRING  BLOCKS  */11  sum  =  0.0;1213  for  (  i=0;  i<N;  i++  )  {14  blockSum  =  0;15  for  (  j=0;  j<M;  j++  )16  blockSum  +=  epsilon[j+i*M];17  pi  =  (double)blockSum/(double)M;18  v  =  pi  -  0.5;19  sum  +=  v*v;20  }21  chi_squared  =  4.0  *  M  *  sum;22  p_value  =  cephes_igamc(N/2.0,  chi_squared/2.0);23}1HLS  compatible  code  rewritten  by  the  LLM1void  BlockFrequency(ac_int<1,  false>  bit,  ac_int<1,  false>&  valid,  ac_int<1,  false>&  result)  {2  static  ac_int<7,  false>  blockSum  =  0;3  static  ac_fixed<16,  8,  false>  sum  =  0.0;4  ac_fixed<8,  4,  false>  pi_fixed,  v;5  static  ac_int<4,  false>  i  =  0;6  static  ac_int<8,  false>  j  =  0;7  if  (j  ==  0)  {8  i++;9  blockSum  =  0;10  }11  blockSum  +=  bit;12  j++;13  if  (j  ==  BLOCK_SIZE)  {14  pi_fixed  =  (ac_fixed<12,  4,  false>)  blockSum  /  BLOCK_SIZE;15  const  ac_fixed<8,  4,  false>  half  =  0.5;16  v  =  pi_fixed  -  half;17  sum  +=  v  *  v;18  j  =  0;19  }20  if  (i  ==  NUM_BLOCKS)  {21  const  ac_fixed<16,  8,  false>  threshold  =  13.8155  /  512.0;22  valid  =  true;23  result  =  (sum  <  threshold)  ?  0  :  1;24  }  else  {25  valid  =  false;26  result  =  0;27}}'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '1原始c代码（去除printf语句后）\end{lstlisting}2\vspace{-7pt}3\end{subfigure}4\begin{subfigure}[t]{.9\columnwidth}5\begin{lstlisting}[language=c]6void
    BlockFrequency(int M, int n)7{8  int i, j, N, blockSum;9  double p_value, sum,
    pi, v, chi_squared;10  N = n/M;  /* 子字符串块的数量 */11  sum = 0.0;1213  for (i=0; i<N;
    i++) {14  blockSum = 0;15  for (j=0; j<M; j++)16  blockSum += epsilon[j+i*M];17  pi
    = (double)blockSum/(double)M;18  v = pi - 0.5;19  sum += v*v;20  }21  chi_squared
    = 4.0 * M * sum;22  p_value = cephes_igamc(N/2.0, chi_squared/2.0);23}1HLS兼容代码由LLM重写1void
    BlockFrequency(ac_int<1, false> bit, ac_int<1, false>& valid, ac_int<1, false>&
    result) {2  static ac_int<7, false> blockSum = 0;3  static ac_fixed<16, 8, false>
    sum = 0.0;4  ac_fixed<8, 4, false> pi_fixed, v;5  static ac_int<4, false> i =
    0;6  static ac_int<8, false> j = 0;7  if (j == 0) {8  i++;9  blockSum = 0;10  }11  blockSum
    += bit;12  j++;13  if (j == BLOCK_SIZE) {14  pi_fixed = (ac_fixed<12, 4, false>)
    blockSum / BLOCK_SIZE;15  const ac_fixed<8, 4, false> half = 0.5;16  v = pi_fixed
    - half;17  sum += v * v;18  j = 0;19  }20  if (i == NUM_BLOCKS) {21  const ac_fixed<16,
    8, false> threshold = 13.8155 / 512.0;22  valid = true;23  result = (sum < threshold)
    ? 0 : 1;24  } else {25  valid = false;26  result = 0;27}}'
- en: 'Figure 7: Human-in-the-loop Monobit Block'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图7：人机协作单比特块
- en: '1Original  c  code  (after  removing  printf  s)  \end{lstlisting}2\vspace{-7pt}3  \end{subfigure}4  \begin{subfigure}[t]{.9\columnwidth}5  \begin{lstlisting}[language=c]6void  CumulativeSums(int  n)  {7  int  S,  sup,  inf,  z,  zrev,  k;8  double  sum1,  sum2,  p_value;9  S  =  0;  sup  =  0;  inf  =  0;10  for  (k  =  0;  k  <  n;  k++)  {11  epsilon[k]  ?  S++  :  S--;12  if  (S  >  sup)  sup++;13  if  (S  <  inf)  inf--;14  z  =  (sup  >  -inf)  ?  sup  :  -inf;15  zrev  =  (sup  -  S  >  S  -  inf)  ?  sup  -  S  :  S  -  inf;}16  sum1  =  0.0;  //  forward17  for  (k  =  (-n  /  z  +  1)  /  4;  k  <=  (n  /  z  -  1)  /  4;  k++)  {18  sum1  +=  cephes_normal(((4  *  k  +  1)  *  z)  /  sqrt(n));19  sum1  -=  cephes_normal(((4  *  k  -  1)  *  z)  /  sqrt(n));}20  sum2  =  0.0;21  for  (k  =  (-n  /  z  -  3)  /  4;  k  <=  (n  /  z  -  1)  /  4;  k++)  {22  sum2  +=  cephes_normal(((4  *  k  +  3)  *  z)  /  sqrt(n));23  sum2  -=  cephes_normal(((4  *  k  +  1)  *  z)  /  sqrt(n));}24  p_value  =  1.0  -  sum1  +  sum2;25  sum1  =  0.0;  //  backwards26  for  (k  =  (-n  /  zrev  +  1)  /  4;  k  <=  (n  /  zrev  -  1)  /  4;  k++)  {27  sum1  +=  cephes_normal(((4  *  k  +  1)  *  zrev)  /  sqrt(n));28  sum1  -=  cephes_normal(((4  *  k  -  1)  *  zrev)  /  sqrt(n));}29  sum2  =  0.0;30  for  (k  =  (-n  /  zrev  -  3)  /  4;  k  <=  (n  /  zrev  -  1)  /  4;  k++)  {31  sum2  +=  cephes_normal(((4  *  k  +  3)  *  zrev)  /  sqrt(n));32  sum2  -=  cephes_normal(((4  *  k  +  1)  *  zrev)  /  sqrt(n));}33  p_value  =  1.0  -  sum1  +  sum2;}1HLS  compatible  code  rewritten  by  the  LLM1#define  N  200002#define  THRESHOLD  (ac_int<12,  false>)3973void  CumulativeSums_Streaming(ac_int<1,  false>  bit,  ac_int<1,  false>*  output,  ac_int<1,  false>*  valid)  {4  static  ac_int<12,  false>  S  =  0;5  static  ac_int<12,  false>  sup  =  0;6  static  ac_int<12,  false>  inf  =  0;7  S  +=  bit  ?  1  :  -1;8  sup  =  sup  >  S  ?  sup  :  S;9  inf  =  inf  <  S  ?  inf  :  S;10  //  Logic  for  output  based  on  sup  and  inf11  static  ac_int<16,  false>  processed_bits  =  0;12  processed_bits++;13  if  (processed_bits  ==  N)  {14  *output  =  (sup  <  THRESHOLD  &&  inf  >  -THRESHOLD)  ?  1  :  0;15  *valid  =  (processed_bits  ==  N);16  processed_bits  =  0;17  }  else  {18  *output  =  0;19  *valid  =  0;20}}'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '1 原始  c  代码  （去除 printf 后） \end{lstlisting}2\vspace{-7pt}3 \end{subfigure}4
    \begin{subfigure}[t]{.9\columnwidth}5 \begin{lstlisting}[language=c]6void  CumulativeSums(int  n)  {7  int  S,  sup,  inf,  z,  zrev,  k;8  double  sum1,  sum2,  p_value;9  S  =  0;  sup  =  0;  inf  =  0;10  for  (k  =  0;  k  <  n;  k++)  {11  epsilon[k]  ?  S++  :  S--;12  if  (S  >  sup)  sup++;13  if  (S  <  inf)  inf--;14  z  =  (sup  >  -inf)  ?  sup  :  -inf;15  zrev  =  (sup  -  S  >  S  -  inf)  ?  sup  -  S  :  S  -  inf;}16  sum1  =  0.0;  //  向前17  for  (k  =  (-n  /  z  +  1)  /  4;  k  <=  (n  /  z  -  1)  /  4;  k++)  {18  sum1  +=  cephes_normal(((4  *  k  +  1)  *  z)  /  sqrt(n));19  sum1  -=  cephes_normal(((4  *  k  -  1)  *  z)  /  sqrt(n));}20  sum2  =  0.0;21  for  (k  =  (-n  /  z  -  3)  /  4;  k  <=  (n  /  z  -  1)  /  4;  k++)  {22  sum2  +=  cephes_normal(((4  *  k  +  3)  *  z)  /  sqrt(n));23  sum2  -=  cephes_normal(((4  *  k  +  1)  *  z)  /  sqrt(n));}24  p_value  =  1.0  -  sum1  +  sum2;25  sum1  =  0.0;  //  向后26  for  (k  =  (-n  /  zrev  +  1)  /  4;  k  <=  (n  /  zrev  -  1)  /  4;  k++)  {27  sum1  +=  cephes_normal(((4  *  k  +  1)  *  zrev)  /  sqrt(n));28  sum1  -=  cephes_normal(((4  *  k  -  1)  *  zrev)  /  sqrt(n));}29  sum2  =  0.0;30  for  (k  =  (-n  /  zrev  -  3)  /  4;  k  <=  (n  /  zrev  -  1)  /  4;  k++)  {31  sum2  +=  cephes_normal(((4  *  k  +  3)  *  zrev)  /  sqrt(n));32  sum2  -=  cephes_normal(((4  *  k  +  1)  *  zrev)  /  sqrt(n));}33  p_value  =  1.0  -  sum1  +  sum2;}1
    HLS  兼容  代码  由  LLM1  重写#define  N  200002#define  THRESHOLD  (ac_int<12,  false>)3973void  CumulativeSums_Streaming(ac_int<1,  false>  bit,  ac_int<1,  false>*  output,  ac_int<1,  false>*  valid)  {4  static  ac_int<12,  false>  S  =  0;5  static  ac_int<12,  false>  sup  =  0;6  static  ac_int<12,  false>  inf  =  0;7  S  +=  bit  ?  1  :  -1;8  sup  =  sup  >  S  ?  sup  :  S;9  inf  =  inf  <  S  ?  inf  :  S;10  //  基于  sup  和  inf  的  输出
    逻辑11  static  ac_int<16,  false>  processed_bits  =  0;12  processed_bits++;13  if  (processed_bits  ==  N)  {14  *output  =  (sup  <  THRESHOLD  &&  inf  >  -THRESHOLD)  ?  1  :  0;15  *valid  =  (processed_bits  ==  N);16  processed_bits  =  0;17  }  else  {18  *output  =  0;19  *valid  =  0;20}}'
- en: 'Figure 8: Human-in-the-loop Cusums'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8：人类在回路中的 Cusums
- en: 1Original  c  code  (after  removing  printf  s)  \end{lstlisting}2\vspace{-7pt}3  \end{subfigure}4  \begin{subfigure}[t]{.9\columnwidth}5  \begin{lstlisting}[language=c]6void  OverlappingTemplateMatchings(int  m,  int  n)7{8int  i,  k,  match;9double  W_obs,  eta,  sum,  chi2,  p_value,  lambda;10int  M,  N,  j,  K  =  5;11unsigned  int  nu[6]  =  {  0,  0,  0,  0,  0,  0  };12//double  pi[6]  =  {  0.143783,  0.139430,  0.137319,  0.124314,  0.106209,  0.348945  };13double  pi[6]  =  {  0.364091,  0.185659,  0.139381,  0.100571,  0.0704323,  0.139865  };14BitSequence  *sequence;15M  =  1032;16N  =  n/M;17if  (  (sequence  =  (BitSequence  *)  calloc(m,  sizeof(BitSequence)))  ==  NULL  )  {18  //  ERROR19}20else21  for  (  i=0;  i<m;  i++  )22  sequence[i]  =  1;23lambda  =  (double)(M-m+1)/pow(2,m);24eta  =  lambda/2.0;25sum  =  0.0;26for  (  i=0;  i<K;  i++  )  {  /*  Compute  Probabilities  */27  pi[i]  =  Pr(i,  eta);28  sum  +=  pi[i];29}30pi[K]  =  1  -  sum;3132for  (  i=0;  i<N;  i++  )  {33  W_obs  =  0;34  for  (  j=0;  j<M-m+1;  j++  )  {35  match  =  1;36  for  (  k=0;  k<m;  k++  )  {37  if  (  sequence[k]  !=  epsilon[i*M+j+k]  )38  match  =  0;39  }40  if  (  match  ==  1  )41  W_obs++;42  }43  if  (  W_obs  <=  4  )44  nu[(int)W_obs]++;45  else46  nu[K]++;47}48sum  =  0;49chi2  =  0.0;  /*  Compute  Chi  Square  */50for  (  i=0;  i<K+1;  i++  )  {51  chi2  +=  pow((double)nu[i]  -  (double)N*pi[i],  2)/((double)N*pi[i]);52  sum  +=  nu[i];53}54p_value  =  cephes_igamc(K/2.0,  chi2/2.0);55}
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 1原始  c  代码  （去除 printf 后） \end{lstlisting}2\vspace{-7pt}3  \end{subfigure}4  \begin{subfigure}[t]{.9\columnwidth}5  \begin{lstlisting}[language=c]6void  OverlappingTemplateMatchings(int  m,  int  n)7{8int  i,  k,  match;9double  W_obs,  eta,  sum,  chi2,  p_value,  lambda;10int  M,  N,  j,  K  =  5;11unsigned  int  nu[6]  =  {  0,  0,  0,  0,  0,  0  };12//double  pi[6]  =  {  0.143783,  0.139430,  0.137319,  0.124314,  0.106209,  0.348945  };13double  pi[6]  =  {  0.364091,  0.185659,  0.139381,  0.100571,  0.0704323,  0.139865  };14BitSequence  *sequence;15M  =  1032;16N  =  n/M;17if  (  (sequence  =  (BitSequence  *)  calloc(m,  sizeof(BitSequence)))  ==  NULL  )  {18  //  错误19}20else21  for  (  i=0;  i<m;  i++  )22  sequence[i]  =  1;23lambda  =  (double)(M-m+1)/pow(2,m);24eta  =  lambda/2.0;25sum  =  0.0;26for  (  i=0;  i<K;  i++  )  {  /*  计算  概率  */27  pi[i]  =  Pr(i,  eta);28  sum  +=  pi[i];29}30pi[K]  =  1  -  sum;3132for  (  i=0;  i<N;  i++  )  {33  W_obs  =  0;34  for  (  j=0;  j<M-m+1;  j++  )  {35  match  =  1;36  for  (  k=0;  k<m;  k++  )  {37  if  (  sequence[k]  !=  epsilon[i*M+j+k]  )38  match  =  0;39  }40  if  (  match  ==  1  )41  W_obs++;42  }43  if  (  W_obs  <=  4  )44  nu[(int)W_obs]++;45  else46  nu[K]++;47}48sum  =  0;49chi2  =  0.0;  /*  计算  卡方  */50for  (  i=0;  i<K+1;  i++  )  {51  chi2  +=  pow((double)nu[i]  -  (double)N*pi[i],  2)/((double)N*pi[i]);52  sum  +=  nu[i];53}54p_value  =  cephes_igamc(K/2.0,  chi2/2.0);55}
- en: 'Figure 9: Overlapping Original'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9：重叠的原始
- en: 1HLS  compatible  code  rewritten  by  the  LLM1#define  N  10485762#define  M  10323#define  N_WIDTH  204#define  M_WIDTH  105#define  CHI2_THRESHOLD_FIXED  ac_fixed<21,  21,  false>(1056300.0)6void  OverlappingTemplateMatchings(int  epsilon,  ac_int<1,  false>  *is_random_out,  ac_int<1,  false>  *valid_output_out)  {7  static  ac_int<9,  false>  W_obs  =  0;8  static  ac_int<10,  false>  nu[6]  =  {0,  0,  0,  0,  0,  0};9  static  ac_int<9,  false>  shift_reg[9]  =  {0};10  static  ac_int<N_WIDTH+1,  false>  n_counter  =  0;11  static  const  ac_fixed<32,  16,  false>  pi[6]  =  {12  2.746566,13  ac_fixed<32,  16,  false>(5.386218),  ac_fixed<32,  16,  false>(7.17457),14  ac_fixed<32,  16,  false>(9.94322),  ac_fixed<32,  16,  false>(14.198031),  ac_fixed<32,  16,  false>(7.1497515)15  };16ac_fixed<23,  22>  chi2  =  0;17  for  (int  i  =  8;  i  >  0;  i--)  {18  shift_reg[i]  =  shift_reg[i  -  1];19  }20  shift_reg[0]  =  ac_int<1,  false>(epsilon);21  ac_int<1,  false>  match  =  1;22  for  (int  i  =  0;  i  <  9;  i++)  {23  if  (shift_reg[i]  !=  1)  {24  match  =  0;25  break;26  }27  }28  if  (match)  {29  W_obs++;30  }31  n_counter++;32  if  (n_counter  %  M  ==  M-1)  {33  if  (W_obs  <=  4)  {34  nu[(int)W_obs]++;35  }  else  {36  nu[5]++;37  }38  W_obs  =  0;39  }40  *is_random_out  =  0;41  *valid_output_out  =  0;42  if  (n_counter  ==  N)  {43  for  (int  i  =  0;  i  <  6;  i++)  {44  chi2  +=  nu[i]  *  nu  [i]  *  pi[i];45  }46  *is_random_out  =  chi2  <  CHI2_THRESHOLD_FIXED;47  *valid_output_out  =  true;48  for  (int  i  =  0;  i  <  6;  i++)  {49  nu[i]  =  0;50  }51  n_counter  =  0;52}}
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 1HLS兼容代码，由LLM重写1#define N 10485762#define M 10323#define N_WIDTH 204#define
    M_WIDTH 105#define CHI2_THRESHOLD_FIXED ac_fixed<21, 21, false>(1056300.0)6void
    OverlappingTemplateMatchings(int epsilon, ac_int<1, false> *is_random_out, ac_int<1,
    false> *valid_output_out) {7  static ac_int<9, false> W_obs = 0;8  static ac_int<10,
    false> nu[6] = {0, 0, 0, 0, 0, 0};9  static ac_int<9, false> shift_reg[9] = {0};10  static
    ac_int<N_WIDTH+1, false> n_counter = 0;11  static const ac_fixed<32, 16, false>
    pi[6] = {12  2.746566,13  ac_fixed<32, 16, false>(5.386218), ac_fixed<32, 16,
    false>(7.17457),14  ac_fixed<32, 16, false>(9.94322), ac_fixed<32, 16, false>(14.198031),
    ac_fixed<32, 16, false>(7.1497515)15  };16ac_fixed<23, 22> chi2 = 0;17  for (int
    i = 8; i > 0; i--) {18  shift_reg[i] = shift_reg[i - 1];19  }20  shift_reg[0]
    = ac_int<1, false>(epsilon);21  ac_int<1, false> match = 1;22  for (int i = 0;
    i < 9; i++) {23  if (shift_reg[i] != 1) {24  match = 0;25  break;26  }27  }28  if
    (match) {29  W_obs++;30  }31  n_counter++;32  if (n_counter % M == M-1) {33  if
    (W_obs <= 4) {34  nu[(int)W_obs]++;35  }  else  {36  nu[5]++;37  }38  W_obs =
    0;39  }40  *is_random_out = 0;41  *valid_output_out = 0;42  if (n_counter == N)
    {43  for (int i = 0; i < 6; i++) {44  chi2 += nu[i] * nu[i] * pi[i];45  }46  *is_random_out
    = chi2 < CHI2_THRESHOLD_FIXED;47  *valid_output_out = true;48  for (int i = 0;
    i < 6; i++) {49  nu[i] = 0;50  }51  n_counter = 0;52}}
- en: 'Figure 10: Human-in-the-loop Overlapping'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '图 10: 人工环节重叠'
- en: 1Original  c  code  (after  removing  printf  s)  \end{lstlisting}2\vspace{-7pt}3  \end{subfigure}4  \begin{subfigure}[t]{.9\columnwidth}5  \begin{lstlisting}[language=c]6void  swap(int*  a,  int*  b)  {7  int  temp  =  *a;8  *a  =  *b;9  *b  =  temp;  }10  int  partition(int  arr[],  int  low,  int  high)  {11  int  pivot  =  arr[low];12  int  i  =  low;13  int  j  =  high;14  while  (i  <  j)  {15  while  (arr[i]  <=  pivot  &&  i  <=  high  -  1)  {16  i++;17  }18  while  (arr[j]  >  pivot  &&  j  >=  low  +  1)  {19  j--;20  }21  if  (i  <  j)  {22  swap(&arr[i],  &arr[j]);23  }24  }25  swap(&arr[low],  &arr[j]);26  return  j;  }27void  quickSort(int  arr[],  int  low,  int  high)  {28  if  (low  <  high)  {29  int  partitionIndex  =  partition(arr,  low,  high);30  quickSort(arr,  low,  partitionIndex  -  1);31  quickSort(arr,  partitionIndex  +  1,  high);32}  }
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 1原始c代码（去掉printf后）\end{lstlisting}2\vspace{-7pt}3\end{subfigure}4\begin{subfigure}[t]{.9\columnwidth}5\begin{lstlisting}[language=c]6void
    swap(int* a, int* b) {7  int temp = *a;8  *a = *b;9  *b = temp;  }10  int partition(int
    arr[], int low, int high) {11  int pivot = arr[low];12  int i = low;13  int j
    = high;14  while (i < j) {15  while (arr[i] <= pivot && i <= high - 1) {16  i++;17  }18  while
    (arr[j] > pivot && j >= low + 1) {19  j--;20  }21  if (i < j) {22  swap(&arr[i],
    &arr[j]);23  }24  }25  swap(&arr[low], &arr[j]);26  return j;  }27void quickSort(int
    arr[], int low, int high) {28  if (low < high) {29  int partitionIndex = partition(arr,
    low, high);30  quickSort(arr, low, partitionIndex - 1);31  quickSort(arr, partitionIndex
    + 1, high);32}  }
- en: 'Figure 11: Quicksort original'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '图 11: 快速排序原始'
- en: 1HLS  compatible  code  rewritten  by  the  LLM1int  partition(int  arr[MAX_SIZE],  int  low,  int  high)  {}2  int  pivot  =  arr[low];3  int  i  =  low;4  int  j  =  high;5  if  (low  ==  high)  {6  return  low;7  }8  while  (i  <  j)  {9  while  (arr[i]  <=  pivot  &&  i  <=  high  -  1)  {10  i++;11  }12  while  (arr[j]  >  pivot  &&  j  >=  low  +  1)  {13  j--;14  }15  if  (i  <  j)  {16  int  temp  =  arr[i];17  arr[i]  =  arr[j];18  arr[j]  =  temp;19  }20  }21  int  temp  =  arr[low];22  arr[low]  =  arr[j];23  arr[j]  =  temp;24  return  j;25}26void  quickSort(int  arr[MAX_SIZE],  int  low,  int  high)  {27int  stack[100];28int  top  =  -1;29if  (high  -  low  +  1  >  MAX_SIZE)  {30  return;31}32stack[++top]  =  low;33stack[++top]  =  high;34while  (top  >=  0)  {35  high  =  stack[top--];36  low  =  stack[top--];37  int  partitionIndex  =  partition(arr,  low,  high);38  if  (partitionIndex  +  1  <  high)  {39  stack[++top]  =  partitionIndex  +  1;40  stack[++top]  =  high;41  }42  if  (low  <  partitionIndex  -  1)  {43  stack[++top]  =  low;44  stack[++top]  =  partitionIndex  -  1;45}}}
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 1HLS 兼容代码由 LLM1int 重写 partition(int arr[MAX_SIZE], int low, int high) {}2 int
    pivot = arr[low];3 int i = low;4 int j = high;5 if (low == high) {6 return low;7
    }8 while (i < j) {9 while (arr[i] <= pivot && i <= high - 1) {10 i++;11 }12 while
    (arr[j] > pivot && j >= low + 1) {13 j--;14 }15 if (i < j) {16 int temp = arr[i];17
    arr[i] = arr[j];18 arr[j] = temp;19 }20 }21 int temp = arr[low];22 arr[low] =
    arr[j];23 arr[j] = temp;24 return j;25}26void quickSort(int arr[MAX_SIZE], int
    low, int high) {27int stack[100];28int top = -1;29if (high - low + 1 > MAX_SIZE)
    {30 return;31}32stack[++top] = low;33stack[++top] = high;34while (top >= 0) {35
    high = stack[top--];36 low = stack[top--];37 int partitionIndex = partition(arr,
    low, high);38 if (partitionIndex + 1 < high) {39 stack[++top] = partitionIndex
    + 1;40 stack[++top] = high;41 }42 if (low < partitionIndex - 1) {43 stack[++top]
    = low;44 stack[++top] = partitionIndex - 1;45}}}
- en: 'Figure 12: Human-in-the-loop Quicksort'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12：人机交互快速排序
- en: 1Original  c  code  (after  removing  printf  s)  \end{lstlisting}2\vspace{-7pt}3  \end{subfigure}4  \begin{subfigure}[t]{.9\columnwidth}5  \begin{lstlisting}[language=c]6static  void  Cipher(state_t*  state,  const  uint8_t*  RoundKey)7{8  uint8_t  round  =  0;9  AddRoundKey(0,  state,  RoundKey);10  for  (round  =  1;  ;  ++round)11  {12  SubBytes(state);13  ShiftRows(state);14  if  (round  ==  Nr)  {15  break;16  }17  MixColumns(state);18  AddRoundKey(round,  state,  RoundKey);19  }20  AddRoundKey(Nr,  state,  RoundKey);21}1HLS  compatible  code  rewritten  by  the  LLM1void  Cipher(state_t  state[4][4],  const  uint8_t  RoundKey[AES_keyExpSize])  {2  uint8_t  round;3  AddRoundKey(0,  state,  RoundKey);4  for  (round  =  1;  round  <=  Nr;  ++round)  {5  SubBytes(state);6  ShiftRows(state);7  if  (round  <  Nr)  {8  MixColumns(state);9  }10  AddRoundKey(round,  state,  RoundKey);11  }12}
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 1原始 C 代码（移除 printf 后） \end{lstlisting}2\vspace{-7pt}3 \end{subfigure}4 \begin{subfigure}[t]{.9\columnwidth}5
    \begin{lstlisting}[language=c]6static void Cipher(state_t* state, const uint8_t*
    RoundKey)7{8 uint8_t round = 0;9 AddRoundKey(0, state, RoundKey);10 for (round
    = 1; ; ++round)11 {12 SubBytes(state);13 ShiftRows(state);14 if (round == Nr)
    {15 break;16 }17 MixColumns(state);18 AddRoundKey(round, state, RoundKey);19 }20
    AddRoundKey(Nr, state, RoundKey);21}1HLS 兼容代码由 LLM1 重写2void Cipher(state_t state[4][4],
    const uint8_t RoundKey[AES_keyExpSize]) {3 uint8_t round;4 AddRoundKey(0, state,
    RoundKey);5 for (round = 1; round <= Nr; ++round) {6 SubBytes(state);7 ShiftRows(state);8
    if (round < Nr) {9 MixColumns(state);10 }11 AddRoundKey(round, state, RoundKey);12
    }}
- en: 'Figure 13: Human-in-the-loop AES Cipher'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13：人机交互 AES 加密算法
- en: 1Original  c  code  (after  removing  printf  s)  \end{lstlisting}2\vspace{-7pt}3  \end{subfigure}4  \begin{subfigure}[t]{.9\columnwidth}5  \begin{lstlisting}[language=c]6static  void  MixColumns(state_t*  state)7{8  uint8_t  i;9  uint8_t  Tmp,  Tm,  t;10  for  (i  =  0;  i  <  4;  ++i)11  {12  t  =  (*state)[i][0];13  Tmp  =  (*state)[i][0]  ^  (*state)[i][1]  ^  (*state)[i][2]  ^  (*state)[i][3]  ;14  Tm  =  (*state)[i][0]  ^  (*state)[i][1]  ;15  Tm  =  xtime(Tm);  (*state)[i][0]  ^=  Tm  ^  Tmp  ;16  Tm  =  (*state)[i][1]  ^  (*state)[i][2]  ;17  Tm  =  xtime(Tm);  (*state)[i][1]  ^=  Tm  ^  Tmp  ;18  Tm  =  (*state)[i][2]  ^  (*state)[i][3]  ;19  Tm  =  xtime(Tm);  (*state)[i][2]  ^=  Tm  ^  Tmp  ;20  Tm  =  (*state)[i][3]  ^  t  ;21  Tm  =  xtime(Tm);  (*state)[i][3]  ^=  Tm  ^  Tmp  ;22  }23}1HLS  compatible  code  rewritten  by  the  LLM1static  void  MixColumns(state_t  state[4][4])  {2  uint8_t  i,  Tmp,  Tm,  t;3  for  (i  =  0;  i  <  4;  ++i)  {4  t  =  state[i][0];5  Tmp  =  state[i][0]  ^  state[i][1]  ^  state[i][2]  ^  state[i][3];6  Tm  =  state[i][0]  ^  state[i][1];  Tm  =  xtime(Tm);7  state[i][0]  ^=  Tm  ^  Tmp;89  //  Corrected  lines  with  direct  array  access10  Tm  =  state[i][1]  ^  state[i][2];  Tm  =  xtime(Tm);11  state[i][1]  ^=  Tm  ^  Tmp;12  Tm  =  state[i][2]  ^  state[i][3];  Tm  =  xtime(Tm);13  state[i][2]  ^=  Tm  ^  Tmp;14  Tm  =  state[i][3]  ^  t;  Tm  =  xtime(Tm);15  state[i][3]  ^=  Tm  ^  Tmp;16  }17}
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 1原始  c  代码  （移除  printf  后）\end{lstlisting}2\vspace{-7pt}3  \end{subfigure}4  \begin{subfigure}[t]{.9\columnwidth}5  \begin{lstlisting}[language=c]6static  void  MixColumns(state_t*  state)7{8  uint8_t  i;9  uint8_t  Tmp,  Tm,  t;10  for  (i  =  0;  i  <  4;  ++i)11  {12  t  =  (*state)[i][0];13  Tmp  =  (*state)[i][0]  ^  (*state)[i][1]  ^  (*state)[i][2]  ^  (*state)[i][3];14  Tm  =  (*state)[i][0]  ^  (*state)[i][1];15  Tm  =  xtime(Tm);  (*state)[i][0]  ^=  Tm  ^  Tmp;16  Tm  =  (*state)[i][1]  ^  (*state)[i][2];17  Tm  =  xtime(Tm);  (*state)[i][1]  ^=  Tm  ^  Tmp;18  Tm  =  (*state)[i][2]  ^  (*state)[i][3];19  Tm  =  xtime(Tm);  (*state)[i][2]  ^=  Tm  ^  Tmp;20  Tm  =  (*state)[i][3]  ^  t;21  Tm  =  xtime(Tm);  (*state)[i][3]  ^=  Tm  ^  Tmp;22  }23}1HLS  兼容  代码  由  LLM  重写1static  void  MixColumns(state_t  state[4][4])  {2  uint8_t  i,  Tmp,  Tm,  t;3  for  (i  =  0;  i  <  4;  ++i)  {4  t  =  state[i][0];5  Tmp  =  state[i][0]  ^  state[i][1]  ^  state[i][2]  ^  state[i][3];6  Tm  =  state[i][0]  ^  state[i][1];  Tm  =  xtime(Tm);7  state[i][0]  ^=  Tm  ^  Tmp;89  //  修正  了  直接  数组  访问的  行10  Tm  =  state[i][1]  ^  state[i][2];  Tm  =  xtime(Tm);11  state[i][1]  ^=  Tm  ^  Tmp;12  Tm  =  state[i][2]  ^  state[i][3];  Tm  =  xtime(Tm);13  state[i][2]  ^=  Tm  ^  Tmp;14  Tm  =  state[i][3]  ^  t;  Tm  =  xtime(Tm);15  state[i][3]  ^=  Tm  ^  Tmp;16  }17}
- en: 'Figure 14: Human-in-the-loop AES Mix Columns'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14：人机协作 AES Mix Columns
- en: 1Original  c  code  (after  removing  printf  s)  \end{lstlisting}2\vspace{-7pt}3  \end{subfigure}4  \begin{subfigure}[t]{.9\columnwidth}5  \begin{lstlisting}[language=c]6static  void  ShiftRows(state_t*  state)7{8  uint8_t  temp;910  //  Rotate  first  row  1  columns  to  left11  temp  =  (*state)[0][1];12  (*state)[0][1]  =  (*state)[1][1];13  (*state)[1][1]  =  (*state)[2][1];14  (*state)[2][1]  =  (*state)[3][1];15  (*state)[3][1]  =  temp;1617  //  Rotate  second  row  2  columns  to  left18  temp  =  (*state)[0][2];19  (*state)[0][2]  =  (*state)[2][2];20  (*state)[2][2]  =  temp;2122  temp  =  (*state)[1][2];23  (*state)[1][2]  =  (*state)[3][2];24  (*state)[3][2]  =  temp;2526  //  Rotate  third  row  3  columns  to  left27  temp  =  (*state)[0][3];28  (*state)[0][3]  =  (*state)[3][3];29  (*state)[3][3]  =  (*state)[2][3];30  (*state)[2][3]  =  (*state)[1][3];31  (*state)[1][3]  =  temp;32}1HLS  compatible  code  rewritten  by  the  LLM1static  void  ShiftRows(state_t  state[4][4])  {2  uint8_t  temp;3  int  i,  j;45  //  Loop  over  rows  1  to  3  (0-based  indexing)6  for  (i  =  1;  i  <  4;  ++i)  {7  //  Number  of  positions  to  left  shift  for  current  row8  int  shift  =  i;910  //  Use  a  separate  loop  for  the  number  of  shifts11  for  (j  =  0;  j  <  shift;  ++j)  {12  temp  =  state[0][i];  //  Store  the  element  to  be  shifted13  //  Shift  all  elements  by  one  position  to  the  left14  for  (int  k  =  0;  k  <  3;  ++k)  {15  state[k][i]  =  state[k  +  1][i];16  }17  state[3][i]  =  temp;  //  Place  the  temp  value  at  the  end18  }19  }20}
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 1 原始的 `c` 代码（去除 `printf`） \end{lstlisting}2\vspace{-7pt}3 \end{subfigure}4 \begin{subfigure}[t]{.9\columnwidth}5
    \begin{lstlisting}[language=c]6static void ShiftRows(state_t* state)7{8 uint8_t
    temp;910 // 将第一行向左旋转 1 列11 temp = (*state)[0][1];12 (*state)[0][1] = (*state)[1][1];13
    (*state)[1][1] = (*state)[2][1];14 (*state)[2][1] = (*state)[3][1];15 (*state)[3][1]
    = temp;1617 // 将第二行向左旋转 2 列18 temp = (*state)[0][2];19 (*state)[0][2] = (*state)[2][2];20
    (*state)[2][2] = temp;2122 temp = (*state)[1][2];23 (*state)[1][2] = (*state)[3][2];24
    (*state)[3][2] = temp;2526 // 将第三行向左旋转 3 列27 temp = (*state)[0][3];28 (*state)[0][3]
    = (*state)[3][3];29 (*state)[3][3] = (*state)[2][3];30 (*state)[2][3] = (*state)[1][3];31
    (*state)[1][3] = temp;32}1 HLS 兼容的代码由 LLM 重新编写1 static void ShiftRows(state_t
    state[4][4]) {2 uint8_t temp;3 int i, j;45 // 遍历行 1 到 3（从 0 开始的索引）6 for (i = 1;
    i < 4; ++i) {7 // 当前行左移的位置数8 int shift = i;910 // 使用单独的循环处理移动次数11 for (j = 0;
    j < shift; ++j) {12 temp = state[0][i];  // 存储要移动的元素13 // 将所有元素向左移动一个位置14 for
    (int k = 0; k < 3; ++k) {15 state[k][i] = state[k + 1][i];16 }17 state[3][i] =
    temp;  // 将临时值放到末尾18 }19 }20}
- en: 'Figure 15: Human-in-the-loop AES Shift Rows'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15：人机交互 AES Shift Rows
- en: 1Original  c  code  (after  removing  printf  s)  \end{lstlisting}2\vspace{-7pt}3  \end{subfigure}4  \begin{subfigure}[t]{.9\columnwidth}5  \begin{lstlisting}[language=c]6static  void  SubBytes(state_t*  state)7{8  uint8_t  i,  j;9  for  (i  =  0;  i  <  4;  ++i)10  {11  for  (j  =  0;  j  <  4;  ++j)12  {13  (*state)[j][i]  =  getSBoxValue((*state)[j][i]);14  }15  }16}1HLS  compatible  code  rewritten  by  the  LLM1static  void  SubBytes(state_t  state[4][4])  {2  uint8_t  i,  j;3  for  (i  =  0;  i  <  4;  ++i)  {4  for  (j  =  0;  j  <  4;  ++j)  {5  state[j][i]  =  getSBoxValue(state[j][i]);6  }7  }
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 1 原始的 `c` 代码（去除 `printf`） \end{lstlisting}2\vspace{-7pt}3 \end{subfigure}4 \begin{subfigure}[t]{.9\columnwidth}5
    \begin{lstlisting}[language=c]6static void SubBytes(state_t* state)7{8 uint8_t
    i, j;9 for (i = 0; i < 4; ++i)10 {11 for (j = 0; j < 4; ++j)12 {13 (*state)[j][i]
    = getSBoxValue((*state)[j][i]);14 }15 }16}1 HLS 兼容的代码由 LLM 重新编写1 static void SubBytes(state_t
    state[4][4]) {2 uint8_t i, j;3 for (i = 0; i < 4; ++i) {4 for (j = 0; j < 4; ++j)
    {5 state[j][i] = getSBoxValue(state[j][i]);6 }7 }
- en: 'Figure 16: Human-in-the-loop AES Sub Bytes'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16：人机交互 AES Sub Bytes
- en: 1Original  c  code  (after  removing  printf  s)  \end{lstlisting}2\vspace{-7pt}3  \end{subfigure}4  \begin{subfigure}[t]{.9\columnwidth}5  \begin{lstlisting}[language=c]6static  void  AddRoundKey(uint8_t  round,  state_t*  state,  const  uint8_t*  RoundKey)7{8  uint8_t  i,j;9  for  (i  =  0;  i  <  4;  ++i)10  {11  for  (j  =  0;  j  <  4;  ++j)12  {13  (*state)[i][j]  ^=  RoundKey[(round  *  Nb  *  4)  +  (i  *  Nb)  +  j];14  }15  }16}1HLS  compatible  code  rewritten  by  the  LLM1static  void  AddRoundKey(uint8_t  round,  state_t  state[4][4],  const  uint8_t  RoundKey[AES_KEYLEN])  {2  uint8_t  i,  j;3  uint8_t  base  =  round  *  Nb  *  4;4  for  (i  =  0;  i  <  4;  ++i)  {5  for  (j  =  0;  j  <  4;  ++j)  {6  state[i][j]  ^=  RoundKey[base  +  (i  *  Nb)  +  j];7  }8  }9}
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 1原始的 c 代码（去除 printf 后）\end{lstlisting}2\vspace{-7pt}3\end{subfigure}4\begin{subfigure}[t]{.9\columnwidth}5\begin{lstlisting}[language=c]6static
    void AddRoundKey(uint8_t round, state_t* state, const uint8_t* RoundKey)7{8  uint8_t
    i,j;9  for (i = 0; i < 4; ++i)10  {11  for (j = 0; j < 4; ++j)12  {13  (*state)[i][j]
    ^= RoundKey[(round * Nb * 4) + (i * Nb) + j];14  }15  }16}1HLS 兼容的代码由 LLM 重写1static
    void AddRoundKey(uint8_t round, state_t state[4][4], const uint8_t RoundKey[AES_KEYLEN])
    {2  uint8_t i, j;3  uint8_t base = round * Nb * 4;4  for (i = 0; i < 4; ++i) {5  for
    (j = 0; j < 4; ++j) {6  state[i][j] ^= RoundKey[base + (i * Nb) + j];7  }8  }9}
- en: 'Figure 17: Human-in-the-loop AES Add Round Key'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17：人机交互 AES 添加轮密钥
- en: 1HLS  compatible  code  from  the  hands-free  flow1//  Function  to  swap  two  elements2void  swap(int*  a,  int*  b){3int  temp  =  *a;4*a  =  *b;5*b  =  temp;}6int  partition(int  arr[],  int  low,  int  high){7int  pivot  =  arr[low];8int  i  =  low;9int  j  =  high;10while  (i  <  j){11  while  (arr[i]  <=  pivot  &&  i  <=  high  -  1){12  i++;13  }14  while  (arr[j]  >  pivot  &&  j  >=  low  +  1){15  j--;16  }17  if  (i  <  j){18  swap(&arr[i],  &arr[j]);19  }20}21swap(&arr[low],  &arr[j]);22return  j;23}24void  quickSort(int  arr[64],  int  low,  int  high){25int  stack[128];  //  Fixed  size  stack  to  work  with  HLS  tools26int  top  =  -1;27stack[++top]  =  low;28stack[++top]  =  high;29while  (top  >=  0){30  high  =  stack[top--];31  low  =  stack[top--];32  if  (low  <  high){33  int  partitionIndex  =  partition(arr,  low,  high);34  stack[++top]  =  low;35  stack[++top]  =  partitionIndex  -  1;36  stack[++top]  =  partitionIndex  +  1;37  stack[++top]  =  high;38}}}
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 1HLS 兼容的代码来自免手动流程1// 交换两个元素的函数2void swap(int* a, int* b){3int temp = *a;4*a
    = *b;5*b = temp;}6int partition(int arr[], int low, int high){7int pivot = arr[low];8int
    i = low;9int j = high;10while (i < j){11  while (arr[i] <= pivot && i <= high
    - 1){12  i++;13  }14  while (arr[j] > pivot && j >= low + 1){15  j--;16  }17  if
    (i < j){18  swap(&arr[i], &arr[j]);19  }20}21swap(&arr[low], &arr[j]);22return
    j;23}24void quickSort(int arr[64], int low, int high){25int stack[128];  // 固定大小的栈以配合
    HLS 工具26int top = -1;27stack[++top] = low;28stack[++top] = high;29while (top >=
    0){30  high = stack[top--];31  low = stack[top--];32  if (low < high){33  int
    partitionIndex = partition(arr, low, high);34  stack[++top] = low;35  stack[++top]
    = partitionIndex - 1;36  stack[++top] = partitionIndex + 1;37  stack[++top] =
    high;38}}}
- en: 'Figure 18: Hands-free C2HLSC QuickSort'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18：免手动 C2HLSC 快速排序
- en: 1HLS  compatible  code  from  the  hands-free  flow1void  AddRoundKey(uint8_t  round,  state_t  state,  const  uint8_t*  RoundKey)2{3uint8_t  i,  j;4uint8_t  RoundKey_local[AES_keyExpSize];5for  (i  =  0;  i  <  AES_keyExpSize;  ++i)6{7#pragma  HLS  PIPELINE  II=18  RoundKey_local[i]  =  RoundKey[i];9}10for  (i  =  0;  i  <  4;  ++i)11{12  for  (j  =  0;  j  <  4;  ++j)13  {14#pragma  HLS  PIPELINE  II=115  state[i][j]  ^=  RoundKey_local[(round  *  Nb  *  4)  +  (i  *  Nb)  +  j];16  }17}18}
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 1HLS 兼容的代码来自免手动流程1void AddRoundKey(uint8_t round, state_t state, const uint8_t*
    RoundKey)2{3uint8_t i, j;4uint8_t RoundKey_local[AES_keyExpSize];5for (i = 0;
    i < AES_keyExpSize; ++i)6{7#pragma HLS PIPELINE II=18 RoundKey_local[i] = RoundKey[i];9}10for
    (i = 0; i < 4; ++i)11{12  for (j = 0; j < 4; ++j)13  {14#pragma HLS PIPELINE II=115  state[i][j]
    ^= RoundKey_local[(round * Nb * 4) + (i * Nb) + j];16  }17}18}
- en: 'Figure 19: Hands-free C2HLSC AES Add Round Key'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19：免手动 C2HLSC AES 添加轮密钥
- en: 1HLS  compatible  code  from  the  hands-free  flow1void  ShiftRows(state_t  state)  {2  uint8_t  temp;34  //  Rotate  first  row  1  column  to  the  left5  temp  =  state[0][1];6  state[0][1]  =  state[1][1];7  state[1][1]  =  state[2][1];8  state[2][1]  =  state[3][1];9  state[3][1]  =  temp;1011  //  Rotate  second  row  2  columns  to  the  left12  temp  =  state[0][2];13  state[0][2]  =  state[2][2];14  state[2][2]  =  temp;1516  temp  =  state[1][2];17  state[1][2]  =  state[3][2];18  state[3][2]  =  temp;1920  //  Rotate  third  row  3  columns  to  the  left21  temp  =  state[0][3];22  state[0][3]  =  state[3][3];23  state[3][3]  =  state[2][3];24  state[2][3]  =  state[1][3];25  state[1][3]  =  temp;26}
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 1HLS 兼容代码来自免手动流程1void  ShiftRows(state_t  state)  {2  uint8_t  temp;34  //  将第一行的1列向左旋转5  temp  =  state[0][1];6  state[0][1]  =  state[1][1];7  state[1][1]  =  state[2][1];8  state[2][1]  =  state[3][1];9  state[3][1]  =  temp;1011  //  将第二行的2列向左旋转12  temp  =  state[0][2];13  state[0][2]  =  state[2][2];14  state[2][2]  =  temp;1516  temp  =  state[1][2];17  state[1][2]  =  state[3][2];18  state[3][2]  =  temp;1920  //  将第三行的3列向左旋转21  temp  =  state[0][3];22  state[0][3]  =  state[3][3];23  state[3][3]  =  state[2][3];24  state[2][3]  =  state[1][3];25  state[1][3]  =  temp;26}
- en: 'Figure 20: Hands-free C2HLSC AES Shift Rows'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '图 20: 免手动 C2HLSC AES Shift Rows'
- en: 1HLS  compatible  code  from  the  hands-free  flow1void  MixColumns(state_t  state)2{3  uint8_t  i;4  uint8_t  Tmp,  Tm,  t;5  for  (i  =  0;  i  <  4;  ++i)6  {7  t  =  state[i][0];8  Tmp  =  state[i][0]  ^  state[i][1]  ^  state[i][2]  ^  state[i][3];9  Tm  =  state[i][0]  ^  state[i][1];  Tm  =  xtime(Tm);  state[i][0]  ^=  Tm  ^  Tmp;10  Tm  =  state[i][1]  ^  state[i][2];  Tm  =  xtime(Tm);  state[i][1]  ^=  Tm  ^  Tmp;11  Tm  =  state[i][2]  ^  state[i][3];  Tm  =  xtime(Tm);  state[i][2]  ^=  Tm  ^  Tmp;12  Tm  =  state[i][3]  ^  t;  Tm  =  xtime(Tm);  state[i][3]  ^=  Tm  ^  Tmp;13  }14}
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 1HLS 兼容代码来自免手动流程1void  MixColumns(state_t  state)2{3  uint8_t  i;4  uint8_t  Tmp,  Tm,  t;5  for  (i  =  0;  i  <  4;  ++i)6  {7  t  =  state[i][0];8  Tmp  =  state[i][0]  ^  state[i][1]  ^  state[i][2]  ^  state[i][3];9  Tm  =  state[i][0]  ^  state[i][1];  Tm  =  xtime(Tm);  state[i][0]  ^=  Tm  ^  Tmp;10  Tm  =  state[i][1]  ^  state[i][2];  Tm  =  xtime(Tm);  state[i][1]  ^=  Tm  ^  Tmp;11  Tm  =  state[i][2]  ^  state[i][3];  Tm  =  xtime(Tm);  state[i][2]  ^=  Tm  ^  Tmp;12  Tm  =  state[i][3]  ^  t;  Tm  =  xtime(Tm);  state[i][3]  ^=  Tm  ^  Tmp;13  }14}
- en: 'Figure 21: Hands-free C2HLSC AES Mix Columns'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '图 21: 免手动 C2HLSC AES 混合列'
- en: 1HLS  compatible  code  from  the  hands-free  flow1#define  getSBoxValue(num)  (sbox[(num)])23//  The  SubBytes  Function  Substitutes  the  values  in  the4//  state  matrix  with  values  in  an  S-box.5static  void  SubBytes(state_t  state)6{7  uint8_t  i,  j;8  for  (i  =  0;  i  <  4;  ++i)9  {10  for  (j  =  0;  j  <  4;  ++j)11  {12  state[j][i]  =  getSBoxValue(state[j][i]);13  }14  }15}
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 1HLS 兼容代码来自免手动流程1#define  getSBoxValue(num)  (sbox[(num)])23//  SubBytes 函数用
    S-box 中的值替换状态矩阵中的值。4//  state 矩阵中的值5static  void  SubBytes(state_t  state)6{7  uint8_t  i,  j;8  for  (i  =  0;  i  <  4;  ++i)9  {10  for  (j  =  0;  j  <  4;  ++j)11  {12  state[j][i]  =  getSBoxValue(state[j][i]);13  }14  }15}
- en: 'Figure 22: Hands-free C2HLSC AES Sub Bytes'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '图 22: 免手动 C2HLSC AES Sub Bytes'
- en: -B Waveforms
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: -B 波形
- en: -C Conversations
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: -C 对话
- en: Here we list the links to the conversations to go from C to HLS C.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们列出了将 C 代码转换为 HLS C 的对话链接。
- en: •
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: '[Frequency Test: https://g.co/gemini/share/ba393c5de5a6](https://g.co/gemini/share/ba393c5de5a6)'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[频率测试](https://g.co/gemini/share/ba393c5de5a6)'
- en: •
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: '[Frequency Block Test: https://g.co/gemini/share/659379d677c0](https://g.co/gemini/share/659379d677c0)'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[频率块测试](https://g.co/gemini/share/659379d677c0)'
- en: •
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: '[Cumulative Sums Test: https://g.co/gemini/share/0f35a4d248e7](https://g.co/gemini/share/0f35a4d248e7)'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[累计和测试](https://g.co/gemini/share/0f35a4d248e7)'
- en: •
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: '[QuickSort: https://g.co/gemini/share/92b68e7849fc](https://g.co/gemini/share/92b68e7849fc)'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[快速排序](https://g.co/gemini/share/92b68e7849fc)'
- en: •
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: '[AES 128: https://g.co/gemini/share/92b68e7849fc](https://g.co/gemini/share/92b68e7849fc)'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[AES 128](https://g.co/gemini/share/92b68e7849fc)'
- en: •
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: •
- en: '[Overlapping Template Matching Test: https://g.co/gemini/share/c1ac0cef56f2](https://g.co/gemini/share/c1ac0cef56f2)'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[重叠模板匹配测试](https://g.co/gemini/share/c1ac0cef56f2)'
