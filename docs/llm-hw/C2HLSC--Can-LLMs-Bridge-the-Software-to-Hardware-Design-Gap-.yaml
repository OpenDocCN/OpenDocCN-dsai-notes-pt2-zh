- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-09-08 18:51:29'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: 'C2HLSC: Can LLMs Bridge the Software-to-Hardware Design Gap?'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://ar5iv.labs.arxiv.org/html/2406.09233](https://ar5iv.labs.arxiv.org/html/2406.09233)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Luca Collini , Siddharth Garg , Ramesh Karri
  prefs: []
  type: TYPE_NORMAL
- en: Abstract
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: High Level Synthesis (HLS) tools offer rapid hardware design from C code, but
    their compatibility is limited by code constructs. This paper investigates Large
    Language Models (LLMs) for refactoring C code into HLS-compatible formats. We
    present several case studies by using an LLM to rewrite C code for NIST 800-22
    randomness tests, a QuickSort algorithm and AES-128 into HLS-synthesizable c.
    The LLM iteratively transforms the C code guided by user prompts, implementing
    functions like streaming data and hardware-specific signals. This evaluation demonstrates
    the LLM’s potential to assist hardware design refactoring regular C code into
    HLS synthesizable C code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Index Terms:'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Chip Design, LLM, Catapult HLS, Cryptocores.^†^†publicationid: pubid: 979-8-3503-7608-1/24$31.00
    ©2024 IEEE'
  prefs: []
  type: TYPE_NORMAL
- en: I Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'High-Level Synthesis (HLS) is a promising chip design methodology that enables
    rapid hardware design from high-level specifications. HLS tools convert a high-level
    specification (C, C++) into an register transfer level (RTL) description [[1](#bib.bib1)]:
    (1) HLS uses state-of-the-art compilers (e.g., LLVM or GCC) to extract a high-level
    control data flow graph (CDFG). (2) They then assign operations to time (scheduling)
    and space (allocation and binding) to determine the micro-architecture. HLS tools
    also support pragmas and directives to explore architectural choices for a C specification.
    Software and hardware paradigms are different. Hence HLS tools support a subset
    of C constructs that map to hardware. For instance, hardware does not support
    dynamic memory allocation and recursive constructs. Outputs can only communicate
    through parameters, arrays sizes need to be static, limit support for pointers
    and multiple processes can be modeled through independent function instances mapped
    into hardware blocks. Designers manually refactor C code to remove these constructs
    and make it compatible with HLS tools. However, manual refactoring is time consuming,
    and error prone [[2](#bib.bib2)].'
  prefs: []
  type: TYPE_NORMAL
- en: I-A Large Language Models (LLMs)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: LLMs are trained on massive amounts of text data and excel at tasks like code
    generation and translation, particularly in languages like C, Cc++, and Python.
    However, their performance suffers on Hardware Description Languages (HDLs) like
    Verilog or VHDL due to the limited amount of training data available in those
    languages [[3](#bib.bib3)]. This paper explores LLMs for refactoring C code, transforming
    it into a subset C compatible with HLS tools. LLMs can analyze generic C code
    and refactor it to HLS-synthesizable C. This leverages the power of LLMs in generating
    and manipulating C code and bypassing their limitations in generating HDL code.
  prefs: []
  type: TYPE_NORMAL
- en: I-B Contributions and Roadmap
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'LLMs have limited success in generating Verilog code [[4](#bib.bib4), [5](#bib.bib5)].
    This is due to the scarcity online of hardware description language (HDL) data
    compared to code in C, C++ and other software. We explore use of LLMs to assist
    developers in refactoring generic C specification into synthesizable C that is
    compatible with HLS as shown in Figure [1](#S1.F1 "Figure 1 ‣ I-B Contributions
    and Roadmap ‣ I Introduction ‣ C2HLSC: Can LLMs Bridge the Software-to-Hardware
    Design Gap?"). Out work has two main contributions. First, we present case studies
    of deriving HLS-usable C codes derived from generic C codes. The study compares
    development time and resource use achieved using LLM-assisted development in lieu
    of cumbersome manual methods. Second, we discuss the results and present a prototype
    hands-free C2HLSC LLM-based tool, which will be open-source. The paper road-map
    is as follows: 1. Section [II](#S2 "II Related Work ‣ C2HLSC: Can LLMs Bridge
    the Software-to-Hardware Design Gap?") presents related work, highlighting the
    novelties of the approach. 2. Section [III](#S3 "III Case Study ‣ C2HLSC: Can
    LLMs Bridge the Software-to-Hardware Design Gap?") illustrates the case study,
    presenting the tasks and methodologies and results. 3. Section [IV](#S4 "IV Hands-Free
    C2HSLC Prototype ‣ C2HLSC: Can LLMs Bridge the Software-to-Hardware Design Gap?")
    presents the prototype hands-free C2HLSC tool, discussing capabilities and limitations.
    4. Section [V](#S5 "V Conclusions ‣ C2HLSC: Can LLMs Bridge the Software-to-Hardware
    Design Gap?") concludes the paper.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Refer to caption](img/1dbbe43ac3d13f93384e2a2eba246631.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1: Flow for the proposed C2HLSC approach.'
  prefs: []
  type: TYPE_NORMAL
- en: II Related Work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Previous work explored LLMs to design hardware. Verigen fine-tuned an LLM to
    improve its ability to produce Verilog [[4](#bib.bib4)]. The fine tuned LLM though
    performed marginally better than ChatGPT3.5-turbo with an accuracy $\sim$65%.
    ChipChat [[5](#bib.bib5)] was the first to tapeout a design written by an AI model.
    However, the single shot performance of the AI model was low and needed several
    iterations in order for the LLM to get to the correct result. We target generating
    synthesizable C code as LLMs are more capable at C than at hardware languages [[3](#bib.bib3)].
    In [[6](#bib.bib6)] an LLM was used to write Amaranth HDL, a Python based HDL,
    that allows to model synchronous logic at the RTL. For this reason, while it uses
    a high level language, its semantics are close to verilog, and targets hardware
    designers. While the LLM came up with parts of the design, it fell short in some
    tasks, like generating interfaces. Software developers use HLS to design hardware
    and as such the code only provides the functionality¹¹1Whereas the hardware architecture
    and interface specification are instructed using HLS pragmas and directives..
  prefs: []
  type: TYPE_NORMAL
- en: III Case Study
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: III-A Overview
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We evaluated Gemini LLM [[7](#bib.bib7)] to transform C code into synthesizable
    C suitable for HLS. The evaluation consisted of two tasks. The first task involved
    rewriting reference C implementations of the Frequency test, Frequency Block test,
    Cumulative Sums, and Overlapping Template Matching tests from the NIST 800-22
    suite [[8](#bib.bib8)] into synthesizable C code. These tests are designed to
    assess the randomness of a sequence. A first challenge arose due to the inherent
    differences between software and hardware implementations. The reference C implementations
    operate on a pre-loaded random sequence stored in memory. Conversely, hardware
    implementations require on-the-fly analysis, processing the sequence bit-by-bit.
    This necessitates modifying the code to handle a streaming data input rather than
    a pre-loaded array. A second challenge stemmed from the p-value calculation. In
    software context, the precise p-value is critical and computed on-the-fly. However,
    since the hardware implementations primarily focus on distinguishing random from
    non-random sequences one can simplify this by pre-computing certain values offline
    and reducing the computational burden during on-the-fly analysis. Both these challenges
    are non-trivial for human developers and LLMs. The second task assesses the LLM’s
    ability to rewrite code constructs that are not supported by HLS tools. We used
    two algorithms: a QuickSort containing pointers and recursion [[9](#bib.bib9)],
    and the AES128 encrypt from the tinyAES library [[10](#bib.bib10)] with six functions.
    The goal was for the LLM to generate code without pointers and recursion, making
    it suitable for (Catapult) HLS.'
  prefs: []
  type: TYPE_NORMAL
- en: III-B Methodology
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We broke down the process into small steps to allow the LLM to transform the
    original C into synthesizable C. For the first task we followed the following
    steps for the three tests: 1. Present task to the LLM: ”Hi, I have this code in
    C that I need to rewrite such that I can use it with an HLS tool to generate hardware.”.
    2. Ask to remove print statements. 3. Ask to rewrite the function as a streaming
    interface: ”Now I need to rewrite the function such that it will get inferred
    as a streaming interface, to do so, I need to get rid of the epsilon array and
    have the function take a parameter to accept a bit at each function call.” 4.
    Ask to remove math steps to be computed offline (in some cases, ask to write a
    script to run them). 5. Ask to add is_random and valid signals as parameters.
    6. Ask to optimize data types using arbitrary width integers and fixed point arithmetic
    using HLSLIBS [[11](#bib.bib11)]. 7. Ask to write a main function to test the
    function passing random bits. 8. Ask to fix mistakes passing errors from HLS tool.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For QuickSort we followed these steps: 1. Present the task to the LLM: ”Hi,
    I have this code in C that I need to rewrite such that I can use it with an HLS
    tool to generate hardware.”. 2. Ask to remove print statements. 3. Ask to rewrite
    function without using pointers. 4. Ask to rewrite function without recursion.
    5. Ask to fix array sizes in function parameters. 6. Ask to optimize data types
    using arbitrary width integers and fixed point arithmetic using HLSLIBS. 7. Ask
    to write a main function to test the function passing an array to sort. 8. Ask
    to fix mistakes by passing errors from HLS tool.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the AES 128 from tinyAES [[10](#bib.bib10)] we followed the following steps
    asking to fix one function at a time: 1. Present the task to the LLM: ”Hi, I have
    this code in C that I need to rewrite such that I can use it with an HLS tool
    to generate hardware.”. 2. Ask to rewrite for loops with fixed bounds and no pointer
    usage. 3. Ask to rewrite the function parameters to using fixed size arrays. 4.
    Ask to fix eventual mistakes passing errors from the HLS tool. When the LLM responds
    with sub optimal answers, we check alternative answers, and if none fully satisfied
    the request we instruct the LLM with additional prompts including more details
    pointing out where the problem was, and, if not sufficient, hinting at possible
    solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: III-C Results
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The aim of this study is to evaluate how LLMs perform at rewriting C code such
    that it is HLS synthesizable²²2Finding pragmas to optimize the hardware architecture
    is an orthogonal problem for which LLMs could be employed, left as future work..
    We run the code through Catapult HLS to check correctness after synthesis, but
    we do not focus on the resource utilization, as it is depends on the architectural
    decisions. We targeted the nangate45 library at 50 MHz with a synchronous active
    high reset for all the tests. The LLM was able to rewrite all C codes to run on
    Catapult HLS. We performed simulations with Modelsim to check result equivalency
    between the original C and the synthesized Verilog obtained from the LLM-generated
    C. The original C codes (without printfs) and the HLS C code rewritten by the
    LLM are in Appendix [-A](#A0.SS1 "-A LLM generated HLS compatible C codes ‣ C2HLSC:
    Can LLMs Bridge the Software-to-Hardware Design Gap?"), links to the conversations
    are in Appendix [-C](#A0.SS3 "-C Conversations ‣ C2HLSC: Can LLMs Bridge the Software-to-Hardware
    Design Gap?"). We can classify the errors in the LLM generated code into compile/synthesis
    errors, and functional errors. The former where easier to fix instructing the
    LLM with the error message and affected line. For functional errors caught by
    the failing tests, it was harder for the LLM to identify the cause and propose
    a fix. Manual effort was needed to point out sources of the issues for the LLM
    to propose an effective fix. Typical functional issues where mistaken loop readjustments,
    widths and arbitrary widths types.'
  prefs: []
  type: TYPE_NORMAL
- en: III-C1 C2HLSC of NIST 800-22 Randomness Tests
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The LLM performed well in most steps, especially in rewriting the function
    as a streaming interface, which is one of the more complex steps. Figure [2](#S3.F2
    "Figure 2 ‣ III-C1 C2HLSC of NIST 800-22 Randomness Tests ‣ III-C Results ‣ III
    Case Study ‣ C2HLSC: Can LLMs Bridge the Software-to-Hardware Design Gap?") shows
    the streaming interface rewriting for the Frequency Block test. For all the three
    tests this step was performed correctly at the first shot. However, the LLM did
    stumble on tasks that seemd more trivial. For example, when asked to remove the
    abs function in this line of code (abs(sum.to_int()) <= SUM_THRESHOLD); it came
    up with convoluted ways that did not work like (sum.to_int() <0) ? -sum.to_int()
    : sum.to_int()) <= SUM_THRESHOLD and it took many tries to eventually get the
    expected result (sum <SUM_THRESHOLD) && (sum <-SUM_THRESHOLD). The test function
    generation was always generated effectively.'
  prefs: []
  type: TYPE_NORMAL
- en: '[⬇](data:text/plain;base64,SSBuZWVkIHRvIHJld3JpdGUgdGhlIGZ1bmN0aW9uIHN1Y2ggdGhhdCBpdAp3aWxsIGdldCBpbmZlcnJlZCBhcyBhIHN0cmVhbWluZyBpbnRlcmZhY2UsCnRvIGRvIHNvLCBJIG5lZWQgdG8gZ2V0IHJpZCBvZiB0aGUgZXBzaWxvbgphcnJheSBhbmQgaGF2ZSB0aGUgZnVuY3Rpb24gdGFrZSBhIHBhcmFtZXRlcgp0byBhY2NlcHQgYSBiaXQgYXQgZWFjaCBmdW5jdGlvbiBjYWxsLg==)1I  need  to  rewrite  the  function  such  that  it2will  get  inferred  as  a  streaming  interface,3to  do  so,  I  need  to  get  rid  of  the  epsilon4array  and  have  the  function  take  a  parameter5to  accept  a  bit  at  each  function  call.[⬇](data:text/plain;base64,dm9pZCBCbG9ja0ZyZXF1ZW5jeShpbnQgTSwgaW50IG4pIHsKaW50IGksIGosIE4sIGJsb2NrU3VtOwpkb3VibGUgcF92YWx1ZSwgc3VtLCBwaSwgdiwgY2hpMjsKTiA9IG4gLyBNOyAgLyogIyBPRiBTVUJTVFJJTkcgQkxPQ0tTICovCnN1bSA9IDAuMDsKZm9yIChpID0gMDsgaSA8IE47IGkrKykgewogICAgYmxvY2tTdW0gPSAwOwogICAgZm9yIChqID0gMDsgaiA8IE07IGorKykgewogICAgICAgIGJsb2NrU3VtICs9IGVwc2lsb25baiArIGkgKiBNXTsKICAgIH0KICAgIHBpID0gKGRvdWJsZSlibG9ja1N1bSAvIChkb3VibGUpTTsKICAgIHYgPSBwaSAtIDAuNTsKICAgIHN1bSArPSB2ICogdjsKfQpjaGkyID0gNC4wICogTSAqIHN1bTsKcF92YWx1ZSA9IGNlcGhlc19pZ2FtYyhOIC8gMi4wLCBjaGkyIC8gMi4wKTt9)1void  BlockFrequency(int  M,  int  n)  {2int  i,  j,  N,  blockSum;3double  p_value,  sum,  pi,  v,  chi2;4N  =  n  /  M;  /*  #  OF  SUBSTRING  BLOCKS  */5sum  =  0.0;6for  (i  =  0;  i  <  N;  i++)  {7  blockSum  =  0;8  for  (j  =  0;  j  <  M;  j++)  {9  blockSum  +=  epsilon[j  +  i  *  M];10  }11  pi  =  (double)blockSum  /  (double)M;12  v  =  pi  -  0.5;13  sum  +=  v  *  v;14}15chi2  =  4.0  *  M  *  sum;16p_value  =  cephes_igamc(N  /  2.0,  chi2  /  2.0);}[⬇](data:text/plain;base64,SGVyZSdzIHRoZSBjb2RlIHJld3JpdHRlbiB0byBhY2NlcHQgYSBzaW5nbGUKYml0IHBlciBmdW5jdGlvbiBjYWxsLCBtYWtpbmcgaXQgbW9yZSBzdWl0YWJsZQpmb3IgYSBzdHJlYW1pbmcgaW50ZXJmYWNlOg==)1Here’s  the  code  rewritten  to  accept  a  single2bit  per  function  call,  making  it  more  suitable3for  a  streaming  interface:[⬇](data:text/plain;base64,dm9pZCBCbG9ja0ZyZXF1ZW5jeShpbnQgTSwgaW50IG4sIGJvb2wgYml0KSB7CnN0YXRpYyBpbnQgaSA9IDAsIGogPSAwLCBibG9ja1N1bSA9IDA7CnN0YXRpYyBkb3VibGUgc3VtID0gMC4wOwpkb3VibGUgcGksIHYsIGNoaTI7CmlmIChqID09IDApIHsgLy8gUmVzZXQgb24gbmV3IGJsb2NrCiAgICBpKys7CiAgICBibG9ja1N1bSA9IDA7Cn0KYmxvY2tTdW0gKz0gYml0OyAvLyBBY2N1bXVsYXRlIGJpdApqKys7CmlmIChqID09IE0pIHsgLy8gQmxvY2sgY29tcGxldGUKICAgIHBpID0gKGRvdWJsZSlibG9ja1N1bSAvIChkb3VibGUpTTsKICAgIHYgPSBwaSAtIDAuNTsKICAgIHN1bSArPSB2ICogdjsKICAgIGogPSAwOwp9CmlmIChpID09IChuIC8gTSkpIHsgLy8gQWxsIGJsb2NrcyBwcm9jZXNzZWQKICAgIGNoaTIgPSA0LjAgKiBNICogc3VtOwogICAgcF92YWx1ZT1jZXBoZXNfaWdhbWMobiAvIDIuMCwgY2hpMiAvIDIuMCk7Cn19)1void  BlockFrequency(int  M,  int  n,  bool  bit)  {2static  int  i  =  0,  j  =  0,  blockSum  =  0;3static  double  sum  =  0.0;4double  pi,  v,  chi2;5if  (j  ==  0)  {  //  Reset  on  new  block6  i++;7  blockSum  =  0;8}9blockSum  +=  bit;  //  Accumulate  bit10j++;11if  (j  ==  M)  {  //  Block  complete12  pi  =  (double)blockSum  /  (double)M;13  v  =  pi  -  0.5;14  sum  +=  v  *  v;15  j  =  0;16}17if  (i  ==  (n  /  M))  {  //  All  blocks  processed18  chi2  =  4.0  *  M  *  sum;19  p_value=cephes_igamc(n  /  2.0,  chi2  /  2.0);20}}'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2: Transforming into a streaming pipeline.'
  prefs: []
  type: TYPE_NORMAL
- en: III-C2 C2HLSC of QuickSort
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The original QuickSort used a function to swap elements in the arrays using
    pointers. Inlining the function and removing pointers was flawless as reported
    in Figure [3](#S3.F3 "Figure 3 ‣ III-C2 C2HLSC of QuickSort ‣ III-C Results ‣
    III Case Study ‣ C2HLSC: Can LLMs Bridge the Software-to-Hardware Design Gap?").
    However, in the subsequent steps it reverted to using the function and needed
    re-prompting to inline. The LLM got rid of recursion in one shot, using a fixed
    size stack to track the high and low values. However, the stack management logic
    was not correct. The problem was identified at the end, when running the generated
    test, which caused a segmentation fault. The LLM fixed the problem in a few tries
    by feeding the errors from gdb and showing intermediate values of high and low.'
  prefs: []
  type: TYPE_NORMAL
- en: '[⬇](data:text/plain;base64,Q2FuIHdlIGdldCByaWQgb2YgdGhlIHN3YXAgZnVuY3Rpb24gYW5kIHJlcGxhY2UKaXQgaW5saW5lPw==)1Can  we  get  rid  of  the  swap  function  and  replace2it  inline?[⬇](data:text/plain;base64,dm9pZCBzd2FwKGludCogYSwgaW50KiBiKSB7CiAgICBpbnQgdGVtcCA9ICphOwogICAgKmEgPSAqYjsKICAgICpiID0gdGVtcDt9Ci4uLgogICAgaWYgKGkgPCBqKSB7CiAgICAgICAgc3dhcChhcnJbaV0sIGFycltqXSk7IC8vIENhbGwgdG8gbW9kaWZpZWQgc3dhcCBmdW5jdGlvbgogICAgfX0Kc3dhcCgmYXJyW2xvd10sICZhcnJbal0pOwouLi4=)1void  swap(int*  a,  int*  b)  {2  int  temp  =  *a;3  *a  =  *b;4  *b  =  temp;}5...6  if  (i  <  j)  {7  swap(arr[i],  arr[j]);  //  Call  to  modified  swap  function8  }}9swap(&arr[low],  &arr[j]);10...[⬇](data:text/plain;base64,WWVzLCB5b3UgY2FuIGRlZmluaXRlbHkgZ2V0IHJpZCBvZiB0aGUgc3dhcApmdW5jdGlvbiBhbmQgcmVwbGFjZSBpdCBpbmxpbmUgd2l0aGluIHRoZQpwYXJ0aXRpb24gZnVuY3Rpb24uIEhlcmUncyB0aGUgbW9kaWZpZWQgY29kZTo=)1Yes,  you  can  definitely  get  rid  of  the  swap2function  and  replace  it  inline  within  the3partition  function.  Here’s  the  modified  code:[⬇](data:text/plain;base64,Li4uCiAgICBpZiAoaSA8IGopIHsKICAgICAgICAvLyBJbmxpbmUgc3dhcCB1c2luZyB0ZW1wb3JhcnkgdmFyaWFibGUKICAgICAgICBpbnQgdGVtcCA9IGFycltpXTsKICAgICAgICBhcnJbaV0gPSBhcnJbal07CiAgICAgICAgYXJyW2pdID0gdGVtcDsKICAgIH19Ci8vIFN3YXAgcGl2b3QgZWxlbWVudCB3aXRoIGVsZW1lbnQgYXQgaW5kZXggagppbnQgdGVtcCA9IGFycltsb3ddOwphcnJbbG93XSA9IGFycltqXTsKYXJyW2pdID0gdGVtcDsKcmV0dXJuIGo7Ci4uLg==)1...2  if  (i  <  j)  {3  //  Inline  swap  using  temporary  variable4  int  temp  =  arr[i];5  arr[i]  =  arr[j];6  arr[j]  =  temp;7  }}8//  Swap  pivot  element  with  element  at  index  j9int  temp  =  arr[low];10arr[low]  =  arr[j];11arr[j]  =  temp;12return  j;13...'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3: Removing pointers and inlining.'
  prefs: []
  type: TYPE_NORMAL
- en: III-C3 C2HLSC of AES 128 Encrypt
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We fed one function at a time to the LLM starting from the top function Cipher.
    We tested the generated C code and found errors. We prompted the LLM to correct
    the errors. The LLM made major changes in the MixColumn and ShiftRows functions,
    so we asked it to double check that the new code was correct. ShiftRow function
    was corrected in 2 iterations, without extra context on the error. Results are
    in Figure [4](#S3.F4 "Figure 4 ‣ III-C3 C2HLSC of AES 128 Encrypt ‣ III-C Results
    ‣ III Case Study ‣ C2HLSC: Can LLMs Bridge the Software-to-Hardware Design Gap?").
    Fixing MixColumn function took more iterations even though the error was simple.'
  prefs: []
  type: TYPE_NORMAL
- en: '[⬇](data:text/plain;base64,Q2FuIHlvdSBmaXggcG9zc2libGUgcHJvYmxlbXMgaW4gdGhpcyBmdW5jdGlvbj8=)1Can  you  fix  possible  problems  in  this  function?[⬇](data:text/plain;base64,c3RhdGljIHZvaWQgU2hpZnRSb3dzKHN0YXRlX3QqIHN0YXRlKXsKICB1aW50OF90IHRlbXA7CiAgLy8gUm90YXRlIGZpcnN0IHJvdyAxIGNvbHVtbnMgdG8gbGVmdAogIHRlbXAgICAgICAgICAgID0gKCpzdGF0ZSlbMF1bMV07CiAgKCpzdGF0ZSlbMF1bMV0gPSAoKnN0YXRlKVsxXVsxXTsKICAoKnN0YXRlKVsxXVsxXSA9ICgqc3RhdGUpWzJdWzFdOwogICgqc3RhdGUpWzJdWzFdID0gKCpzdGF0ZSlbM11bMV07CiAgKCpzdGF0ZSlbM11bMV0gPSB0ZW1wOwogIC8vIFJvdGF0ZSBzZWNvbmQgcm93IDIgY29sdW1ucyB0byBsZWZ0CiAgdGVtcCAgICAgICAgICAgPSAoKnN0YXRlKVswXVsyXTsKICAoKnN0YXRlKVswXVsyXSA9ICgqc3RhdGUpWzJdWzJdOwogICgqc3RhdGUpWzJdWzJdID0gdGVtcDsKICB0ZW1wICAgICAgICAgICA9ICgqc3RhdGUpWzFdWzJdOwogICgqc3RhdGUpWzFdWzJdID0gKCpzdGF0ZSlbM11bMl07CiAgKCpzdGF0ZSlbM11bMl0gPSB0ZW1wOwogIC8vIFJvdGF0ZSB0aGlyZCByb3cgMyBjb2x1bW5zIHRvIGxlZnQKICB0ZW1wICAgICAgICAgICA9ICgqc3RhdGUpWzBdWzNdOwogICgqc3RhdGUpWzBdWzNdID0gKCpzdGF0ZSlbM11bM107CiAgKCpzdGF0ZSlbM11bM10gPSAoKnN0YXRlKVsyXVszXTsKICAoKnN0YXRlKVsyXVszXSA9ICgqc3RhdGUpWzFdWzNdOwogICgqc3RhdGUpWzFdWzNdID0gdGVtcDt9Ci4uLg==)1static  void  ShiftRows(state_t*  state){2  uint8_t  temp;3  //  Rotate  first  row  1  columns  to  left4  temp  =  (*state)[0][1];5  (*state)[0][1]  =  (*state)[1][1];6  (*state)[1][1]  =  (*state)[2][1];7  (*state)[2][1]  =  (*state)[3][1];8  (*state)[3][1]  =  temp;9  //  Rotate  second  row  2  columns  to  left10  temp  =  (*state)[0][2];11  (*state)[0][2]  =  (*state)[2][2];12  (*state)[2][2]  =  temp;13  temp  =  (*state)[1][2];14  (*state)[1][2]  =  (*state)[3][2];15  (*state)[3][2]  =  temp;16  //  Rotate  third  row  3  columns  to  left17  temp  =  (*state)[0][3];18  (*state)[0][3]  =  (*state)[3][3];19  (*state)[3][3]  =  (*state)[2][3];20  (*state)[2][3]  =  (*state)[1][3];21  (*state)[1][3]  =  temp;}22...[⬇](data:text/plain;base64,TExNIHJlc3VsdCBhZnRlciAyIHRyaWVzIHRlbGxpbmcgdGhlIExMTSB0aGF0CnRoZSBsb29wIGxvZ2ljIHdhcyB3cm9uZy4=)1LLM  result  after  2  tries  telling  the  LLM  that2the  loop  logic  was  wrong.[⬇](data:text/plain;base64,c3RhdGljIHZvaWQgU2hpZnRSb3dzKHN0YXRlX3Qgc3RhdGVbNF1bNF0pIHsKdWludDhfdCB0ZW1wOwppbnQgaSwgajsKLy8gTG9vcCBvdmVyIHJvd3MgMSB0byAzICgwLWJhc2VkIGluZGV4aW5nKQpmb3IgKGkgPSAxOyBpIDwgNDsgKytpKSB7Ci8vIE51bWJlciBvZiBwb3NpdGlvbnMgdG8gbGVmdCBzaGlmdCBmb3IgY3VycmVudCByb3cKICBpbnQgc2hpZnQgPSBpOwogIC8vIFVzZSBhIHNlcGFyYXRlIGxvb3AgZm9yIHRoZSBudW1iZXIgb2Ygc2hpZnRzCiAgZm9yIChqID0gMDsgaiA8IHNoaWZ0OyArK2opIHsKICAgIHRlbXAgPSBzdGF0ZVswXVtpXTsgIC8vIFN0b3JlIHRoZSBlbGVtZW50IHRvIGJlIHNoaWZ0ZWQKICAgIC8vIFNoaWZ0IGFsbCBlbGVtZW50cyBieSBvbmUgcG9zaXRpb24gdG8gdGhlIGxlZnQKICAgIGZvciAoaW50IGsgPSAwOyBrIDwgMzsgKytrKSB7CiAgICAgIHN0YXRlW2tdW2ldID0gc3RhdGVbayArIDFdW2ldOwogICAgfQogIHN0YXRlWzNdW2ldID0gdGVtcDsgLy8gUGxhY2UgdGhlIHRlbXAgdmFsdWUgYXQgdGhlIGVuZAp9fX0=)1static  void  ShiftRows(state_t  state[4][4])  {2uint8_t  temp;3int  i,  j;4//  Loop  over  rows  1  to  3  (0-based  indexing)5for  (i  =  1;  i  <  4;  ++i)  {6//  Number  of  positions  to  left  shift  for  current  row7  int  shift  =  i;8  //  Use  a  separate  loop  for  the  number  of  shifts9  for  (j  =  0;  j  <  shift;  ++j)  {10  temp  =  state[0][i];  //  Store  the  element  to  be  shifted11  //  Shift  all  elements  by  one  position  to  the  left12  for  (int  k  =  0;  k  <  3;  ++k)  {13  state[k][i]  =  state[k  +  1][i];14  }15  state[3][i]  =  temp;  //  Place  the  temp  value  at  the  end16}}}'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4: Removing pointers and inlining.'
  prefs: []
  type: TYPE_NORMAL
- en: III-D Discussion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using LLMs for refactoring C code into HLS-compatible formats is a promising
    avenue in LLM aided design. The LLM, in our case Google’s Gemini, refactored reference
    C implementations of NIST 800-22 randomness tests, QuickSort, and AES-128\. The
    LLM’s ability to iteratively refactor the code based on user instructions significantly
    reduces manual effort in adapting code for HLS tools. This can streamline the
    hardware design process, especially for repetitive tasks. The LLM effectively
    addressed challenges like converting code from memory-based data processing to
    streaming, from recursion to iteration and pointers. While the LLM achieved core
    functionalities, it occasionally struggled with minor details requiring several
    iterations to guide it to the correct solution. In a practical scenario, a developer
    can rectify these minor errors. However, for an automated flow, a feedback loop
    is crucial, like that in [[5](#bib.bib5)].
  prefs: []
  type: TYPE_NORMAL
- en: 'TABLE I: Resource Utilization and Latency Results'
  prefs: []
  type: TYPE_NORMAL
- en: '| Design | Area Score | # Operations | Latency |'
  prefs: []
  type: TYPE_TB
- en: '| This work | Manual | This work | Manual | This work | Manual |'
  prefs: []
  type: TYPE_TB
- en: '| NIST-Monobit | 244 | 225.3 | 19 | 19 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| NIST-Monobit Block | 702.3 | 826.0 | 24 | 20 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| NIST-Cusums | 677.4 | 632 | 24 | 28 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| NIST-Overlapping | 9933.4 | 7172.1 | 165 | 118 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| QuickSort | 18115.8 | n.a. | 67 | n.a. | 18 | n.a. |'
  prefs: []
  type: TYPE_TB
- en: '| AES | 38604.5 | n.a. | 1924 | n.a. | 160 | n.a. |'
  prefs: []
  type: TYPE_TB
- en: 'Table [I](#S3.T1 "Table I ‣ III-D Discussion ‣ III Case Study ‣ C2HLSC: Can
    LLMs Bridge the Software-to-Hardware Design Gap?") shows area for the implemented
    designs. For NIST test implementation we have reference designs that were implemented
    by a graduate student. We used the same directives for a fair comparison between
    the 2\. Area scores from Catapult are close. The manual implementations took around
    4 hours each while C2HLSC took between 30 to 60 minutes each. Although the sample
    size is limited, this shows the potential of LLMs in speeding up the process effectively
    and efficiently.'
  prefs: []
  type: TYPE_NORMAL
- en: IV Hands-Free C2HSLC Prototype
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the experience of the engineer-in-the-loop case studies, we implemented
    a hands-free C2HLSC prototype. The first insight from the case study was the twofold
    nature of the errors that can occur in the generated C — functional/compile errors
    and synthesis errors. The former kind can be caught by gcc. The latter kind can
    be caught by running the Catapult HLS tool. For this reason we setup a double
    feedback loop as shown in Figure [5](#S4.F5 "Figure 5 ‣ IV Hands-Free C2HSLC Prototype
    ‣ C2HLSC: Can LLMs Bridge the Software-to-Hardware Design Gap?"). One checks that
    the generated code compiles and passes reference tests, and one that checks that
    the code is synthesizable by Catapult HLS. We selected ChatGPT 3.5 Turbo as we
    did not have access to Gemini APIs. The flow is implemented in Python and will
    be made open source.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Refer to caption](img/19db92c791fe51fe72eb734807f8f2b3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5: Hands-free C2HSLC LLM-based prototype flow.'
  prefs: []
  type: TYPE_NORMAL
- en: We ran the flow on the QuickSort and AES C codes used in the case study. In
    the current version, the flow can handle only a limited number of functions at
    a time and so for AES we broke the code down into the individual functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'TABLE II: Hands-free C2HLSC LLM-based flow.'
  prefs: []
  type: TYPE_NORMAL
- en: '| Design | # Prompts | Area Score | # Ops | Latency |'
  prefs: []
  type: TYPE_TB
- en: '| QuickSort | 6 | 52184 | 1961 | 8 |'
  prefs: []
  type: TYPE_TB
- en: '| AddRoundKey | 9 | 702.3 | 837 | 210 |'
  prefs: []
  type: TYPE_TB
- en: '| ShiftRows | 1 | 23.9 | 3 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| MixColumns | 1 | 635.9 | 225 | 6 |'
  prefs: []
  type: TYPE_TB
- en: '| SubBytes | 1 | 1176.5 | 53 | 33 |'
  prefs: []
  type: TYPE_TB
- en: 'The flow was able to automatically rewrite the functions without any human
    intervention. We plan to expand it by allowing more functions at a time, and include
    better optimizations. The generated codes are in Appendix [-A](#A0.SS1 "-A LLM
    generated HLS compatible C codes ‣ C2HLSC: Can LLMs Bridge the Software-to-Hardware
    Design Gap?").'
  prefs: []
  type: TYPE_NORMAL
- en: V Conclusions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The case studies demonstrated the potential of LLMs in aiding HLS. The implemented
    prototype shows the potential of LLMs in aiding hardware design leveraging HLS.
    Future work includes the use of LLMs to discover architectural trade-offs by applying
    pragmas and directives. Together with the proposed flow, it will enable a seamless
    transition from C to HLS C to optimized hardware architectures.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[1] R. Nane, V.-M. Sima, C. Pilato, J. Choi, B. Fort, A. Canis, Y. T. Chen,
    H. Hsiao, S. Brown, F. Ferrandi, J. Anderson, and K. Bertels, “A survey and evaluation
    of fpga high-level synthesis tools,” *IEEE Transactions on CAD*, vol. 35, no. 10,
    pp. 1591–1604, 2016.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[2] D. Soni, M. Nabeel, K. Basu, and R. Karri, “Power, area, speed, and security
    (pass) trade-offs of nist pqc signature candidates using a c to asic design flow,”
    in *IEEE International Conference on Computer Design*, 2019, pp. 337–340.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[3] H. Pearce, B. Ahmad, B. Tan, B. Dolan-Gavitt, and R. Karri, “Asleep at
    the keyboard? assessing the security of github copilot’s code contributions,”
    in *IEEE Symposium on Security and Privacy*, 2022, pp. 754–768.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[4] S. Thakur, B. Ahmad, H. Pearce, B. Tan, B. Dolan-Gavitt, R. Karri, and
    S. Garg, “Verigen: A large language model for verilog code generation,” *ACM Trans.
    Des. Autom. Electron. Syst.*, feb 2024, just Accepted. [Online]. Available: [https://doi.org/10.1145/3643681](https://doi.org/10.1145/3643681)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[5] J. Blocklove, S. Garg, R. Karri, and H. Pearce, “Chip-chat: Challenges
    and opportunities in conversational hardware design,” in *2023 ACM/IEEE 5th Workshop
    on Machine Learning for CAD (MLCAD)*, 2023, pp. 1–6.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[6] J. T. Meech, “Leveraging high-level synthesis and large language models
    to generate, simulate, and deploy a uniform random number generator hardware design,”
    2024.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[7] “Bard: A large language model from google ai,” [https://blog.google/technology/ai/bard-google-ai-search-updates/](https://blog.google/technology/ai/bard-google-ai-search-updates/),
    accessed on 2024-04-06.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[8] “A statistical test suite for random and pseudorandom number generators
    for cryptographic applications (revision 1a),” April 2010, accessed on 2024-04-06\.
    [Online]. Available: [https://nvlpubs.nist.gov/nistpubs/legacy/sp/nistspecialpublication800-22r1a.pdf](https://nvlpubs.nist.gov/nistpubs/legacy/sp/nistspecialpublication800-22r1a.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[9] GeeksforGeeks, “Quick sort in c,” [https://www.geeksforgeeks.org/quick-sort-in-c/](https://www.geeksforgeeks.org/quick-sort-in-c/),
    accessed on 2024-04-06.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[10] K. [kokke], “tiny-aes-c,” [https://github.com/kokke/tiny-AES-c](https://github.com/kokke/tiny-AES-c),
    accessed on 2024-04-06.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[11] HLSLibs, “Hlslibs - high-level synthesis libraries,” [https://hlslibs.org/](https://hlslibs.org/),
    accessed on 2024-04-06.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: -A LLM generated HLS compatible C codes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section we report original codes and final codes of our case study.
    We cut print statements from the originals and comments from the results.
  prefs: []
  type: TYPE_NORMAL
- en: '[⬇](data:text/plain;base64,T3JpZ2luYWwgYyBjb2RlIChhZnRlciByZW1vdmluZyBwcmludGYgcykgICBcZW5ke2xzdGxpc3Rpbmd9Clx2c3BhY2V7LTdwdH0KICBcZW5ke3N1YmZpZ3VyZX0KICBcYmVnaW57c3ViZmlndXJlfVt0XXsuOVxjb2x1bW53aWR0aH0KICAgIFxiZWdpbntsc3RsaXN0aW5nfVtsYW5ndWFnZT1jXQp2b2lkIEZyZXF1ZW5jeShpbnQgbikKewoJaW50CQlpOwoJZG91YmxlCWYsIHNfb2JzLCBwX3ZhbHVlLCBzdW0sIHNxcnQyID0gMS40MTQyMTM1NjIzNzMwOTUwNDg4MDsKCXN1bSA9IDAuMDsKCWZvciAoIGk9MDsgaTxuOyBpKysgKQoJCXN1bSArPSAyKihpbnQpZXBzaWxvbltpXS0xOwoJc19vYnMgPSBmYWJzKHN1bSkvc3FydChuKTsKCWYgPSBzX29icy9zcXJ0MjsKCXBfdmFsdWUgPSBlcmZjKGYpOwp9)1Original  c  code  (after  removing  printf  s)  \end{lstlisting}2\vspace{-7pt}3  \end{subfigure}4  \begin{subfigure}[t]{.9\columnwidth}5  \begin{lstlisting}[language=c]6void  Frequency(int  n)7{8  int  i;9  double  f,  s_obs,  p_value,  sum,  sqrt2  =  1.41421356237309504880;10  sum  =  0.0;11  for  (  i=0;  i<n;  i++  )12  sum  +=  2*(int)epsilon[i]-1;13  s_obs  =  fabs(sum)/sqrt(n);14  f  =  s_obs/sqrt2;15  p_value  =  erfc(f);16}[⬇](data:text/plain;base64,SExTIGNvbXBhdGlibGUgY29kZSByZXdyaXR0ZW4gYnkgdGhlIExMTQ==)1HLS  compatible  code  rewritten  by  the  LLM[⬇](data:text/plain;base64,I2RlZmluZSBUQVJHRVRfQklUUyAxMjgKI2RlZmluZSBQX1ZBTFVFX1RIUkVTSE9MRCAwLjAxCiNkZWZpbmUgVEhSRVNIT0xEIDI5CnR5cGVkZWYgYWNfaW50PDksIHRydWU+IHN1bV90eXBlOyAgLy8gdHJ1ZSBmb3Igc2lnbmVkCnR5cGVkZWYgYWNfaW50PDgsIGZhbHNlPiBjb3VudF90eXBlOyAgLy8gZmFsc2UgZm9yIHVuc2lnbmVkCnR5cGVkZWYgYWNfaW50PDEsIGZhbHNlPiBiaXRfdHlwZTsKdm9pZApGcmVxdWVuY3lfQml0KGJpdF90eXBlICpiaXQsIGJpdF90eXBlICp2YWxpZCwgYml0X3R5cGUgKnJlc3VsdCkKewogIHN0YXRpYyBzdW1fdHlwZSAgICBzdW0gPSAwOwogIHN0YXRpYyBjb3VudF90eXBlIGNvdW50ID0gMDsKICBzdW0gKz0gKCpiaXQpID8gc3VtX3R5cGUoMSkgOiBzdW1fdHlwZSgtMSk7CiAgY291bnQrKzsKICBpZiAoY291bnQgPT0gVEFSR0VUX0JJVFMpIHsKICAgIC8vIENoZWNrIGlmIHN1bSBpcyB3aXRoaW4gdGhlIHRocmVzaG9sZCByYW5nZQogICAgKnJlc3VsdCA9IChzdW0gPD0gVEhSRVNIT0xEKSAmJiAoc3VtID49IC1USFJFU0hPTEQpOwogICAgKnZhbGlkID0gMTsKICAgIGNvdW50ID0gMDsKICAgIHN1bSA9IDA7CiAgfSBlbHNlIHsKICAgICpyZXN1bHQgPSAwOwogICAgKnZhbGlkID0gMDsKfX0=)1#define  TARGET_BITS  1282#define  P_VALUE_THRESHOLD  0.013#define  THRESHOLD  294typedef  ac_int<9,  true>  sum_type;  //  true  for  signed5typedef  ac_int<8,  false>  count_type;  //  false  for  unsigned6typedef  ac_int<1,  false>  bit_type;7void8Frequency_Bit(bit_type  *bit,  bit_type  *valid,  bit_type  *result)9{10  static  sum_type  sum  =  0;11  static  count_type  count  =  0;12  sum  +=  (*bit)  ?  sum_type(1)  :  sum_type(-1);13  count++;14  if  (count  ==  TARGET_BITS)  {15  //  Check  if  sum  is  within  the  threshold  range16  *result  =  (sum  <=  THRESHOLD)  &&  (sum  >=  -THRESHOLD);17  *valid  =  1;18  count  =  0;19  sum  =  0;20  }  else  {21  *result  =  0;22  *valid  =  0;23}}'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6: Human-in-the-loop Monobit'
  prefs: []
  type: TYPE_NORMAL
- en: '[⬇](data:text/plain;base64,T3JpZ2luYWwgYyBjb2RlIChhZnRlciByZW1vdmluZyBwcmludGYgcykgICBcZW5ke2xzdGxpc3Rpbmd9Clx2c3BhY2V7LTdwdH0KICBcZW5ke3N1YmZpZ3VyZX0KICBcYmVnaW57c3ViZmlndXJlfVt0XXsuOVxjb2x1bW53aWR0aH0KICAgIFxiZWdpbntsc3RsaXN0aW5nfVtsYW5ndWFnZT1jXQp2b2lkIEJsb2NrRnJlcXVlbmN5KGludCBNLCBpbnQgbikKewoJaW50CQlpLCBqLCBOLCBibG9ja1N1bTsKCWRvdWJsZQlwX3ZhbHVlLCBzdW0sIHBpLCB2LCBjaGlfc3F1YXJlZDsKCU4gPSBuL007IAkJLyogIyBPRiBTVUJTVFJJTkcgQkxPQ0tTICAgICAgKi8KCXN1bSA9IDAuMDsKCQoJZm9yICggaT0wOyBpPE47IGkrKyApIHsKCQlibG9ja1N1bSA9IDA7CgkJZm9yICggaj0wOyBqPE07IGorKyApCgkJCWJsb2NrU3VtICs9IGVwc2lsb25baitpKk1dOwoJCXBpID0gKGRvdWJsZSlibG9ja1N1bS8oZG91YmxlKU07CgkJdiA9IHBpIC0gMC41OwoJCXN1bSArPSB2KnY7Cgl9CgljaGlfc3F1YXJlZCA9IDQuMCAqIE0gKiBzdW07CglwX3ZhbHVlID0gY2VwaGVzX2lnYW1jKE4vMi4wLCBjaGlfc3F1YXJlZC8yLjApOwp9)1Original  c  code  (after  removing  printf  s)  \end{lstlisting}2\vspace{-7pt}3  \end{subfigure}4  \begin{subfigure}[t]{.9\columnwidth}5  \begin{lstlisting}[language=c]6void  BlockFrequency(int  M,  int  n)7{8  int  i,  j,  N,  blockSum;9  double  p_value,  sum,  pi,  v,  chi_squared;10  N  =  n/M;  /*  #  OF  SUBSTRING  BLOCKS  */11  sum  =  0.0;1213  for  (  i=0;  i<N;  i++  )  {14  blockSum  =  0;15  for  (  j=0;  j<M;  j++  )16  blockSum  +=  epsilon[j+i*M];17  pi  =  (double)blockSum/(double)M;18  v  =  pi  -  0.5;19  sum  +=  v*v;20  }21  chi_squared  =  4.0  *  M  *  sum;22  p_value  =  cephes_igamc(N/2.0,  chi_squared/2.0);23}[⬇](data:text/plain;base64,SExTIGNvbXBhdGlibGUgY29kZSByZXdyaXR0ZW4gYnkgdGhlIExMTQ==)1HLS  compatible  code  rewritten  by  the  LLM[⬇](data:text/plain;base64,dm9pZCBCbG9ja0ZyZXF1ZW5jeShhY19pbnQ8MSwgZmFsc2U+IGJpdCwgYWNfaW50PDEsIGZhbHNlPiYgdmFsaWQsIGFjX2ludDwxLCBmYWxzZT4mIHJlc3VsdCkgewogIHN0YXRpYyBhY19pbnQ8NywgZmFsc2U+IGJsb2NrU3VtID0gMDsKICBzdGF0aWMgYWNfZml4ZWQ8MTYsIDgsIGZhbHNlPiBzdW0gPSAwLjA7CiAgYWNfZml4ZWQ8OCwgNCwgZmFsc2U+IHBpX2ZpeGVkLCB2OwogIHN0YXRpYyBhY19pbnQ8NCwgZmFsc2U+IGkgPSAwOwogIHN0YXRpYyBhY19pbnQ8OCwgZmFsc2U+IGogPSAwOwogIGlmIChqID09IDApIHsKICAgIGkrKzsKICAgIGJsb2NrU3VtID0gMDsKICB9CiAgYmxvY2tTdW0gKz0gYml0OwogIGorKzsKICBpZiAoaiA9PSBCTE9DS19TSVpFKSB7CiAgICBwaV9maXhlZCA9IChhY19maXhlZDwxMiwgNCwgZmFsc2U+KSBibG9ja1N1bSAvIEJMT0NLX1NJWkU7CiAgICBjb25zdCBhY19maXhlZDw4LCA0LCBmYWxzZT4gaGFsZiA9IDAuNTsKICAgIHYgPSBwaV9maXhlZCAtIGhhbGY7CiAgICBzdW0gKz0gdiAqIHY7CiAgICBqID0gMDsKICB9CiAgaWYgKGkgPT0gTlVNX0JMT0NLUykgewogICAgY29uc3QgYWNfZml4ZWQ8MTYsIDgsIGZhbHNlPiB0aHJlc2hvbGQgPSAxMy44MTU1IC8gNTEyLjA7CiAgICB2YWxpZCA9IHRydWU7CiAgICByZXN1bHQgPSAoc3VtIDwgdGhyZXNob2xkKSA/IDAgOiAxOwogIH0gZWxzZSB7CiAgICB2YWxpZCA9IGZhbHNlOwogICAgcmVzdWx0ID0gMDsKfX0=)1void  BlockFrequency(ac_int<1,  false>  bit,  ac_int<1,  false>&  valid,  ac_int<1,  false>&  result)  {2  static  ac_int<7,  false>  blockSum  =  0;3  static  ac_fixed<16,  8,  false>  sum  =  0.0;4  ac_fixed<8,  4,  false>  pi_fixed,  v;5  static  ac_int<4,  false>  i  =  0;6  static  ac_int<8,  false>  j  =  0;7  if  (j  ==  0)  {8  i++;9  blockSum  =  0;10  }11  blockSum  +=  bit;12  j++;13  if  (j  ==  BLOCK_SIZE)  {14  pi_fixed  =  (ac_fixed<12,  4,  false>)  blockSum  /  BLOCK_SIZE;15  const  ac_fixed<8,  4,  false>  half  =  0.5;16  v  =  pi_fixed  -  half;17  sum  +=  v  *  v;18  j  =  0;19  }20  if  (i  ==  NUM_BLOCKS)  {21  const  ac_fixed<16,  8,  false>  threshold  =  13.8155  /  512.0;22  valid  =  true;23  result  =  (sum  <  threshold)  ?  0  :  1;24  }  else  {25  valid  =  false;26  result  =  0;27}}'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7: Human-in-the-loop Monobit Block'
  prefs: []
  type: TYPE_NORMAL
- en: '[⬇](data:text/plain;base64,T3JpZ2luYWwgYyBjb2RlIChhZnRlciByZW1vdmluZyBwcmludGYgcykgICBcZW5ke2xzdGxpc3Rpbmd9Clx2c3BhY2V7LTdwdH0KICBcZW5ke3N1YmZpZ3VyZX0KICBcYmVnaW57c3ViZmlndXJlfVt0XXsuOVxjb2x1bW53aWR0aH0KICAgIFxiZWdpbntsc3RsaXN0aW5nfVtsYW5ndWFnZT1jXQp2b2lkIEN1bXVsYXRpdmVTdW1zKGludCBuKSB7CiAgICBpbnQgUywgc3VwLCBpbmYsIHosIHpyZXYsIGs7CiAgICBkb3VibGUgc3VtMSwgc3VtMiwgcF92YWx1ZTsKICAgIFMgPSAwOyBzdXAgPSAwOyBpbmYgPSAwOwogICAgZm9yIChrID0gMDsgayA8IG47IGsrKykgewogICAgICAgIGVwc2lsb25ba10gPyBTKysgOiBTLS07CiAgICAgICAgaWYgKFMgPiBzdXApIHN1cCsrOwogICAgICAgIGlmIChTIDwgaW5mKSBpbmYtLTsKICAgICAgICB6ID0gKHN1cCA+IC1pbmYpID8gc3VwIDogLWluZjsKICAgICAgICB6cmV2ID0gKHN1cCAtIFMgPiBTIC0gaW5mKSA/IHN1cCAtIFMgOiBTIC0gaW5mO30KICAgIHN1bTEgPSAwLjA7IC8vIGZvcndhcmQKICAgIGZvciAoayA9ICgtbiAvIHogKyAxKSAvIDQ7IGsgPD0gKG4gLyB6IC0gMSkgLyA0OyBrKyspIHsKICAgICAgICBzdW0xICs9IGNlcGhlc19ub3JtYWwoKCg0ICogayArIDEpICogeikgLyBzcXJ0KG4pKTsKICAgICAgICBzdW0xIC09IGNlcGhlc19ub3JtYWwoKCg0ICogayAtIDEpICogeikgLyBzcXJ0KG4pKTt9CiAgICBzdW0yID0gMC4wOwogICAgZm9yIChrID0gKC1uIC8geiAtIDMpIC8gNDsgayA8PSAobiAvIHogLSAxKSAvIDQ7IGsrKykgewogICAgICAgIHN1bTIgKz0gY2VwaGVzX25vcm1hbCgoKDQgKiBrICsgMykgKiB6KSAvIHNxcnQobikpOwogICAgICAgIHN1bTIgLT0gY2VwaGVzX25vcm1hbCgoKDQgKiBrICsgMSkgKiB6KSAvIHNxcnQobikpO30KICAgIHBfdmFsdWUgPSAxLjAgLSBzdW0xICsgc3VtMjsKICAgIHN1bTEgPSAwLjA7IC8vIGJhY2t3YXJkcwogICAgZm9yIChrID0gKC1uIC8genJldiArIDEpIC8gNDsgayA8PSAobiAvIHpyZXYgLSAxKSAvIDQ7IGsrKykgewogICAgICAgIHN1bTEgKz0gY2VwaGVzX25vcm1hbCgoKDQgKiBrICsgMSkgKiB6cmV2KSAvIHNxcnQobikpOwogICAgICAgIHN1bTEgLT0gY2VwaGVzX25vcm1hbCgoKDQgKiBrIC0gMSkgKiB6cmV2KSAvIHNxcnQobikpO30KICAgIHN1bTIgPSAwLjA7CiAgICBmb3IgKGsgPSAoLW4gLyB6cmV2IC0gMykgLyA0OyBrIDw9IChuIC8genJldiAtIDEpIC8gNDsgaysrKSB7CiAgICAgICAgc3VtMiArPSBjZXBoZXNfbm9ybWFsKCgoNCAqIGsgKyAzKSAqIHpyZXYpIC8gc3FydChuKSk7CiAgICAgICAgc3VtMiAtPSBjZXBoZXNfbm9ybWFsKCgoNCAqIGsgKyAxKSAqIHpyZXYpIC8gc3FydChuKSk7fQogICAgcF92YWx1ZSA9IDEuMCAtIHN1bTEgKyBzdW0yO30=)1Original  c  code  (after  removing  printf  s)  \end{lstlisting}2\vspace{-7pt}3  \end{subfigure}4  \begin{subfigure}[t]{.9\columnwidth}5  \begin{lstlisting}[language=c]6void  CumulativeSums(int  n)  {7  int  S,  sup,  inf,  z,  zrev,  k;8  double  sum1,  sum2,  p_value;9  S  =  0;  sup  =  0;  inf  =  0;10  for  (k  =  0;  k  <  n;  k++)  {11  epsilon[k]  ?  S++  :  S--;12  if  (S  >  sup)  sup++;13  if  (S  <  inf)  inf--;14  z  =  (sup  >  -inf)  ?  sup  :  -inf;15  zrev  =  (sup  -  S  >  S  -  inf)  ?  sup  -  S  :  S  -  inf;}16  sum1  =  0.0;  //  forward17  for  (k  =  (-n  /  z  +  1)  /  4;  k  <=  (n  /  z  -  1)  /  4;  k++)  {18  sum1  +=  cephes_normal(((4  *  k  +  1)  *  z)  /  sqrt(n));19  sum1  -=  cephes_normal(((4  *  k  -  1)  *  z)  /  sqrt(n));}20  sum2  =  0.0;21  for  (k  =  (-n  /  z  -  3)  /  4;  k  <=  (n  /  z  -  1)  /  4;  k++)  {22  sum2  +=  cephes_normal(((4  *  k  +  3)  *  z)  /  sqrt(n));23  sum2  -=  cephes_normal(((4  *  k  +  1)  *  z)  /  sqrt(n));}24  p_value  =  1.0  -  sum1  +  sum2;25  sum1  =  0.0;  //  backwards26  for  (k  =  (-n  /  zrev  +  1)  /  4;  k  <=  (n  /  zrev  -  1)  /  4;  k++)  {27  sum1  +=  cephes_normal(((4  *  k  +  1)  *  zrev)  /  sqrt(n));28  sum1  -=  cephes_normal(((4  *  k  -  1)  *  zrev)  /  sqrt(n));}29  sum2  =  0.0;30  for  (k  =  (-n  /  zrev  -  3)  /  4;  k  <=  (n  /  zrev  -  1)  /  4;  k++)  {31  sum2  +=  cephes_normal(((4  *  k  +  3)  *  zrev)  /  sqrt(n));32  sum2  -=  cephes_normal(((4  *  k  +  1)  *  zrev)  /  sqrt(n));}33  p_value  =  1.0  -  sum1  +  sum2;}[⬇](data:text/plain;base64,SExTIGNvbXBhdGlibGUgY29kZSByZXdyaXR0ZW4gYnkgdGhlIExMTQ==)1HLS  compatible  code  rewritten  by  the  LLM[⬇](data:text/plain;base64,I2RlZmluZSBOICAyMDAwMAojZGVmaW5lIFRIUkVTSE9MRCAoYWNfaW50PDEyLCBmYWxzZT4pMzk3CnZvaWQgQ3VtdWxhdGl2ZVN1bXNfU3RyZWFtaW5nKGFjX2ludDwxLCBmYWxzZT4gYml0LCBhY19pbnQ8MSwgZmFsc2U+KiBvdXRwdXQsIGFjX2ludDwxLCBmYWxzZT4qIHZhbGlkKSB7CiAgc3RhdGljIGFjX2ludDwxMiwgZmFsc2U+IFMgPSAwOwogIHN0YXRpYyBhY19pbnQ8MTIsIGZhbHNlPiBzdXAgPSAwOwogIHN0YXRpYyBhY19pbnQ8MTIsIGZhbHNlPiBpbmYgPSAwOwogIFMgKz0gYml0ID8gMSA6IC0xOwogIHN1cCA9IHN1cCA+IFMgPyBzdXAgOiBTOwogIGluZiA9IGluZiA8IFMgPyBpbmYgOiBTOwogIC8vIExvZ2ljIGZvciBvdXRwdXQgYmFzZWQgb24gc3VwIGFuZCBpbmYKICBzdGF0aWMgYWNfaW50PDE2LCBmYWxzZT4gcHJvY2Vzc2VkX2JpdHMgPSAwOwogIHByb2Nlc3NlZF9iaXRzKys7CiAgaWYgKHByb2Nlc3NlZF9iaXRzID09IE4pIHsKICAgICpvdXRwdXQgPSAoc3VwIDwgVEhSRVNIT0xEICYmIGluZiA+IC1USFJFU0hPTEQpID8gMSA6IDA7CiAgICAqdmFsaWQgPSAocHJvY2Vzc2VkX2JpdHMgPT0gTik7CiAgICBwcm9jZXNzZWRfYml0cyA9IDA7CiAgfSBlbHNlIHsKICAgICpvdXRwdXQgPSAwOwogICAgKnZhbGlkID0gMDsKfX0=)1#define  N  200002#define  THRESHOLD  (ac_int<12,  false>)3973void  CumulativeSums_Streaming(ac_int<1,  false>  bit,  ac_int<1,  false>*  output,  ac_int<1,  false>*  valid)  {4  static  ac_int<12,  false>  S  =  0;5  static  ac_int<12,  false>  sup  =  0;6  static  ac_int<12,  false>  inf  =  0;7  S  +=  bit  ?  1  :  -1;8  sup  =  sup  >  S  ?  sup  :  S;9  inf  =  inf  <  S  ?  inf  :  S;10  //  Logic  for  output  based  on  sup  and  inf11  static  ac_int<16,  false>  processed_bits  =  0;12  processed_bits++;13  if  (processed_bits  ==  N)  {14  *output  =  (sup  <  THRESHOLD  &&  inf  >  -THRESHOLD)  ?  1  :  0;15  *valid  =  (processed_bits  ==  N);16  processed_bits  =  0;17  }  else  {18  *output  =  0;19  *valid  =  0;20}}'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8: Human-in-the-loop Cusums'
  prefs: []
  type: TYPE_NORMAL
- en: '[⬇](data:text/plain;base64,T3JpZ2luYWwgYyBjb2RlIChhZnRlciByZW1vdmluZyBwcmludGYgcykgICBcZW5ke2xzdGxpc3Rpbmd9Clx2c3BhY2V7LTdwdH0KICBcZW5ke3N1YmZpZ3VyZX0KICBcYmVnaW57c3ViZmlndXJlfVt0XXsuOVxjb2x1bW53aWR0aH0KICAgIFxiZWdpbntsc3RsaXN0aW5nfVtsYW5ndWFnZT1jXQp2b2lkIE92ZXJsYXBwaW5nVGVtcGxhdGVNYXRjaGluZ3MoaW50IG0sIGludCBuKQp7CmludAkJCQlpLCBrLCBtYXRjaDsKZG91YmxlCQkJV19vYnMsIGV0YSwgc3VtLCBjaGkyLCBwX3ZhbHVlLCBsYW1iZGE7CmludAkJCQlNLCBOLCBqLCBLID0gNTsKdW5zaWduZWQgaW50CW51WzZdID0geyAwLCAwLCAwLCAwLCAwLCAwIH07Ci8vZG91YmxlCQkJcGlbNl0gPSB7IDAuMTQzNzgzLCAwLjEzOTQzMCwgMC4xMzczMTksIDAuMTI0MzE0LCAwLjEwNjIwOSwgMC4zNDg5NDUgfTsKZG91YmxlCQkJcGlbNl0gPSB7IDAuMzY0MDkxLCAwLjE4NTY1OSwgMC4xMzkzODEsIDAuMTAwNTcxLCAwLjA3MDQzMjMsIDAuMTM5ODY1IH07CkJpdFNlcXVlbmNlCQkqc2VxdWVuY2U7Ck0gPSAxMDMyOwpOID0gbi9NOwppZiAoIChzZXF1ZW5jZSA9IChCaXRTZXF1ZW5jZSAqKSBjYWxsb2MobSwgc2l6ZW9mKEJpdFNlcXVlbmNlKSkpID09IE5VTEwgKSB7CiAgICAvLyBFUlJPUgp9CmVsc2UKICAgIGZvciAoIGk9MDsgaTxtOyBpKysgKQogICAgICAgIHNlcXVlbmNlW2ldID0gMTsKbGFtYmRhID0gKGRvdWJsZSkoTS1tKzEpL3BvdygyLG0pOwpldGEgPSBsYW1iZGEvMi4wOwpzdW0gPSAwLjA7CmZvciAoIGk9MDsgaTxLOyBpKysgKSB7CQkJLyogQ29tcHV0ZSBQcm9iYWJpbGl0aWVzICovCiAgICBwaVtpXSA9IFByKGksIGV0YSk7CiAgICBzdW0gKz0gcGlbaV07Cn0KcGlbS10gPSAxIC0gc3VtOwoKZm9yICggaT0wOyBpPE47IGkrKyApIHsKICBXX29icyA9IDA7CiAgZm9yICggaj0wOyBqPE0tbSsxOyBqKysgKSB7CiAgICBtYXRjaCA9IDE7CiAgICBmb3IgKCBrPTA7IGs8bTsgaysrICkgewogICAgIGlmICggc2VxdWVuY2Vba10gIT0gZXBzaWxvbltpKk0raitrXSApCiAgICAgICAgbWF0Y2ggPSAwOwogICAgIH0KICAgICBpZiAoIG1hdGNoID09IDEgKQogICAgICAgV19vYnMrKzsKICAgIH0KICAgIGlmICggV19vYnMgPD0gNCApCiAgICAgbnVbKGludClXX29ic10rKzsKICAgIGVsc2UKICAgICBudVtLXSsrOwp9CnN1bSA9IDA7CmNoaTIgPSAwLjA7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBDb21wdXRlIENoaSBTcXVhcmUgKi8KZm9yICggaT0wOyBpPEsrMTsgaSsrICkgewogICAgY2hpMiArPSBwb3coKGRvdWJsZSludVtpXSAtIChkb3VibGUpTipwaVtpXSwgMikvKChkb3VibGUpTipwaVtpXSk7CiAgICBzdW0gKz0gbnVbaV07Cn0KcF92YWx1ZSA9IGNlcGhlc19pZ2FtYyhLLzIuMCwgY2hpMi8yLjApOwp9)1Original  c  code  (after  removing  printf  s)  \end{lstlisting}2\vspace{-7pt}3  \end{subfigure}4  \begin{subfigure}[t]{.9\columnwidth}5  \begin{lstlisting}[language=c]6void  OverlappingTemplateMatchings(int  m,  int  n)7{8int  i,  k,  match;9double  W_obs,  eta,  sum,  chi2,  p_value,  lambda;10int  M,  N,  j,  K  =  5;11unsigned  int  nu[6]  =  {  0,  0,  0,  0,  0,  0  };12//double  pi[6]  =  {  0.143783,  0.139430,  0.137319,  0.124314,  0.106209,  0.348945  };13double  pi[6]  =  {  0.364091,  0.185659,  0.139381,  0.100571,  0.0704323,  0.139865  };14BitSequence  *sequence;15M  =  1032;16N  =  n/M;17if  (  (sequence  =  (BitSequence  *)  calloc(m,  sizeof(BitSequence)))  ==  NULL  )  {18  //  ERROR19}20else21  for  (  i=0;  i<m;  i++  )22  sequence[i]  =  1;23lambda  =  (double)(M-m+1)/pow(2,m);24eta  =  lambda/2.0;25sum  =  0.0;26for  (  i=0;  i<K;  i++  )  {  /*  Compute  Probabilities  */27  pi[i]  =  Pr(i,  eta);28  sum  +=  pi[i];29}30pi[K]  =  1  -  sum;3132for  (  i=0;  i<N;  i++  )  {33  W_obs  =  0;34  for  (  j=0;  j<M-m+1;  j++  )  {35  match  =  1;36  for  (  k=0;  k<m;  k++  )  {37  if  (  sequence[k]  !=  epsilon[i*M+j+k]  )38  match  =  0;39  }40  if  (  match  ==  1  )41  W_obs++;42  }43  if  (  W_obs  <=  4  )44  nu[(int)W_obs]++;45  else46  nu[K]++;47}48sum  =  0;49chi2  =  0.0;  /*  Compute  Chi  Square  */50for  (  i=0;  i<K+1;  i++  )  {51  chi2  +=  pow((double)nu[i]  -  (double)N*pi[i],  2)/((double)N*pi[i]);52  sum  +=  nu[i];53}54p_value  =  cephes_igamc(K/2.0,  chi2/2.0);55}'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9: Overlapping Original'
  prefs: []
  type: TYPE_NORMAL
- en: '[⬇](data:text/plain;base64,SExTIGNvbXBhdGlibGUgY29kZSByZXdyaXR0ZW4gYnkgdGhlIExMTQ==)1HLS  compatible  code  rewritten  by  the  LLM[⬇](data:text/plain;base64,I2RlZmluZSBOIDEwNDg1NzYKI2RlZmluZSBNIDEwMzIKI2RlZmluZSBOX1dJRFRIIDIwCiNkZWZpbmUgTV9XSURUSCAxMAojZGVmaW5lIENISTJfVEhSRVNIT0xEX0ZJWEVEIGFjX2ZpeGVkPDIxLCAyMSwgZmFsc2U+KDEwNTYzMDAuMCkKdm9pZCBPdmVybGFwcGluZ1RlbXBsYXRlTWF0Y2hpbmdzKGludCBlcHNpbG9uLCBhY19pbnQ8MSwgZmFsc2U+ICppc19yYW5kb21fb3V0LCBhY19pbnQ8MSwgZmFsc2U+ICp2YWxpZF9vdXRwdXRfb3V0KSB7CiAgc3RhdGljIGFjX2ludDw5LCBmYWxzZT4gV19vYnMgPSAwOwogIHN0YXRpYyBhY19pbnQ8MTAsIGZhbHNlPiBudVs2XSA9IHswLCAwLCAwLCAwLCAwLCAwfTsKICBzdGF0aWMgYWNfaW50PDksIGZhbHNlPiBzaGlmdF9yZWdbOV0gPSB7MH07CiAgc3RhdGljIGFjX2ludDxOX1dJRFRIKzEsIGZhbHNlPiBuX2NvdW50ZXIgPSAwOwogIHN0YXRpYyBjb25zdCBhY19maXhlZDwzMiwgMTYsIGZhbHNlPiBwaVs2XSA9IHsKICAgIDIuNzQ2NTY2LAogICAgYWNfZml4ZWQ8MzIsIDE2LCBmYWxzZT4oNS4zODYyMTgpLCBhY19maXhlZDwzMiwgMTYsIGZhbHNlPig3LjE3NDU3KSwKICAgIGFjX2ZpeGVkPDMyLCAxNiwgZmFsc2U+KDkuOTQzMjIpLCBhY19maXhlZDwzMiwgMTYsIGZhbHNlPigxNC4xOTgwMzEpLCBhY19maXhlZDwzMiwgMTYsIGZhbHNlPig3LjE0OTc1MTUpCiAgfTsKYWNfZml4ZWQ8MjMsIDIyPiBjaGkyID0gMDsKICBmb3IgKGludCBpID0gODsgaSA+IDA7IGktLSkgewogICAgc2hpZnRfcmVnW2ldID0gc2hpZnRfcmVnW2kgLSAxXTsKICB9CiAgc2hpZnRfcmVnWzBdID0gYWNfaW50PDEsIGZhbHNlPihlcHNpbG9uKTsKICBhY19pbnQ8MSwgZmFsc2U+IG1hdGNoID0gMTsKICBmb3IgKGludCBpID0gMDsgaSA8IDk7IGkrKykgewogICAgaWYgKHNoaWZ0X3JlZ1tpXSAhPSAxKSB7CiAgICAgIG1hdGNoID0gMDsKICAgICAgYnJlYWs7CiAgICB9CiAgfQogIGlmIChtYXRjaCkgewogICAgV19vYnMrKzsKICB9CiAgbl9jb3VudGVyKys7CiAgaWYgKG5fY291bnRlciAlIE0gPT0gTS0xKSB7CiAgICBpZiAoV19vYnMgPD0gNCkgewogICAgICBudVsoaW50KVdfb2JzXSsrOwogICAgfSBlbHNlIHsKICAgICAgbnVbNV0rKzsKICAgIH0KICAgIFdfb2JzID0gMDsKICB9CiAgKmlzX3JhbmRvbV9vdXQgPSAwOwogICp2YWxpZF9vdXRwdXRfb3V0ID0gMDsKICBpZiAobl9jb3VudGVyID09IE4pIHsKICAgIGZvciAoaW50IGkgPSAwOyBpIDwgNjsgaSsrKSB7CiAgICAgICAgY2hpMiArPSAgbnVbaV0gKiBudSBbaV0gKiBwaVtpXTsKICAgIH0KICAgICppc19yYW5kb21fb3V0ID0gY2hpMiA8IENISTJfVEhSRVNIT0xEX0ZJWEVEOwogICp2YWxpZF9vdXRwdXRfb3V0ID0gdHJ1ZTsKICAgIGZvciAoaW50IGkgPSAwOyBpIDwgNjsgaSsrKSB7CiAgICAgIG51W2ldID0gMDsKICAgIH0KICAgIG5fY291bnRlciA9IDA7Cn19)1#define  N  10485762#define  M  10323#define  N_WIDTH  204#define  M_WIDTH  105#define  CHI2_THRESHOLD_FIXED  ac_fixed<21,  21,  false>(1056300.0)6void  OverlappingTemplateMatchings(int  epsilon,  ac_int<1,  false>  *is_random_out,  ac_int<1,  false>  *valid_output_out)  {7  static  ac_int<9,  false>  W_obs  =  0;8  static  ac_int<10,  false>  nu[6]  =  {0,  0,  0,  0,  0,  0};9  static  ac_int<9,  false>  shift_reg[9]  =  {0};10  static  ac_int<N_WIDTH+1,  false>  n_counter  =  0;11  static  const  ac_fixed<32,  16,  false>  pi[6]  =  {12  2.746566,13  ac_fixed<32,  16,  false>(5.386218),  ac_fixed<32,  16,  false>(7.17457),14  ac_fixed<32,  16,  false>(9.94322),  ac_fixed<32,  16,  false>(14.198031),  ac_fixed<32,  16,  false>(7.1497515)15  };16ac_fixed<23,  22>  chi2  =  0;17  for  (int  i  =  8;  i  >  0;  i--)  {18  shift_reg[i]  =  shift_reg[i  -  1];19  }20  shift_reg[0]  =  ac_int<1,  false>(epsilon);21  ac_int<1,  false>  match  =  1;22  for  (int  i  =  0;  i  <  9;  i++)  {23  if  (shift_reg[i]  !=  1)  {24  match  =  0;25  break;26  }27  }28  if  (match)  {29  W_obs++;30  }31  n_counter++;32  if  (n_counter  %  M  ==  M-1)  {33  if  (W_obs  <=  4)  {34  nu[(int)W_obs]++;35  }  else  {36  nu[5]++;37  }38  W_obs  =  0;39  }40  *is_random_out  =  0;41  *valid_output_out  =  0;42  if  (n_counter  ==  N)  {43  for  (int  i  =  0;  i  <  6;  i++)  {44  chi2  +=  nu[i]  *  nu  [i]  *  pi[i];45  }46  *is_random_out  =  chi2  <  CHI2_THRESHOLD_FIXED;47  *valid_output_out  =  true;48  for  (int  i  =  0;  i  <  6;  i++)  {49  nu[i]  =  0;50  }51  n_counter  =  0;52}}'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10: Human-in-the-loop Overlapping'
  prefs: []
  type: TYPE_NORMAL
- en: '[⬇](data:text/plain;base64,T3JpZ2luYWwgYyBjb2RlIChhZnRlciByZW1vdmluZyBwcmludGYgcykgICBcZW5ke2xzdGxpc3Rpbmd9Clx2c3BhY2V7LTdwdH0KICBcZW5ke3N1YmZpZ3VyZX0KICBcYmVnaW57c3ViZmlndXJlfVt0XXsuOVxjb2x1bW53aWR0aH0KICAgIFxiZWdpbntsc3RsaXN0aW5nfVtsYW5ndWFnZT1jXQp2b2lkIHN3YXAoaW50KiBhLCBpbnQqIGIpIHsKICAgIGludCB0ZW1wID0gKmE7CiAgICAqYSA9ICpiOwogICAgKmIgPSB0ZW1wOyB9CiAgaW50IHBhcnRpdGlvbihpbnQgYXJyW10sIGludCBsb3csIGludCBoaWdoKSB7CiAgICBpbnQgcGl2b3QgPSBhcnJbbG93XTsKICAgIGludCBpID0gbG93OwogICAgaW50IGogPSBoaWdoOwogICAgd2hpbGUgKGkgPCBqKSB7CiAgICAgICAgd2hpbGUgKGFycltpXSA8PSBwaXZvdCAmJiBpIDw9IGhpZ2ggLSAxKSB7CiAgICAgICAgICAgIGkrKzsKICAgICAgICB9CiAgICAgICAgd2hpbGUgKGFycltqXSA+IHBpdm90ICYmIGogPj0gbG93ICsgMSkgewogICAgICAgICAgICBqLS07CiAgICAgICAgfQogICAgICAgIGlmIChpIDwgaikgewogICAgICAgICAgICBzd2FwKCZhcnJbaV0sICZhcnJbal0pOwogICAgICAgIH0KICAgIH0KICAgIHN3YXAoJmFycltsb3ddLCAmYXJyW2pdKTsKICAgIHJldHVybiBqOyB9CnZvaWQgcXVpY2tTb3J0KGludCBhcnJbXSwgaW50IGxvdywgaW50IGhpZ2gpIHsKICAgIGlmIChsb3cgPCBoaWdoKSB7CiAgICAgICAgaW50IHBhcnRpdGlvbkluZGV4ID0gcGFydGl0aW9uKGFyciwgbG93LCBoaWdoKTsKICAgICAgICBxdWlja1NvcnQoYXJyLCBsb3csIHBhcnRpdGlvbkluZGV4IC0gMSk7CiAgICAgICAgcXVpY2tTb3J0KGFyciwgcGFydGl0aW9uSW5kZXggKyAxLCBoaWdoKTsKfSB9)1Original  c  code  (after  removing  printf  s)  \end{lstlisting}2\vspace{-7pt}3  \end{subfigure}4  \begin{subfigure}[t]{.9\columnwidth}5  \begin{lstlisting}[language=c]6void  swap(int*  a,  int*  b)  {7  int  temp  =  *a;8  *a  =  *b;9  *b  =  temp;  }10  int  partition(int  arr[],  int  low,  int  high)  {11  int  pivot  =  arr[low];12  int  i  =  low;13  int  j  =  high;14  while  (i  <  j)  {15  while  (arr[i]  <=  pivot  &&  i  <=  high  -  1)  {16  i++;17  }18  while  (arr[j]  >  pivot  &&  j  >=  low  +  1)  {19  j--;20  }21  if  (i  <  j)  {22  swap(&arr[i],  &arr[j]);23  }24  }25  swap(&arr[low],  &arr[j]);26  return  j;  }27void  quickSort(int  arr[],  int  low,  int  high)  {28  if  (low  <  high)  {29  int  partitionIndex  =  partition(arr,  low,  high);30  quickSort(arr,  low,  partitionIndex  -  1);31  quickSort(arr,  partitionIndex  +  1,  high);32}  }'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11: Quicksort original'
  prefs: []
  type: TYPE_NORMAL
- en: '[⬇](data:text/plain;base64,SExTIGNvbXBhdGlibGUgY29kZSByZXdyaXR0ZW4gYnkgdGhlIExMTQ==)1HLS  compatible  code  rewritten  by  the  LLM[⬇](data:text/plain;base64,aW50IHBhcnRpdGlvbihpbnQgYXJyW01BWF9TSVpFXSwgaW50IGxvdywgaW50IGhpZ2gpIHt9CiAgICBpbnQgcGl2b3QgPSBhcnJbbG93XTsKICAgIGludCBpID0gbG93OwogICAgaW50IGogPSBoaWdoOwogICAgaWYgKGxvdyA9PSBoaWdoKSB7CiAgICAgICAgcmV0dXJuIGxvdzsKICAgIH0KICAgIHdoaWxlIChpIDwgaikgewogICAgICAgIHdoaWxlIChhcnJbaV0gPD0gcGl2b3QgJiYgaSA8PSBoaWdoIC0gMSkgewogICAgICAgICAgICBpKys7CiAgICAgICAgfQogICAgICAgIHdoaWxlIChhcnJbal0gPiBwaXZvdCAmJiBqID49IGxvdyArIDEpIHsKICAgICAgICAgICAgai0tOwogICAgICAgIH0KICAgICAgICBpZiAoaSA8IGopIHsKICAgICAgICAgICAgaW50IHRlbXAgPSBhcnJbaV07CiAgICAgICAgICAgIGFycltpXSA9IGFycltqXTsKICAgICAgICAgICAgYXJyW2pdID0gdGVtcDsKICAgICAgICB9CiAgICB9CiAgICBpbnQgdGVtcCA9IGFycltsb3ddOwogICAgYXJyW2xvd10gPSBhcnJbal07CiAgICBhcnJbal0gPSB0ZW1wOwogICAgcmV0dXJuIGo7Cn0Kdm9pZCBxdWlja1NvcnQoaW50IGFycltNQVhfU0laRV0sIGludCBsb3csIGludCBoaWdoKSB7CmludCBzdGFja1sxMDBdOwppbnQgdG9wID0gLTE7CmlmIChoaWdoIC0gbG93ICsgMSA+IE1BWF9TSVpFKSB7CiAgICByZXR1cm47Cn0Kc3RhY2tbKyt0b3BdID0gbG93OwpzdGFja1srK3RvcF0gPSBoaWdoOwp3aGlsZSAodG9wID49IDApIHsKICAgIGhpZ2ggPSBzdGFja1t0b3AtLV07CiAgICBsb3cgPSBzdGFja1t0b3AtLV07CiAgICBpbnQgcGFydGl0aW9uSW5kZXggPSBwYXJ0aXRpb24oYXJyLCBsb3csIGhpZ2gpOwogICAgaWYgKHBhcnRpdGlvbkluZGV4ICsgMSA8IGhpZ2gpIHsKICAgICAgICBzdGFja1srK3RvcF0gPSBwYXJ0aXRpb25JbmRleCArIDE7CiAgICAgICAgc3RhY2tbKyt0b3BdID0gaGlnaDsKICAgIH0KICAgIGlmIChsb3cgPCBwYXJ0aXRpb25JbmRleCAtIDEpIHsKICAgICAgICBzdGFja1srK3RvcF0gPSBsb3c7CiAgICAgICAgc3RhY2tbKyt0b3BdID0gcGFydGl0aW9uSW5kZXggLSAxOwp9fX0=)1int  partition(int  arr[MAX_SIZE],  int  low,  int  high)  {}2  int  pivot  =  arr[low];3  int  i  =  low;4  int  j  =  high;5  if  (low  ==  high)  {6  return  low;7  }8  while  (i  <  j)  {9  while  (arr[i]  <=  pivot  &&  i  <=  high  -  1)  {10  i++;11  }12  while  (arr[j]  >  pivot  &&  j  >=  low  +  1)  {13  j--;14  }15  if  (i  <  j)  {16  int  temp  =  arr[i];17  arr[i]  =  arr[j];18  arr[j]  =  temp;19  }20  }21  int  temp  =  arr[low];22  arr[low]  =  arr[j];23  arr[j]  =  temp;24  return  j;25}26void  quickSort(int  arr[MAX_SIZE],  int  low,  int  high)  {27int  stack[100];28int  top  =  -1;29if  (high  -  low  +  1  >  MAX_SIZE)  {30  return;31}32stack[++top]  =  low;33stack[++top]  =  high;34while  (top  >=  0)  {35  high  =  stack[top--];36  low  =  stack[top--];37  int  partitionIndex  =  partition(arr,  low,  high);38  if  (partitionIndex  +  1  <  high)  {39  stack[++top]  =  partitionIndex  +  1;40  stack[++top]  =  high;41  }42  if  (low  <  partitionIndex  -  1)  {43  stack[++top]  =  low;44  stack[++top]  =  partitionIndex  -  1;45}}}'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12: Human-in-the-loop Quicksort'
  prefs: []
  type: TYPE_NORMAL
- en: '[⬇](data:text/plain;base64,T3JpZ2luYWwgYyBjb2RlIChhZnRlciByZW1vdmluZyBwcmludGYgcykgICBcZW5ke2xzdGxpc3Rpbmd9Clx2c3BhY2V7LTdwdH0KICBcZW5ke3N1YmZpZ3VyZX0KICBcYmVnaW57c3ViZmlndXJlfVt0XXsuOVxjb2x1bW53aWR0aH0KICAgIFxiZWdpbntsc3RsaXN0aW5nfVtsYW5ndWFnZT1jXQpzdGF0aWMgdm9pZCBDaXBoZXIoc3RhdGVfdCogc3RhdGUsIGNvbnN0IHVpbnQ4X3QqIFJvdW5kS2V5KQp7CiAgdWludDhfdCByb3VuZCA9IDA7CiAgQWRkUm91bmRLZXkoMCwgc3RhdGUsIFJvdW5kS2V5KTsKICBmb3IgKHJvdW5kID0gMTsgOyArK3JvdW5kKQogIHsKICAgIFN1YkJ5dGVzKHN0YXRlKTsKICAgIFNoaWZ0Um93cyhzdGF0ZSk7CiAgICBpZiAocm91bmQgPT0gTnIpIHsKICAgICAgYnJlYWs7CiAgICB9CiAgICBNaXhDb2x1bW5zKHN0YXRlKTsKICAgIEFkZFJvdW5kS2V5KHJvdW5kLCBzdGF0ZSwgUm91bmRLZXkpOwogIH0KICBBZGRSb3VuZEtleShOciwgc3RhdGUsIFJvdW5kS2V5KTsKfQ==)1Original  c  code  (after  removing  printf  s)  \end{lstlisting}2\vspace{-7pt}3  \end{subfigure}4  \begin{subfigure}[t]{.9\columnwidth}5  \begin{lstlisting}[language=c]6static  void  Cipher(state_t*  state,  const  uint8_t*  RoundKey)7{8  uint8_t  round  =  0;9  AddRoundKey(0,  state,  RoundKey);10  for  (round  =  1;  ;  ++round)11  {12  SubBytes(state);13  ShiftRows(state);14  if  (round  ==  Nr)  {15  break;16  }17  MixColumns(state);18  AddRoundKey(round,  state,  RoundKey);19  }20  AddRoundKey(Nr,  state,  RoundKey);21}[⬇](data:text/plain;base64,SExTIGNvbXBhdGlibGUgY29kZSByZXdyaXR0ZW4gYnkgdGhlIExMTQ==)1HLS  compatible  code  rewritten  by  the  LLM[⬇](data:text/plain;base64,dm9pZCBDaXBoZXIoc3RhdGVfdCBzdGF0ZVs0XVs0XSwgY29uc3QgdWludDhfdCBSb3VuZEtleVtBRVNfa2V5RXhwU2l6ZV0pIHsKICB1aW50OF90IHJvdW5kOwogIEFkZFJvdW5kS2V5KDAsIHN0YXRlLCBSb3VuZEtleSk7CiAgZm9yIChyb3VuZCA9IDE7IHJvdW5kIDw9IE5yOyArK3JvdW5kKSB7CiAgICBTdWJCeXRlcyhzdGF0ZSk7CiAgICBTaGlmdFJvd3Moc3RhdGUpOwogICAgaWYgKHJvdW5kIDwgTnIpIHsKICAgICAgTWl4Q29sdW1ucyhzdGF0ZSk7CiAgICB9CiAgICBBZGRSb3VuZEtleShyb3VuZCwgc3RhdGUsIFJvdW5kS2V5KTsKICB9Cn0=)1void  Cipher(state_t  state[4][4],  const  uint8_t  RoundKey[AES_keyExpSize])  {2  uint8_t  round;3  AddRoundKey(0,  state,  RoundKey);4  for  (round  =  1;  round  <=  Nr;  ++round)  {5  SubBytes(state);6  ShiftRows(state);7  if  (round  <  Nr)  {8  MixColumns(state);9  }10  AddRoundKey(round,  state,  RoundKey);11  }12}'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13: Human-in-the-loop AES Cipher'
  prefs: []
  type: TYPE_NORMAL
- en: '[⬇](data:text/plain;base64,T3JpZ2luYWwgYyBjb2RlIChhZnRlciByZW1vdmluZyBwcmludGYgcykgICBcZW5ke2xzdGxpc3Rpbmd9Clx2c3BhY2V7LTdwdH0KICBcZW5ke3N1YmZpZ3VyZX0KICBcYmVnaW57c3ViZmlndXJlfVt0XXsuOVxjb2x1bW53aWR0aH0KICAgIFxiZWdpbntsc3RsaXN0aW5nfVtsYW5ndWFnZT1jXQpzdGF0aWMgdm9pZCBNaXhDb2x1bW5zKHN0YXRlX3QqIHN0YXRlKQp7CiAgdWludDhfdCBpOwogIHVpbnQ4X3QgVG1wLCBUbSwgdDsKICBmb3IgKGkgPSAwOyBpIDwgNDsgKytpKQogIHsKICAgIHQgICA9ICgqc3RhdGUpW2ldWzBdOwogICAgVG1wID0gKCpzdGF0ZSlbaV1bMF0gXiAoKnN0YXRlKVtpXVsxXSBeICgqc3RhdGUpW2ldWzJdIF4gKCpzdGF0ZSlbaV1bM10gOwogICAgVG0gID0gKCpzdGF0ZSlbaV1bMF0gXiAoKnN0YXRlKVtpXVsxXSA7CiAgICBUbSA9IHh0aW1lKFRtKTsgICgqc3RhdGUpW2ldWzBdIF49IFRtIF4gVG1wIDsKICAgIFRtICA9ICgqc3RhdGUpW2ldWzFdIF4gKCpzdGF0ZSlbaV1bMl0gOwogICAgVG0gPSB4dGltZShUbSk7ICAoKnN0YXRlKVtpXVsxXSBePSBUbSBeIFRtcCA7CiAgICBUbSAgPSAoKnN0YXRlKVtpXVsyXSBeICgqc3RhdGUpW2ldWzNdIDsKICAgIFRtID0geHRpbWUoVG0pOyAgKCpzdGF0ZSlbaV1bMl0gXj0gVG0gXiBUbXAgOwogICAgVG0gID0gKCpzdGF0ZSlbaV1bM10gXiB0IDsKICAgIFRtID0geHRpbWUoVG0pOyAgKCpzdGF0ZSlbaV1bM10gXj0gVG0gXiBUbXAgOwogIH0KfQo=)1Original  c  code  (after  removing  printf  s)  \end{lstlisting}2\vspace{-7pt}3  \end{subfigure}4  \begin{subfigure}[t]{.9\columnwidth}5  \begin{lstlisting}[language=c]6static  void  MixColumns(state_t*  state)7{8  uint8_t  i;9  uint8_t  Tmp,  Tm,  t;10  for  (i  =  0;  i  <  4;  ++i)11  {12  t  =  (*state)[i][0];13  Tmp  =  (*state)[i][0]  ^  (*state)[i][1]  ^  (*state)[i][2]  ^  (*state)[i][3]  ;14  Tm  =  (*state)[i][0]  ^  (*state)[i][1]  ;15  Tm  =  xtime(Tm);  (*state)[i][0]  ^=  Tm  ^  Tmp  ;16  Tm  =  (*state)[i][1]  ^  (*state)[i][2]  ;17  Tm  =  xtime(Tm);  (*state)[i][1]  ^=  Tm  ^  Tmp  ;18  Tm  =  (*state)[i][2]  ^  (*state)[i][3]  ;19  Tm  =  xtime(Tm);  (*state)[i][2]  ^=  Tm  ^  Tmp  ;20  Tm  =  (*state)[i][3]  ^  t  ;21  Tm  =  xtime(Tm);  (*state)[i][3]  ^=  Tm  ^  Tmp  ;22  }23}[⬇](data:text/plain;base64,SExTIGNvbXBhdGlibGUgY29kZSByZXdyaXR0ZW4gYnkgdGhlIExMTQ==)1HLS  compatible  code  rewritten  by  the  LLM[⬇](data:text/plain;base64,c3RhdGljIHZvaWQgTWl4Q29sdW1ucyhzdGF0ZV90IHN0YXRlWzRdWzRdKSB7CiAgdWludDhfdCBpLCBUbXAsIFRtLCB0OwogIGZvciAoaSA9IDA7IGkgPCA0OyArK2kpIHsKICAgIHQgICA9IHN0YXRlW2ldWzBdOwogICAgVG1wID0gc3RhdGVbaV1bMF0gXiBzdGF0ZVtpXVsxXSBeIHN0YXRlW2ldWzJdIF4gc3RhdGVbaV1bM107CiAgICBUbSAgPSBzdGF0ZVtpXVswXSBeIHN0YXRlW2ldWzFdOyBUbSA9IHh0aW1lKFRtKTsKICAgIHN0YXRlW2ldWzBdIF49IFRtIF4gVG1wOwoKICAgIC8vIENvcnJlY3RlZCBsaW5lcyB3aXRoIGRpcmVjdCBhcnJheSBhY2Nlc3MKICAgIFRtICA9IHN0YXRlW2ldWzFdIF4gc3RhdGVbaV1bMl07IFRtID0geHRpbWUoVG0pOwogICAgc3RhdGVbaV1bMV0gXj0gVG0gXiBUbXA7CiAgICBUbSAgPSBzdGF0ZVtpXVsyXSBeIHN0YXRlW2ldWzNdOyBUbSA9IHh0aW1lKFRtKTsKICAgIHN0YXRlW2ldWzJdIF49IFRtIF4gVG1wOwogICAgVG0gID0gc3RhdGVbaV1bM10gXiB0OyAgICAgICAgICAgICAgVG0gPSB4dGltZShUbSk7CiAgICBzdGF0ZVtpXVszXSBePSBUbSBeIFRtcDsKICB9Cn0=)1static  void  MixColumns(state_t  state[4][4])  {2  uint8_t  i,  Tmp,  Tm,  t;3  for  (i  =  0;  i  <  4;  ++i)  {4  t  =  state[i][0];5  Tmp  =  state[i][0]  ^  state[i][1]  ^  state[i][2]  ^  state[i][3];6  Tm  =  state[i][0]  ^  state[i][1];  Tm  =  xtime(Tm);7  state[i][0]  ^=  Tm  ^  Tmp;89  //  Corrected  lines  with  direct  array  access10  Tm  =  state[i][1]  ^  state[i][2];  Tm  =  xtime(Tm);11  state[i][1]  ^=  Tm  ^  Tmp;12  Tm  =  state[i][2]  ^  state[i][3];  Tm  =  xtime(Tm);13  state[i][2]  ^=  Tm  ^  Tmp;14  Tm  =  state[i][3]  ^  t;  Tm  =  xtime(Tm);15  state[i][3]  ^=  Tm  ^  Tmp;16  }17}'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14: Human-in-the-loop AES Mix Columns'
  prefs: []
  type: TYPE_NORMAL
- en: '[⬇](data:text/plain;base64,T3JpZ2luYWwgYyBjb2RlIChhZnRlciByZW1vdmluZyBwcmludGYgcykgICBcZW5ke2xzdGxpc3Rpbmd9Clx2c3BhY2V7LTdwdH0KICBcZW5ke3N1YmZpZ3VyZX0KICBcYmVnaW57c3ViZmlndXJlfVt0XXsuOVxjb2x1bW53aWR0aH0KICAgIFxiZWdpbntsc3RsaXN0aW5nfVtsYW5ndWFnZT1jXQpzdGF0aWMgdm9pZCBTaGlmdFJvd3Moc3RhdGVfdCogc3RhdGUpCnsKICB1aW50OF90IHRlbXA7CgogIC8vIFJvdGF0ZSBmaXJzdCByb3cgMSBjb2x1bW5zIHRvIGxlZnQKICB0ZW1wICAgICAgICAgICA9ICgqc3RhdGUpWzBdWzFdOwogICgqc3RhdGUpWzBdWzFdID0gKCpzdGF0ZSlbMV1bMV07CiAgKCpzdGF0ZSlbMV1bMV0gPSAoKnN0YXRlKVsyXVsxXTsKICAoKnN0YXRlKVsyXVsxXSA9ICgqc3RhdGUpWzNdWzFdOwogICgqc3RhdGUpWzNdWzFdID0gdGVtcDsKCiAgLy8gUm90YXRlIHNlY29uZCByb3cgMiBjb2x1bW5zIHRvIGxlZnQKICB0ZW1wICAgICAgICAgICA9ICgqc3RhdGUpWzBdWzJdOwogICgqc3RhdGUpWzBdWzJdID0gKCpzdGF0ZSlbMl1bMl07CiAgKCpzdGF0ZSlbMl1bMl0gPSB0ZW1wOwoKICB0ZW1wICAgICAgICAgICA9ICgqc3RhdGUpWzFdWzJdOwogICgqc3RhdGUpWzFdWzJdID0gKCpzdGF0ZSlbM11bMl07CiAgKCpzdGF0ZSlbM11bMl0gPSB0ZW1wOwoKICAvLyBSb3RhdGUgdGhpcmQgcm93IDMgY29sdW1ucyB0byBsZWZ0CiAgdGVtcCAgICAgICAgICAgPSAoKnN0YXRlKVswXVszXTsKICAoKnN0YXRlKVswXVszXSA9ICgqc3RhdGUpWzNdWzNdOwogICgqc3RhdGUpWzNdWzNdID0gKCpzdGF0ZSlbMl1bM107CiAgKCpzdGF0ZSlbMl1bM10gPSAoKnN0YXRlKVsxXVszXTsKICAoKnN0YXRlKVsxXVszXSA9IHRlbXA7Cn0=)1Original  c  code  (after  removing  printf  s)  \end{lstlisting}2\vspace{-7pt}3  \end{subfigure}4  \begin{subfigure}[t]{.9\columnwidth}5  \begin{lstlisting}[language=c]6static  void  ShiftRows(state_t*  state)7{8  uint8_t  temp;910  //  Rotate  first  row  1  columns  to  left11  temp  =  (*state)[0][1];12  (*state)[0][1]  =  (*state)[1][1];13  (*state)[1][1]  =  (*state)[2][1];14  (*state)[2][1]  =  (*state)[3][1];15  (*state)[3][1]  =  temp;1617  //  Rotate  second  row  2  columns  to  left18  temp  =  (*state)[0][2];19  (*state)[0][2]  =  (*state)[2][2];20  (*state)[2][2]  =  temp;2122  temp  =  (*state)[1][2];23  (*state)[1][2]  =  (*state)[3][2];24  (*state)[3][2]  =  temp;2526  //  Rotate  third  row  3  columns  to  left27  temp  =  (*state)[0][3];28  (*state)[0][3]  =  (*state)[3][3];29  (*state)[3][3]  =  (*state)[2][3];30  (*state)[2][3]  =  (*state)[1][3];31  (*state)[1][3]  =  temp;32}[⬇](data:text/plain;base64,SExTIGNvbXBhdGlibGUgY29kZSByZXdyaXR0ZW4gYnkgdGhlIExMTQ==)1HLS  compatible  code  rewritten  by  the  LLM[⬇](data:text/plain;base64,c3RhdGljIHZvaWQgU2hpZnRSb3dzKHN0YXRlX3Qgc3RhdGVbNF1bNF0pIHsKICB1aW50OF90IHRlbXA7CiAgaW50IGksIGo7CgogIC8vIExvb3Agb3ZlciByb3dzIDEgdG8gMyAoMC1iYXNlZCBpbmRleGluZykKICBmb3IgKGkgPSAxOyBpIDwgNDsgKytpKSB7CiAgICAvLyBOdW1iZXIgb2YgcG9zaXRpb25zIHRvIGxlZnQgc2hpZnQgZm9yIGN1cnJlbnQgcm93CiAgICBpbnQgc2hpZnQgPSBpOwoKICAgIC8vIFVzZSBhIHNlcGFyYXRlIGxvb3AgZm9yIHRoZSBudW1iZXIgb2Ygc2hpZnRzCiAgICBmb3IgKGogPSAwOyBqIDwgc2hpZnQ7ICsraikgewogICAgICB0ZW1wID0gc3RhdGVbMF1baV07ICAvLyBTdG9yZSB0aGUgZWxlbWVudCB0byBiZSBzaGlmdGVkCiAgICAgIC8vIFNoaWZ0IGFsbCBlbGVtZW50cyBieSBvbmUgcG9zaXRpb24gdG8gdGhlIGxlZnQKICAgICAgZm9yIChpbnQgayA9IDA7IGsgPCAzOyArK2spIHsKICAgICAgICBzdGF0ZVtrXVtpXSA9IHN0YXRlW2sgKyAxXVtpXTsKICAgICAgfQogICAgICBzdGF0ZVszXVtpXSA9IHRlbXA7IC8vIFBsYWNlIHRoZSB0ZW1wIHZhbHVlIGF0IHRoZSBlbmQKICAgIH0KICB9Cn0=)1static  void  ShiftRows(state_t  state[4][4])  {2  uint8_t  temp;3  int  i,  j;45  //  Loop  over  rows  1  to  3  (0-based  indexing)6  for  (i  =  1;  i  <  4;  ++i)  {7  //  Number  of  positions  to  left  shift  for  current  row8  int  shift  =  i;910  //  Use  a  separate  loop  for  the  number  of  shifts11  for  (j  =  0;  j  <  shift;  ++j)  {12  temp  =  state[0][i];  //  Store  the  element  to  be  shifted13  //  Shift  all  elements  by  one  position  to  the  left14  for  (int  k  =  0;  k  <  3;  ++k)  {15  state[k][i]  =  state[k  +  1][i];16  }17  state[3][i]  =  temp;  //  Place  the  temp  value  at  the  end18  }19  }20}'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15: Human-in-the-loop AES Shift Rows'
  prefs: []
  type: TYPE_NORMAL
- en: '[⬇](data:text/plain;base64,T3JpZ2luYWwgYyBjb2RlIChhZnRlciByZW1vdmluZyBwcmludGYgcykgICBcZW5ke2xzdGxpc3Rpbmd9Clx2c3BhY2V7LTdwdH0KICBcZW5ke3N1YmZpZ3VyZX0KICBcYmVnaW57c3ViZmlndXJlfVt0XXsuOVxjb2x1bW53aWR0aH0KICAgIFxiZWdpbntsc3RsaXN0aW5nfVtsYW5ndWFnZT1jXQpzdGF0aWMgdm9pZCBTdWJCeXRlcyhzdGF0ZV90KiBzdGF0ZSkKewogIHVpbnQ4X3QgaSwgajsKICBmb3IgKGkgPSAwOyBpIDwgNDsgKytpKQogIHsKICAgIGZvciAoaiA9IDA7IGogPCA0OyArK2opCiAgICB7CiAgICAgICgqc3RhdGUpW2pdW2ldID0gZ2V0U0JveFZhbHVlKCgqc3RhdGUpW2pdW2ldKTsKICAgIH0KICB9Cn0=)1Original  c  code  (after  removing  printf  s)  \end{lstlisting}2\vspace{-7pt}3  \end{subfigure}4  \begin{subfigure}[t]{.9\columnwidth}5  \begin{lstlisting}[language=c]6static  void  SubBytes(state_t*  state)7{8  uint8_t  i,  j;9  for  (i  =  0;  i  <  4;  ++i)10  {11  for  (j  =  0;  j  <  4;  ++j)12  {13  (*state)[j][i]  =  getSBoxValue((*state)[j][i]);14  }15  }16}[⬇](data:text/plain;base64,SExTIGNvbXBhdGlibGUgY29kZSByZXdyaXR0ZW4gYnkgdGhlIExMTQ==)1HLS  compatible  code  rewritten  by  the  LLM[⬇](data:text/plain;base64,c3RhdGljIHZvaWQgU3ViQnl0ZXMoc3RhdGVfdCBzdGF0ZVs0XVs0XSkgewogIHVpbnQ4X3QgaSwgajsKICBmb3IgKGkgPSAwOyBpIDwgNDsgKytpKSB7CiAgICBmb3IgKGogPSAwOyBqIDwgNDsgKytqKSB7CiAgICAgIHN0YXRlW2pdW2ldID0gZ2V0U0JveFZhbHVlKHN0YXRlW2pdW2ldKTsKICAgIH0KICB9)1static  void  SubBytes(state_t  state[4][4])  {2  uint8_t  i,  j;3  for  (i  =  0;  i  <  4;  ++i)  {4  for  (j  =  0;  j  <  4;  ++j)  {5  state[j][i]  =  getSBoxValue(state[j][i]);6  }7  }'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16: Human-in-the-loop AES Sub Bytes'
  prefs: []
  type: TYPE_NORMAL
- en: '[⬇](data:text/plain;base64,T3JpZ2luYWwgYyBjb2RlIChhZnRlciByZW1vdmluZyBwcmludGYgcykgICBcZW5ke2xzdGxpc3Rpbmd9Clx2c3BhY2V7LTdwdH0KICBcZW5ke3N1YmZpZ3VyZX0KICBcYmVnaW57c3ViZmlndXJlfVt0XXsuOVxjb2x1bW53aWR0aH0KICAgIFxiZWdpbntsc3RsaXN0aW5nfVtsYW5ndWFnZT1jXQpzdGF0aWMgdm9pZCBBZGRSb3VuZEtleSh1aW50OF90IHJvdW5kLCBzdGF0ZV90KiBzdGF0ZSwgY29uc3QgdWludDhfdCogUm91bmRLZXkpCnsKICB1aW50OF90IGksajsKICBmb3IgKGkgPSAwOyBpIDwgNDsgKytpKQogIHsKICAgIGZvciAoaiA9IDA7IGogPCA0OyArK2opCiAgICB7CiAgICAgICgqc3RhdGUpW2ldW2pdIF49IFJvdW5kS2V5Wyhyb3VuZCAqIE5iICogNCkgKyAoaSAqIE5iKSArIGpdOwogICAgfQogIH0KfQ==)1Original  c  code  (after  removing  printf  s)  \end{lstlisting}2\vspace{-7pt}3  \end{subfigure}4  \begin{subfigure}[t]{.9\columnwidth}5  \begin{lstlisting}[language=c]6static  void  AddRoundKey(uint8_t  round,  state_t*  state,  const  uint8_t*  RoundKey)7{8  uint8_t  i,j;9  for  (i  =  0;  i  <  4;  ++i)10  {11  for  (j  =  0;  j  <  4;  ++j)12  {13  (*state)[i][j]  ^=  RoundKey[(round  *  Nb  *  4)  +  (i  *  Nb)  +  j];14  }15  }16}[⬇](data:text/plain;base64,SExTIGNvbXBhdGlibGUgY29kZSByZXdyaXR0ZW4gYnkgdGhlIExMTQ==)1HLS  compatible  code  rewritten  by  the  LLM[⬇](data:text/plain;base64,c3RhdGljIHZvaWQgQWRkUm91bmRLZXkodWludDhfdCByb3VuZCwgc3RhdGVfdCBzdGF0ZVs0XVs0XSwgY29uc3QgdWludDhfdCBSb3VuZEtleVtBRVNfS0VZTEVOXSkgewogIHVpbnQ4X3QgaSwgajsKICB1aW50OF90IGJhc2UgPSByb3VuZCAqIE5iICogNDsKICBmb3IgKGkgPSAwOyBpIDwgNDsgKytpKSB7CiAgICBmb3IgKGogPSAwOyBqIDwgNDsgKytqKSB7CiAgICAgIHN0YXRlW2ldW2pdIF49IFJvdW5kS2V5W2Jhc2UgKyAoaSAqIE5iKSArIGpdOwogICAgfQogIH0KfQ==)1static  void  AddRoundKey(uint8_t  round,  state_t  state[4][4],  const  uint8_t  RoundKey[AES_KEYLEN])  {2  uint8_t  i,  j;3  uint8_t  base  =  round  *  Nb  *  4;4  for  (i  =  0;  i  <  4;  ++i)  {5  for  (j  =  0;  j  <  4;  ++j)  {6  state[i][j]  ^=  RoundKey[base  +  (i  *  Nb)  +  j];7  }8  }9}'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 17: Human-in-the-loop AES Add Round Key'
  prefs: []
  type: TYPE_NORMAL
- en: '[⬇](data:text/plain;base64,SExTIGNvbXBhdGlibGUgY29kZSBmcm9tIHRoZSBoYW5kcy1mcmVlIGZsb3c=)1HLS  compatible  code  from  the  hands-free  flow[⬇](data:text/plain;base64,Ly8gRnVuY3Rpb24gdG8gc3dhcCB0d28gZWxlbWVudHMKdm9pZCBzd2FwKGludCogYSwgaW50KiBiKXsKaW50IHRlbXAgPSAqYTsKKmEgPSAqYjsKKmIgPSB0ZW1wO30KaW50IHBhcnRpdGlvbihpbnQgYXJyW10sIGludCBsb3csIGludCBoaWdoKXsKaW50IHBpdm90ID0gYXJyW2xvd107CmludCBpID0gbG93OwppbnQgaiA9IGhpZ2g7CndoaWxlIChpIDwgail7CiAgICB3aGlsZSAoYXJyW2ldIDw9IHBpdm90ICYmIGkgPD0gaGlnaCAtIDEpewogICAgICAgIGkrKzsKICAgIH0KICAgIHdoaWxlIChhcnJbal0gPiBwaXZvdCAmJiBqID49IGxvdyArIDEpewogICAgICAgIGotLTsKICAgIH0KICAgIGlmIChpIDwgail7CiAgICAgICAgc3dhcCgmYXJyW2ldLCAmYXJyW2pdKTsKICAgIH0KfQpzd2FwKCZhcnJbbG93XSwgJmFycltqXSk7CnJldHVybiBqOwp9CnZvaWQgcXVpY2tTb3J0KGludCBhcnJbNjRdLCBpbnQgbG93LCBpbnQgaGlnaCl7CmludCBzdGFja1sxMjhdOyAvLyBGaXhlZCBzaXplIHN0YWNrIHRvIHdvcmsgd2l0aCBITFMgdG9vbHMKaW50IHRvcCA9IC0xOwpzdGFja1srK3RvcF0gPSBsb3c7CnN0YWNrWysrdG9wXSA9IGhpZ2g7CndoaWxlICh0b3AgPj0gMCl7CiAgICBoaWdoID0gc3RhY2tbdG9wLS1dOwogICAgbG93ID0gc3RhY2tbdG9wLS1dOwogICAgaWYgKGxvdyA8IGhpZ2gpewogICAgICAgIGludCBwYXJ0aXRpb25JbmRleCA9IHBhcnRpdGlvbihhcnIsIGxvdywgaGlnaCk7CiAgICAgICAgc3RhY2tbKyt0b3BdID0gbG93OwogICAgICAgIHN0YWNrWysrdG9wXSA9IHBhcnRpdGlvbkluZGV4IC0gMTsKICAgICAgICBzdGFja1srK3RvcF0gPSBwYXJ0aXRpb25JbmRleCArIDE7CiAgICAgICAgc3RhY2tbKyt0b3BdID0gaGlnaDsKfX19)1//  Function  to  swap  two  elements2void  swap(int*  a,  int*  b){3int  temp  =  *a;4*a  =  *b;5*b  =  temp;}6int  partition(int  arr[],  int  low,  int  high){7int  pivot  =  arr[low];8int  i  =  low;9int  j  =  high;10while  (i  <  j){11  while  (arr[i]  <=  pivot  &&  i  <=  high  -  1){12  i++;13  }14  while  (arr[j]  >  pivot  &&  j  >=  low  +  1){15  j--;16  }17  if  (i  <  j){18  swap(&arr[i],  &arr[j]);19  }20}21swap(&arr[low],  &arr[j]);22return  j;23}24void  quickSort(int  arr[64],  int  low,  int  high){25int  stack[128];  //  Fixed  size  stack  to  work  with  HLS  tools26int  top  =  -1;27stack[++top]  =  low;28stack[++top]  =  high;29while  (top  >=  0){30  high  =  stack[top--];31  low  =  stack[top--];32  if  (low  <  high){33  int  partitionIndex  =  partition(arr,  low,  high);34  stack[++top]  =  low;35  stack[++top]  =  partitionIndex  -  1;36  stack[++top]  =  partitionIndex  +  1;37  stack[++top]  =  high;38}}}'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 18: Hands-free C2HLSC QuickSort'
  prefs: []
  type: TYPE_NORMAL
- en: '[⬇](data:text/plain;base64,SExTIGNvbXBhdGlibGUgY29kZSBmcm9tIHRoZSBoYW5kcy1mcmVlIGZsb3c=)1HLS  compatible  code  from  the  hands-free  flow[⬇](data:text/plain;base64,dm9pZCBBZGRSb3VuZEtleSh1aW50OF90IHJvdW5kLCBzdGF0ZV90IHN0YXRlLCBjb25zdCB1aW50OF90KiBSb3VuZEtleSkKewp1aW50OF90IGksIGo7CnVpbnQ4X3QgUm91bmRLZXlfbG9jYWxbQUVTX2tleUV4cFNpemVdOwpmb3IgKGkgPSAwOyBpIDwgQUVTX2tleUV4cFNpemU7ICsraSkKewojcHJhZ21hIEhMUyBQSVBFTElORSBJST0xCiAgICBSb3VuZEtleV9sb2NhbFtpXSA9IFJvdW5kS2V5W2ldOwp9CmZvciAoaSA9IDA7IGkgPCA0OyArK2kpCnsKICAgIGZvciAoaiA9IDA7IGogPCA0OyArK2opCiAgICB7CiNwcmFnbWEgSExTIFBJUEVMSU5FIElJPTEKICAgICAgICBzdGF0ZVtpXVtqXSBePSBSb3VuZEtleV9sb2NhbFsocm91bmQgKiBOYiAqIDQpICsgKGkgKiBOYikgKyBqXTsKICAgIH0KfQp9)1void  AddRoundKey(uint8_t  round,  state_t  state,  const  uint8_t*  RoundKey)2{3uint8_t  i,  j;4uint8_t  RoundKey_local[AES_keyExpSize];5for  (i  =  0;  i  <  AES_keyExpSize;  ++i)6{7#pragma  HLS  PIPELINE  II=18  RoundKey_local[i]  =  RoundKey[i];9}10for  (i  =  0;  i  <  4;  ++i)11{12  for  (j  =  0;  j  <  4;  ++j)13  {14#pragma  HLS  PIPELINE  II=115  state[i][j]  ^=  RoundKey_local[(round  *  Nb  *  4)  +  (i  *  Nb)  +  j];16  }17}18}'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 19: Hands-free C2HLSC AES Add Round Key'
  prefs: []
  type: TYPE_NORMAL
- en: '[⬇](data:text/plain;base64,SExTIGNvbXBhdGlibGUgY29kZSBmcm9tIHRoZSBoYW5kcy1mcmVlIGZsb3c=)1HLS  compatible  code  from  the  hands-free  flow[⬇](data:text/plain;base64,dm9pZCBTaGlmdFJvd3Moc3RhdGVfdCBzdGF0ZSkgewogICAgdWludDhfdCB0ZW1wOwoKICAgIC8vIFJvdGF0ZSBmaXJzdCByb3cgMSBjb2x1bW4gdG8gdGhlIGxlZnQKICAgIHRlbXAgPSBzdGF0ZVswXVsxXTsKICAgIHN0YXRlWzBdWzFdID0gc3RhdGVbMV1bMV07CiAgICBzdGF0ZVsxXVsxXSA9IHN0YXRlWzJdWzFdOwogICAgc3RhdGVbMl1bMV0gPSBzdGF0ZVszXVsxXTsKICAgIHN0YXRlWzNdWzFdID0gdGVtcDsKCiAgICAvLyBSb3RhdGUgc2Vjb25kIHJvdyAyIGNvbHVtbnMgdG8gdGhlIGxlZnQKICAgIHRlbXAgPSBzdGF0ZVswXVsyXTsKICAgIHN0YXRlWzBdWzJdID0gc3RhdGVbMl1bMl07CiAgICBzdGF0ZVsyXVsyXSA9IHRlbXA7CgogICAgdGVtcCA9IHN0YXRlWzFdWzJdOwogICAgc3RhdGVbMV1bMl0gPSBzdGF0ZVszXVsyXTsKICAgIHN0YXRlWzNdWzJdID0gdGVtcDsKCiAgICAvLyBSb3RhdGUgdGhpcmQgcm93IDMgY29sdW1ucyB0byB0aGUgbGVmdAogICAgdGVtcCA9IHN0YXRlWzBdWzNdOwogICAgc3RhdGVbMF1bM10gPSBzdGF0ZVszXVszXTsKICAgIHN0YXRlWzNdWzNdID0gc3RhdGVbMl1bM107CiAgICBzdGF0ZVsyXVszXSA9IHN0YXRlWzFdWzNdOwogICAgc3RhdGVbMV1bM10gPSB0ZW1wOwp9)1void  ShiftRows(state_t  state)  {2  uint8_t  temp;34  //  Rotate  first  row  1  column  to  the  left5  temp  =  state[0][1];6  state[0][1]  =  state[1][1];7  state[1][1]  =  state[2][1];8  state[2][1]  =  state[3][1];9  state[3][1]  =  temp;1011  //  Rotate  second  row  2  columns  to  the  left12  temp  =  state[0][2];13  state[0][2]  =  state[2][2];14  state[2][2]  =  temp;1516  temp  =  state[1][2];17  state[1][2]  =  state[3][2];18  state[3][2]  =  temp;1920  //  Rotate  third  row  3  columns  to  the  left21  temp  =  state[0][3];22  state[0][3]  =  state[3][3];23  state[3][3]  =  state[2][3];24  state[2][3]  =  state[1][3];25  state[1][3]  =  temp;26}'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 20: Hands-free C2HLSC AES Shift Rows'
  prefs: []
  type: TYPE_NORMAL
- en: '[⬇](data:text/plain;base64,SExTIGNvbXBhdGlibGUgY29kZSBmcm9tIHRoZSBoYW5kcy1mcmVlIGZsb3c=)1HLS  compatible  code  from  the  hands-free  flow[⬇](data:text/plain;base64,dm9pZCBNaXhDb2x1bW5zKHN0YXRlX3Qgc3RhdGUpCnsKICAgIHVpbnQ4X3QgaTsKICAgIHVpbnQ4X3QgVG1wLCBUbSwgdDsKICAgIGZvciAoaSA9IDA7IGkgPCA0OyArK2kpCiAgICB7CiAgICAgICAgdCAgID0gc3RhdGVbaV1bMF07CiAgICAgICAgVG1wID0gc3RhdGVbaV1bMF0gXiBzdGF0ZVtpXVsxXSBeIHN0YXRlW2ldWzJdIF4gc3RhdGVbaV1bM107CiAgICAgICAgVG0gID0gc3RhdGVbaV1bMF0gXiBzdGF0ZVtpXVsxXTsgVG0gPSB4dGltZShUbSk7IHN0YXRlW2ldWzBdIF49IFRtIF4gVG1wOwogICAgICAgIFRtICA9IHN0YXRlW2ldWzFdIF4gc3RhdGVbaV1bMl07IFRtID0geHRpbWUoVG0pOyBzdGF0ZVtpXVsxXSBePSBUbSBeIFRtcDsKICAgICAgICBUbSAgPSBzdGF0ZVtpXVsyXSBeIHN0YXRlW2ldWzNdOyBUbSA9IHh0aW1lKFRtKTsgc3RhdGVbaV1bMl0gXj0gVG0gXiBUbXA7CiAgICAgICAgVG0gID0gc3RhdGVbaV1bM10gXiB0OyAgICAgICAgICAgIFRtID0geHRpbWUoVG0pOyBzdGF0ZVtpXVszXSBePSBUbSBeIFRtcDsKICAgIH0KfQ==)1void  MixColumns(state_t  state)2{3  uint8_t  i;4  uint8_t  Tmp,  Tm,  t;5  for  (i  =  0;  i  <  4;  ++i)6  {7  t  =  state[i][0];8  Tmp  =  state[i][0]  ^  state[i][1]  ^  state[i][2]  ^  state[i][3];9  Tm  =  state[i][0]  ^  state[i][1];  Tm  =  xtime(Tm);  state[i][0]  ^=  Tm  ^  Tmp;10  Tm  =  state[i][1]  ^  state[i][2];  Tm  =  xtime(Tm);  state[i][1]  ^=  Tm  ^  Tmp;11  Tm  =  state[i][2]  ^  state[i][3];  Tm  =  xtime(Tm);  state[i][2]  ^=  Tm  ^  Tmp;12  Tm  =  state[i][3]  ^  t;  Tm  =  xtime(Tm);  state[i][3]  ^=  Tm  ^  Tmp;13  }14}'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 21: Hands-free C2HLSC AES Mix Columns'
  prefs: []
  type: TYPE_NORMAL
- en: '[⬇](data:text/plain;base64,SExTIGNvbXBhdGlibGUgY29kZSBmcm9tIHRoZSBoYW5kcy1mcmVlIGZsb3c=)1HLS  compatible  code  from  the  hands-free  flow[⬇](data:text/plain;base64,I2RlZmluZSBnZXRTQm94VmFsdWUobnVtKSAoc2JveFsobnVtKV0pCgovLyBUaGUgU3ViQnl0ZXMgRnVuY3Rpb24gU3Vic3RpdHV0ZXMgdGhlIHZhbHVlcyBpbiB0aGUKLy8gc3RhdGUgbWF0cml4IHdpdGggdmFsdWVzIGluIGFuIFMtYm94LgpzdGF0aWMgdm9pZCBTdWJCeXRlcyhzdGF0ZV90IHN0YXRlKQp7CiAgICB1aW50OF90IGksIGo7CiAgICBmb3IgKGkgPSAwOyBpIDwgNDsgKytpKQogICAgewogICAgICAgIGZvciAoaiA9IDA7IGogPCA0OyArK2opCiAgICAgICAgewogICAgICAgICAgICBzdGF0ZVtqXVtpXSA9IGdldFNCb3hWYWx1ZShzdGF0ZVtqXVtpXSk7CiAgICAgICAgfQogICAgfQp9)1#define  getSBoxValue(num)  (sbox[(num)])23//  The  SubBytes  Function  Substitutes  the  values  in  the4//  state  matrix  with  values  in  an  S-box.5static  void  SubBytes(state_t  state)6{7  uint8_t  i,  j;8  for  (i  =  0;  i  <  4;  ++i)9  {10  for  (j  =  0;  j  <  4;  ++j)11  {12  state[j][i]  =  getSBoxValue(state[j][i]);13  }14  }15}'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 22: Hands-free C2HLSC AES Sub Bytes'
  prefs: []
  type: TYPE_NORMAL
- en: -B Waveforms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: -C Conversations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here we list the links to the conversations to go from C to HLS C.
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Frequency Test: https://g.co/gemini/share/ba393c5de5a6](https://g.co/gemini/share/ba393c5de5a6)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Frequency Block Test: https://g.co/gemini/share/659379d677c0](https://g.co/gemini/share/659379d677c0)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Cumulative Sums Test: https://g.co/gemini/share/0f35a4d248e7](https://g.co/gemini/share/0f35a4d248e7)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[QuickSort: https://g.co/gemini/share/92b68e7849fc](https://g.co/gemini/share/92b68e7849fc)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[AES 128: https://g.co/gemini/share/92b68e7849fc](https://g.co/gemini/share/92b68e7849fc)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: •
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Overlapping Template Matching Test: https://g.co/gemini/share/c1ac0cef56f2](https://g.co/gemini/share/c1ac0cef56f2)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
